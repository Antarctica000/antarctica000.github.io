<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis在SpringBoot中的一些特殊用法</title>
      <link href="/2020/03/27/redis2/"/>
      <url>/2020/03/27/redis2/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis在SpringBoot中的一些特殊用法"><a href="#Redis在SpringBoot中的一些特殊用法" class="headerlink" title="Redis在SpringBoot中的一些特殊用法"></a>Redis在SpringBoot中的一些特殊用法</h2><p>Redis除了操作那些数据类型的功能外，j巫能支持事务、流水线、发布订阅和Luai吾等功能，这也是Redis常用的功能。在高并发的场景中，往往我们需要保证数据的一致性，这时考虑使用Redis务或者利用Redis执行Lua的原子性来达到数据一致性的目的，所以这里让我们对它们展开讨论。需要大批量执行Redis令的时候，我们可以使用流水线来执行命令，这样可以极大地提Redis执行的速度。</p><h3 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h3><p>首先Redis是支持一定事务能力的NoSQL，在Redis中使用事务，通常的命令组合是watch…multi…exec，也就是要在一个Redis连接中执行多个命令，这时我们可以考虑使用SessionCallback接口来达到这个目的。</p><p>其中，watch命令是可以监控Redis的一些键multi命令是开始事务，开始事务，该客户端的命令不会马上被执行，而是存放在一个队列里，这点是需要注意的地方，也就是在这时我们执行一些堪回数据的命令，Redis也是不会马上执行的，而是把命令放到一个队列里，所以时调用Redis的命令，结果都是返回null，这是初学者容易犯的错误：exe命令的意义在于执行事，只是它在队列命令执行前会判断被watch监控的Redis的键的数据是否发生过变化（即使赋予与前相同的值也会被认为是变化过〉，如果它认为发生了变化，那么Redis就会取消事务，否则就会行事务，Redis在执行事务时，要么全部执行，要么全部不执行，而且不会被其他客户端打断，这就保证了Redis事务下数据的一致性。</p><p>如图，这就是Redis事务的执行流程：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/1009.jpg" alt=""></p><p>下面我们来测试一下这个过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"key1"</span>,<span class="string">"value1"</span>);</span><br><span class="line">    List list = (List) redisTemplate.execute((RedisOperations operations) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 设置要监控key1</span></span><br><span class="line">        operations.watch(<span class="string">"key1"</span>);</span><br><span class="line">        <span class="comment">// 开启事务，在exec命令执行前，全部都只是进入队列</span></span><br><span class="line">        operations.multi();</span><br><span class="line">        operations.opsForValue().set(<span class="string">"key2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">        operations.opsForValue().increment(<span class="string">"key1"</span>, <span class="number">1</span>);<span class="comment">// ①</span></span><br><span class="line">        <span class="comment">// 获取值将为null，因为redis只是把命令放入队列，</span></span><br><span class="line">        Object value2 = operations.opsForValue().get(<span class="string">"key2"</span>);</span><br><span class="line">        System.out.println(<span class="string">"命令在队列，所以value为null【"</span> + value2 + <span class="string">"】"</span>);</span><br><span class="line">        operations.opsForValue().set(<span class="string">"key3"</span>, <span class="string">"value3"</span>);</span><br><span class="line">        Object value3 = operations.opsForValue().get(<span class="string">"key3"</span>);</span><br><span class="line">        System.out.println(<span class="string">"命令在队列，所以value为null【"</span> + value3 + <span class="string">"】"</span>);</span><br><span class="line">        <span class="comment">// 执行exec命令，将先判别key1是否在监控后被修改过，如果是不执行事务，否则执行事务</span></span><br><span class="line">        <span class="keyword">return</span> operations.exec();<span class="comment">// ②</span></span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来做两种测试：</p><p>1：在Redis客户端清空key2和key3两个键的数据，然后在②处设置断点，在调试的环境下让请求达到断点，此时在Redis上修改keyl的值，然后再跳过断点，在请求完成后在Redis上查询key2和key3值，可以发现key2、key3返回的值都为空（nil），因为程序中先使得Redis的watch命令监控了keyl的值，而后的multi让之后的命令进入队列，而在exec方法运行前我们修改了keyl，根据Redis事务的规则，它在exec方法后会探测keyl是否被修改过，如果没有则会执行事务，否则就取消事务，所以key2和key3没有被保存到Redis服务器中。</p><p>测试结果：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2001.jpg" alt=""></p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2002.jpg" alt=""></p><p>2：续把key2和key3两个值清空，把①处的注释取消，让代码可以运行，因为key1是一个字符串，所以这里的代码是对字符串加一，这显然是不能运算的。同样地，我们运行这段代码后，可以看到服务器抛出了异常，然后我们去Redis服务器查询key2和key3，可以看到它们已经有了值。注意，这就是Redis事务和数据库事务的不一样，对于Redis事务是先让命令进入队列，所以一开始它并没有检测这个加一命令是否能够成功，只有在exec命令执行的时候，才能发现错误，对于出错的命令Redis只是报出错误，而错误后面的命令依旧被执行，所以key2和key3都存在数据，这就是Redis事务的特点，也是使用Redis事务需要特别注意的地方。为了克服这个问题，一般我们要在执行Redis事务前，严格地检查数据，以避免这样的情况发生。</p><p>测试结果：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2003.jpg" alt=""></p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2004.jpg" alt=""></p><h3 id="使用Redis流水线"><a href="#使用Redis流水线" class="headerlink" title="使用Redis流水线"></a>使用Redis流水线</h3><p>默认的情况下，Redis客户端是一条条命令发送给Redis服务器的，这样显然性能不高。在关系数据库中我们可以使用批量，也就是只有需要执行SQL时，才一次性地发送所有的SQL去执行，这样性能就提高了许多。对于Redis也是可以的，这便是流水线（pipline）技术，在很多情况下并不是Redis性能不佳，而是网络传输的速度造成瓶颈，使用流水线后就可以大幅度地在需要执行很多命令时提升Redis的性能。</p><p>接下来我们就来试试使用了SessionCallBack接口的，单流水线性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Long start = System.currentTimeMillis();</span><br><span class="line">    List list = (List) redisTemplate.executePipelined((RedisOperations operations) -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            operations.opsForValue().set(<span class="string">"pipeline_"</span> + i, <span class="string">"value_"</span> + i);</span><br><span class="line">            String value = (String) operations.opsForValue().get(<span class="string">"pipeline_"</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">100000</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"命令只是进入队列，所以值为空【"</span> + value + <span class="string">"】"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    Long end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"耗时："</span> + (end - start) + <span class="string">"毫秒。"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2005.jpg" alt=""></p><p>这里还是沿用SessionCallback接口执行写入和读出各10万次Redis命令，只是修改为了Lambda表达式而己如果你的JDK达不到8的版本以上，那么只能采用匿名类的形式来改写这段代码了。</p><p>为了测试性能，这里记录了开始执行时间和结束执行时间，并且打出了耗时。在我的测试中，这10万次读写基本在300～600ms，大约平均值在400～500ms，也就是不到ls就能执行10万次读和写命令，这个速度还是十分快的。在使用非流水线的情况下，我的测试大约每秒只能执行2～3万条命令，可见使用流水线后可以提升大约10倍的速度，它十分适合大数据量的执行。</p><p>但是需要注意以下两点：</p><ul><li>此代码只是运用于测试，在运行如此多的命令时，需要考虑的另外一个问题是内存空间的消耗，因对于程序而言，它最终会返一个List象，如果过的命令执行返回的结果都保存到这个List中，显然会造成内存消耗过大，尤其在那些高并发的网站中就很容易造成川、内存溢出的异常，这个时候应该考虑使用迭代的方法执行Redis命令。</li><li>与事务一样，使用流水线的过程中，有的命令也只是进入队列而没有执行，所以执行的命令返回值也为空，这也是需要注意的地方。</li></ul><h3 id="使用Redis发布订阅"><a href="#使用Redis发布订阅" class="headerlink" title="使用Redis发布订阅"></a>使用Redis发布订阅</h3><p>发布订阅是消息的一种常用模式。例如，在企业分配任务之后，可以通过邮件、短信或者微信通知到相关的责任人，这就是一种典型的发布订阅模式。首先是Redis提供一个渠道，让消息能够发送到这个渠道上，而多个系统可以监听这个渠道，如短信、微信和邮件系统都可以监昕这个渠道，当一条消息发送到渠道，渠道就会通知它的监昕者，这样短信、微信邮件系统就能够得到这个渠道给它们的消息了，这些监听者会根据自己的需要去处理这个消息，于是我们就可以得到各种各样的通知了。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/1010.jpg" alt=""></p><p>为了接收到Redis发送过来的消息，我们需要定义一个消息监听器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisMessageListener</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, <span class="keyword">byte</span>[] pattern)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 消息体</span></span><br><span class="line">        String body = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">        <span class="comment">// 渠道名称</span></span><br><span class="line">        String topic = <span class="keyword">new</span> String(pattern); </span><br><span class="line">        System.out.println(body);</span><br><span class="line">        System.out.println(topic);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的onMessage方法是得到消息后的处理方法，其中message参数代表Redis发送过来的消息，pattern是渠道名称，。且也在Message方法里打印了它们的内容。这里因为标注了＠Component注解，所以在SpringBoot扫描后，会把它自动装配到IoC容器中。</p><p>此外，还需要监听容器的配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerContainer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Redis连接工厂</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisConnectionFactory connectionFactory = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Redis消息监听器</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MessageListener redisMsgListener = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务池</span></span><br><span class="line"><span class="keyword">private</span> ThreadPoolTaskScheduler taskScheduler = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建任务池，运行线程等待处理Redis的消息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ThreadPoolTaskScheduler <span class="title">initTaskScheduler</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (taskScheduler != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> taskScheduler;</span><br><span class="line">&#125;</span><br><span class="line">taskScheduler = <span class="keyword">new</span> ThreadPoolTaskScheduler();</span><br><span class="line">taskScheduler.setPoolSize(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">return</span> taskScheduler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义Redis的监听容器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 监听容器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisMessageListenerContainer <span class="title">initRedisContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">RedisMessageListenerContainer container = <span class="keyword">new</span> RedisMessageListenerContainer();</span><br><span class="line"><span class="comment">// Redis连接工厂</span></span><br><span class="line">container.setConnectionFactory(connectionFactory);</span><br><span class="line"><span class="comment">// 设置运行任务池</span></span><br><span class="line">container.setTaskExecutor(initTaskScheduler());</span><br><span class="line"><span class="comment">// 定义监听渠道，名称为topic1</span></span><br><span class="line">Topic topic = <span class="keyword">new</span> ChannelTopic(<span class="string">"topic1"</span>);</span><br><span class="line"><span class="comment">// 使用监听器监听Redis的消息</span></span><br><span class="line">container.addMessageListener(redisMsgListener, topic);</span><br><span class="line"><span class="keyword">return</span> container;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里RedisTemplate和RedisConnectionFactory象都是SpringBoot自动创建的，所以这里只是把它们注入进来，只需要使用＠Autowired解即。然后定义了一个任务池，并设置了任务池大小为20，这样它将可以运行线程，井进行阻塞，等待Redis消息的传入。</p><p>接着再定义了一个Redis消息听的容器RedisMessageListenerContainer，并且往容器设置了Redis连接工厂和指定运行消息的线程池，定义了接收“topicl”渠道的消息，这样系统就可以监听Redis关于“topicl＂渠道的消息了。</p><p>测试结果：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2007.jpg" alt=""></p><h3 id="使用Lua脚本"><a href="#使用Lua脚本" class="headerlink" title="使用Lua脚本"></a>使用Lua脚本</h3><p>Redis中有很多的命令，但是严格来说Redis提供的计算能力还是比较有限的。为了增强Redis计算能力，Redis在2.6版本后提供了Lua脚本的支持，而且执行Lua脚本在Redis中还具备原子性，所以在需要保证数据一致性的高并发环境中，我们也可以使用Redis的Lua语言来保证数据的一致性，且Lua脚本具备更加强大的运算功能，在高并发需要保证数据一致性时，Lua脚本方案比使用Redis自身提供的事务要更好一些。</p><p>在Redis中有两种运行Lua的方法，一种是直接发送Lua到Redis服务器去执行，另一种是先把Lua发送给Redis,Redis对Lua脚本进行缓存，然后返回一个SHAl的32位编码回来，之后只需要发送SHAl相关参数给Redis便可以执行了。这里需要解释的是为什么会存在通过32位编码执行的方法。如果Lua脚本很长，那么就需要通过网络传递脚本给Redis去执了，而现实的情况是网络的传递速度往往跟不上Redis的执行速度，所以网络就会成为Redis执行的瓶颈。如果只是传递32位编码参数，那么需要传递的消息就少了许多，这样就可以极大地减少网络传输的内容，从而提高系统的性能。</p><p>为了支持Redis的Lua脚本，Spring供了RedisScript接口，与此同时也有一个DefaultRedisScript实现类。让我们先来看看RedisScript接口的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RedisScript</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取脚本的sha1</span></span><br><span class="line">    <span class="function">String <span class="title">getSha1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取脚本的返回值</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">Class&lt;T&gt; <span class="title">getResultType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取脚本的字符串</span></span><br><span class="line">    <span class="function">String <span class="title">getScriptAsString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">returnsRawValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getResultType() == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">RedisScript&lt;T&gt; <span class="title">of</span><span class="params">(String script)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultRedisScript(script);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">RedisScript <span class="title">of</span><span class="params">(String script, Class&lt;T&gt; resultType)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(script, <span class="string">"Script must not be null!"</span>);</span><br><span class="line">        Assert.notNull(resultType, <span class="string">"ResultType must not be null!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultRedisScript(script, resultType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">RedisScript&lt;T&gt; <span class="title">of</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(resource, <span class="string">"Resource must not be null!"</span>);</span><br><span class="line">        DefaultRedisScript&lt;T&gt; script = <span class="keyword">new</span> DefaultRedisScript();</span><br><span class="line">        script.setLocation(resource);</span><br><span class="line">        <span class="keyword">return</span> script;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">RedisScript&lt;T&gt; <span class="title">of</span><span class="params">(Resource resource, Class&lt;T&gt; resultType)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(resource, <span class="string">"Resource must not be null!"</span>);</span><br><span class="line">        Assert.notNull(resultType, <span class="string">"ResultType must not be null!"</span>);</span><br><span class="line">        DefaultRedisScript&lt;T&gt; script = <span class="keyword">new</span> DefaultRedisScript();</span><br><span class="line">        script.setResultType(resultType);</span><br><span class="line">        script.setLocation(resource);</span><br><span class="line">        <span class="keyword">return</span> script;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里Spring会将Lua脚本发送到Redis服务器进行缓存，而此时Redis服务器会返回一个32位的SHAl编码，这时候通过getShal方法就可以得到Redis返回的这个编码了；getResultType方法是获取Lua脚本返回的Java类型getScriptAsString是返回脚本的字符串，以便我们观看脚本。</p><p>下面我们来测试一下吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DefaultRedisScript&lt;String&gt; redisScript=<span class="keyword">new</span> DefaultRedisScript&lt;String &gt;();</span><br><span class="line">    <span class="comment">//设置脚本</span></span><br><span class="line">    redisScript.setScriptText(<span class="string">"return 'i love you'"</span>);</span><br><span class="line">    <span class="comment">//定义返回类型</span></span><br><span class="line">    redisScript.setResultType(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    RedisSerializer&lt;String &gt; redisSerializer=redisTemplate.getStringSerializer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行脚本</span></span><br><span class="line">    String s=(String)redisTemplate.execute</span><br><span class="line">            (redisScript,redisSerializer,redisSerializer,<span class="keyword">null</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在最后一行打一个断点，开始测试：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2008.jpg" alt=""></p><p>这里的代码，首先Lua只是定义了一个简单的字符串，然后就返回了，而返回类型则定义为宇符串。这里必须定义返回类型，否则对于Spring不会把脚本执行的结果返回。接着获取了由RedisTemplate自动创建的字符串序列化器，而后使用RedisTemplate的execute方法执行了脚本。在RedisTemplate中，execute方法执行脚本的方法有两种，其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(RedisScript&lt;T&gt; script, List&lt;K&gt; keys, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.scriptExecutor.execute(script, keys, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(RedisScript&lt;T&gt; script, RedisSerializer&lt;?&gt; argsSerializer, RedisSerializer&lt;T&gt; resultSerializer, List&lt;K&gt; keys, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.scriptExecutor.execute(script, argsSerializer, resultSerializer, keys, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这两个方法中，从参数的名称可以知道，script就是我们定义的RedisScript接口对象，keys代表Redis的键，args是这段脚本的参数。两个方法最大区别是一个存在序列化器的参数，另外个不存在。对于不存在序列化参数的方法，Spring将采用RedisTemplate提供的valueSerializer序列化器对传递的键和参进行序列化。这里我们采用了第二个方法调度脚本，并且设置为字符串序列化器，其中第一个序列化器是键的序列化器，二个是参数序列化器，这样键和参数就在字符串序列化器下被序列化了。</p><p>下面我们再来测试一下带参数的Lua吧：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2009.jpg" alt=""></p><p>这里的脚本中使用了两个键去保存两个参数，然后对这两个参数进行比较，如果相等则返回］,否则返回0。注意脚本中kYS[l］和kYS[2］的写法，它们表客户端传递的第一个键和第二键，而ARGV[1］和ARGV[2则表示客户端传递第一个和第二个参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String key1=<span class="string">"this"</span>,key2=<span class="string">"like"</span>;</span><br><span class="line">    String value1=<span class="string">"not"</span>,value2=<span class="string">"yourself"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    String lua=<span class="string">"redis.call('set',KEYS[1],ARGV[1]) \n"</span></span><br><span class="line">            +<span class="string">"redis.call('set',KEYS[2],ARGV[2]) \n"</span></span><br><span class="line">            +<span class="string">"local str1=redis.call('get',KEYS[1]) \n"</span></span><br><span class="line">            +<span class="string">"local str2=redis.call('get',KEYS[2]) \n"</span></span><br><span class="line">            +<span class="string">"if str1==str2 then \n"</span></span><br><span class="line">            +<span class="string">"return 1 \n"</span></span><br><span class="line">            +<span class="string">"end \n"</span></span><br><span class="line">            +<span class="string">"return 0 \n"</span>;</span><br><span class="line">    System.out.println(lua);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回结果为Long</span></span><br><span class="line">    DefaultRedisScript&lt;Long&gt; redisScript=<span class="keyword">new</span> DefaultRedisScript&lt;Long&gt;();</span><br><span class="line">    redisScript.setScriptText(lua);</span><br><span class="line">    redisScript.setResultType(Long<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">//采用字符串序列化器</span></span><br><span class="line">    RedisSerializer&lt;String&gt; stringRedisSerializer=redisTemplate.getStringSerializer();</span><br><span class="line">    <span class="comment">//定义key参数</span></span><br><span class="line">    List&lt;String&gt; keyList =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    keyList.add(key1);</span><br><span class="line">    keyList.add(key2);</span><br><span class="line">    <span class="comment">//传递两个参数，第一个序列化器是key的序列化器</span></span><br><span class="line">    <span class="comment">//第二个是参数的序列化器</span></span><br><span class="line">    Long result=(Long) redisTemplate.execute</span><br><span class="line">            (redisScript,stringRedisSerializer,stringRedisSerializer,keyList,value1,value2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用keyList保存了各个键，然后通过Redis的execute方法传递，参数则可以使用可变化的方式传递，且设置了给键和参数的序列化器都为字符串序列化器，这样便能够运行这段脚本了。我们的脚本返回为一个数字，这里值得注意的是，因为Java会把整数当作长整型（Long），所以这里返回值设置为Long型。</p><p>测试结果：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2010.jpg" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis在SpringBoot中的基础实现</title>
      <link href="/2020/03/23/redis1/"/>
      <url>/2020/03/23/redis1/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis在SpringBoot中的基础实现"><a href="#Redis在SpringBoot中的基础实现" class="headerlink" title="Redis在SpringBoot中的基础实现"></a>Redis在SpringBoot中的基础实现</h2><p>之前在讲SpringBoot整合Redis的时候，仅仅只是说了简单而又直观的运用，现在，我们来看看Redis在SpringBoot中，到底还有哪些操作。为此，我们仍然需要建立一个工程，其中的Redis使用的是Jedis驱动去连接，如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/1004.jpg" alt=""></p><p>从图可以看出，在Spring中是通过RedisConnection接口操作Redis的，而RedisConnection则对原生的Jedis进行封装。要获取RedisConnection接口对象，是通过RedisConnectionFactory接口去生成的，所以第一步要配置的便是这个工厂了，而配置这个工厂主要是配置Redis的连接池，对于连接池可以限定其最大连接数、超时时间等属性。下面开发一个简单的RedisConnectionFactory接口对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RedisConnectionFactory connectionFactory = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"redisConnectionFactory"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisConnectionFactory <span class="title">initConnectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.connectionFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.connectionFactory;</span><br><span class="line">        &#125;</span><br><span class="line">        JedisPoolConfig poolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        <span class="comment">// 最大空闲数</span></span><br><span class="line">        poolConfig.setMaxIdle(<span class="number">50</span>);</span><br><span class="line">        <span class="comment">// 最大连接数</span></span><br><span class="line">        poolConfig.setMaxTotal(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 最大等待毫秒数</span></span><br><span class="line">        poolConfig.setMaxWaitMillis(<span class="number">2000</span>);</span><br><span class="line">        <span class="comment">// 创建Jedis连接工厂</span></span><br><span class="line">        JedisConnectionFactory connectionFactory = <span class="keyword">new</span> JedisConnectionFactory(poolConfig);</span><br><span class="line">        <span class="comment">// 配置Redis连接服务器</span></span><br><span class="line">        RedisStandaloneConfiguration rsc = connectionFactory.getStandaloneConfiguration();</span><br><span class="line">        rsc.setHostName(<span class="string">"localhost"</span>);</span><br><span class="line">        rsc.setPort(<span class="number">6379</span>);</span><br><span class="line"><span class="comment">//        rsc.setPassword(RedisPassword.of("123456"));</span></span><br><span class="line">                <span class="keyword">this</span>.connectionFactory = connectionFactory;</span><br><span class="line">        <span class="keyword">return</span> connectionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是Redis的配置，当然，你也可以在application.yml文件中把配置写入，由SpringBoot去自动完成，他们之间并没有什么区别。</p><h3 id="RedisTemplate"><a href="#RedisTemplate" class="headerlink" title="RedisTemplate"></a>RedisTemplate</h3><p>我们在SpringBoot当中，所使用Redis最多的类是RedisTemplate，RedisTemplate是一个强大的类，首先它会自动从RedisConnectionFactory工厂中获取连接，然后执行对应的Redis命令，在最后还会关闭Redis的接。这些在RedisTemplate都被封装了，所以并不需要开发者关注Redis连接的闭合问题。</p><p>我们可以创建一个RedisTemplate：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name = <span class="string">"redisTemplate"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object,Object&gt; <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    RedisTemplate&lt;Object,Object&gt; redisTemplate=<span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">    redisTemplate.setConnectionFactory(initConnectionFactory());</span><br><span class="line">    <span class="keyword">return</span> redisTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以从上述代码中得知，每当RedisTemplate需要被使用时，它就会创建一个工厂实例，去初始化这个RedisTemplate，让它获取这个连接的能力，可能很多人看到这里有点疑惑，为什么他们需要这么麻烦呢？直接拥有连接不就好了吗？别着急，其实它们这样做是为了进一步的解耦，使得我们的Redis连接不被固有化，同时，这样的行为还有定制的作用，为什么呢？接着往下看。</p><p>我们开始对这个Redis进行一个实验，来看看它们是否真的成功了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationContext context=<span class="keyword">new</span> AnnotationConfigApplicationContext(RedisConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    RedisTemplate redisTemplate=context.getBean(RedisTemplate<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"ket1"</span>,<span class="string">"value1"</span>);</span><br><span class="line">    redisTemplate.opsForHash().put(<span class="string">"hash"</span>,<span class="string">"field"</span>,<span class="string">"hvalue"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这段代码过后，我们可以从Redis控制台看到结果：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/1001.jpg" alt=""></p><p>我想很多人一定很疑惑，为什么它们的键值，是这样的呢？这是因为，<strong>Redis是一种基于字符串存储的NoSQL，而Java是基于对象的语言</strong>，熟悉Java虚拟机的都知道，一个对象包含的东西太多了，包括了对象头等等，非常复杂的事物，所以无法直接被转化为字符串，而这并不是没有办法，只要类实现了java.io.Serializable接口，就能将类的对象序列化，通过这个原理，也能够反序列化。</p><p>于是乎，我们便可以在Redis中，实现序列化器：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/1005.jpg" alt=""></p><p>对于序列化器，Spring提供了RedisSerializer接口，它有两个方法。这两个方法，一个是serialize，它能把那些可以序列化的对象转换为二进制字符串；另一个是deserialize,它能够通过反序列化把二进制字符串转换为Java对象。图中的JacksonJsonRedisSerializer因为API过时，己经不推荐使用，我们这里主要讨论StringRedisSerializer和JdkSerializationRedisSerializer,其中JdkSerializationRedisSerializer是RedisTemplate默认的序列化器，代码清单的味etl”这个字符串就是被它序列化变为一个比较奇怪的宇符串的，原理如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/1006.jpg" alt=""></p><p>RedisTemplate还有以下的属性可以配置：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/1011.jpg" alt=""></p><p>所以，我们便可以在原来的代码当中，使用字符串序列化器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name=<span class="string">"redisTemplate"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">initRedisTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RedisTemplate&lt;Object, Object&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">    redisTemplate.setConnectionFactory(initConnectionFactory());</span><br><span class="line">    RedisSerializer&lt;String&gt; stringRedisSerializer = redisTemplate.getStringSerializer();</span><br><span class="line">    redisTemplate.setKeySerializer(stringRedisSerializer);</span><br><span class="line">    redisTemplate.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">    redisTemplate.setHashValueSerializer(stringRedisSerializer);</span><br><span class="line">    <span class="keyword">return</span> redisTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验结果：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/1002.jpg" alt=""></p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/1003.jpg" alt=""></p><p>另外，我们可以从代码中看出一些值得注意的事情：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redisTemplate.opsForValue().set(<span class="string">"ket1"</span>,<span class="string">"value1"</span>);</span><br><span class="line">redisTemplate.opsForHash().put(<span class="string">"hash"</span>,<span class="string">"field"</span>,<span class="string">"hvalue"</span>);</span><br></pre></td></tr></table></figure><p>它们还存在一些值得我们探讨的细节。例如，上述的两个操作并不是在同一个Redis的连接下完成的，什么意思？让我们更加详细地阐述代码运行的过程，首先在操作ket1时，redisTemplate会先从连接工厂（RedisConnectionFactory）中获取一个连接，然后执行对应的Redis命令，再关闭这条连接，其次在操作hash时，它也是从连接工厂中获取另条连接，然后执行命令，再关闭该连接。所以我们可以看到这个过程是两条连接的操作，这样显然存在资源的浪费，我们更加希望是在同一连接中就执行两个命令。为了克服这个问题，Spring为我们提供了RedisCallback和SessionCallback个接口。不过在此之前我们需要了解Spring对Redis数据类型的封装。</p><p>Redis使用得最多的是字符串，因此在spring-data-redis项中，还提供了一个StringRedisTemplate，这个类继承RedisTemplate，只是提供了字符串的操作而己，对于复杂Java对象还需要自行处理。</p><h3 id="SpringBoot对Redis数据类型操作的封装"><a href="#SpringBoot对Redis数据类型操作的封装" class="headerlink" title="SpringBoot对Redis数据类型操作的封装"></a>SpringBoot对Redis数据类型操作的封装</h3><p>Redis能够支持7种类型的数据结构，这7种类型是字符串、散列、列表（链表）、集合、有序集合、基数和地理位置。为此Spring针对每一种数据结构的操作都提供了对应的操作接口:</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/1012.jpg" alt=""></p><p>它们都可以通过RedisTemplate得到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">／／获取地理位置操作接口</span><br><span class="line">    redisTemplate.opsForGeo();</span><br><span class="line">／／获取散列操作接口</span><br><span class="line">    redisTemplateopsForHash();</span><br><span class="line">／／获取基数操作接口</span><br><span class="line">    redisTemplate.opsForHyperLogLog();</span><br><span class="line">／／获取列表操作接口</span><br><span class="line">    redisTemplate.opsForList();</span><br><span class="line">／／获取集合操作接口</span><br><span class="line">    redisTemplate.opsForSet();</span><br><span class="line">／／获取字符串操作接口</span><br><span class="line">    redisTemplate.opsForValue();</span><br><span class="line">／／获取有序集合操作接口</span><br><span class="line">    redisTemplate.opsForZSet();</span><br></pre></td></tr></table></figure><p>这样就可以通过各类的操作接口来操作不同的数据类型了，当然这需要你熟悉Redis的各种命令。有时我们可能需要对某一个键值对（key”value）做连续的操作，例如，有时需要连续操作一个散列数据类型或者列表多次，这时Spring也提供支持，它提供了对应的BoundXXXOperations接口：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/1013.jpg" alt=""></p><p>同样的，也有对应的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">／／获取地理位置绑定键操作接口</span><br><span class="line">redisTemplate.boundGeoOps（”geo”）;</span><br><span class="line">／／获取散列绑定键操作接口</span><br><span class="line">redisTemplate.boundHashOps(”hash”);</span><br><span class="line">／／获取列表（链表）绑定键操作接口</span><br><span class="line">redisTemplate.boundListops(”list&quot;);</span><br><span class="line">／／获取集合绑定键操作接口</span><br><span class="line">redisTemplate.boundSetOps（”set”）；</span><br><span class="line">／／获取字符串绑定键操作接口</span><br><span class="line">redisTemplate.boundValueOps(&quot;string”),</span><br><span class="line">／／获取有序集合绑定键操作接口</span><br><span class="line">redisTemplate.boundZSetOps(”zset&quot;);</span><br></pre></td></tr></table></figure><p>获取其中的操作接口后，我们就可以对某个键的数据进行多次操作，这样我们就知道如何有效地通过Spring操作Redis的各种数据型了。</p><h3 id="SessionCallback和RedisCallback接口"><a href="#SessionCallback和RedisCallback接口" class="headerlink" title="SessionCallback和RedisCallback接口"></a>SessionCallback和RedisCallback接口</h3><p>们的作用是让RedisTemplate进行回调，通过它们可以在同一条连接下执行多个Redis命令。其中SessionCallback提供了良好的封装，对于开发者比较友好，因此在实际的开发中应该优先选择使用它；相对而言，RedisCallback接口比较底层，需要处理的内容也比较多，可读性较差，所以在非必要的时候尽量不选择使用它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//// 需要处理底层的转换规则，如果不考虑改写底层，尽量不使用它</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useRedisCallback</span><span class="params">(RedisTemplate redisTemplate)</span> </span>&#123;</span><br><span class="line">    redisTemplate.execute(<span class="keyword">new</span> RedisCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">doInRedis</span><span class="params">(RedisConnection rc)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">            rc.set(<span class="string">"key1"</span>.getBytes(), <span class="string">"value1"</span>.getBytes());</span><br><span class="line">            rc.hSet(<span class="string">"hash"</span>.getBytes(), <span class="string">"field"</span>.getBytes(), <span class="string">"hvalue"</span>.getBytes());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//// 高级接口，比较友好，一般情况下，优先使用它</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useSessionCallback</span><span class="params">(RedisTemplate redisTemplate)</span> </span>&#123;</span><br><span class="line">    redisTemplate.execute(<span class="keyword">new</span> SessionCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(RedisOperations ro)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">            ro.opsForValue().set(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">            ro.opsForHash().put(<span class="string">"hash"</span>, <span class="string">"field"</span>, <span class="string">"hvalue"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，我们采用了匿名类的方式去使用它们。从代码中可以看出，RedisCallback接口井不是那么友好，但是它能够改写一些底层的东西，如序列化的问题，所以在需要改写那些较为底层规则时，可以使用它。使用SessionCallback接口则比较友好，这也是我在大部分情况下推荐使用的接口，它提供了更为高级的API，使得我们的使用更为简单，可读性也更佳。如果采用的是Java8或者以上的版本，则还可以使用Lambda表达式改写上述代码，这样代码就会更加清爽。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useRedisCallback</span><span class="params">(RedisTemplate redisTemplate)</span> </span>&#123;</span><br><span class="line">    redisTemplate.execute((RedisConnection rc) -&gt; &#123;</span><br><span class="line">        rc.set(<span class="string">"key1"</span>.getBytes(), <span class="string">"value1"</span>.getBytes());</span><br><span class="line">        rc.hSet(<span class="string">"hash"</span>.getBytes(), <span class="string">"field"</span>.getBytes(), <span class="string">"hvalue"</span>.getBytes());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useSessionCallback</span><span class="params">(RedisTemplate redisTemplate)</span> </span>&#123;</span><br><span class="line">    redisTemplate.execute((RedisOperations ro) -&gt; &#123;</span><br><span class="line">        ro.opsForValue().set(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">        ro.opsForHash().put(<span class="string">"hash"</span>, <span class="string">"field"</span>, <span class="string">"hvalue"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后，我们再清除掉所有缓存，重新测试一遍：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(RedisConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        RedisTemplate redisTemplate = ctx.getBean(RedisTemplate<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">//redisTemplate.opsForValue().set("key1", "value1");</span></span><br><span class="line"><span class="comment">//redisTemplate.opsForHash().put("hash", "field", "hvalue");</span></span><br><span class="line">        useSessionCallback(redisTemplate);</span><br><span class="line"><span class="comment">//useRedisCallback(redisTemplate);</span></span><br><span class="line">        ctx.close();</span><br></pre></td></tr></table></figure><p>结果是成功的。</p><h3 id="SpringBoot中使用Redis"><a href="#SpringBoot中使用Redis" class="headerlink" title="SpringBoot中使用Redis"></a>SpringBoot中使用Redis</h3><p>虽然我们在整合Redis的时候，已经使用过注解了，但是这样的方法，并不能直观的学习到它的用法，于是乎，我们便一步一步的手动去操作一遍吧。</p><p>首先便是使用application.yml去代替Config：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">jedis:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">2000</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure><p>这里我们配置了连接池和服务器的属性，用以连接Redis服务器，这样SpringBoot的自动装配机制就会读取这些配置来生成有关Redis的操作对象，这里它会自动生成RedisConnectionFactory、RedisTemplate、StringRedisTemplate等常用的Redis对象。我们知道，RedisTemplate会默认使用JdkSerializationRedisSerializer进行序列化键值，这样便能够存储到Redis服务器中。</p><p>如果这样，Redis服务器存入的便是一个经过序列化后的特殊字符串，有时候对于我们跟踪并不是很友好。如果我们在Redis只是使用字符串，那么使用其自动生成的StringRedisTemplate即可，但是这样就只能支持字符串了，并不能支持Java对象的存储。为了克服这个问题，可以通过设置RedisTemplate的序列化器来处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTemplateConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisTemplate redisTemplate=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义自定义后初始方法</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        initRedisTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置template序列化器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initRedisTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RedisSerializer serializer=redisTemplate.getStringSerializer();</span><br><span class="line">        redisTemplate.setKeySerializer(serializer);</span><br><span class="line">        redisTemplate.setHashKeySerializer(serializer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略redisCacheManager</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过＠Autowired注入由SpringBoot根据配置生成的RedisTemplate对象，然后利用SpringBean生命周期的特性使用注解＠PostConstruct自定义后初始化方法。在这个方法里，把RedisTemplate中的键序列化器修改为StringRedisSerializer。</p><p>因为之前我们讨论过，在RedisTemplate中它会默认地定义了一个StringRedisSerializer对象，所以这里我并没有自己创建一个新的StringRedisSerializer对象，而是从RedisTemplate中获取。然后把RedisTemplate关于键和其散列数据类型的filed都修改为了使用StringRedisSerializer进行序列化，这样我们在Redis服务器上得到的键和散列的field就都以宇符串存储了。</p><p>那么接下来，我们就在测试中，测试一下我们存储各种数据类型的情况吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"key1"</span>,<span class="string">"value1"</span>);</span><br><span class="line"></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"int_key"</span>,<span class="string">"1"</span>);</span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">"int"</span>,<span class="string">"1"</span>);</span><br><span class="line">    <span class="comment">//使用运算</span></span><br><span class="line">    stringRedisTemplate.opsForValue().increment(<span class="string">"int"</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//获取底层jedis连接</span></span><br><span class="line">    Jedis jedis=(Jedis)stringRedisTemplate.getConnectionFactory()</span><br><span class="line">            .getConnection().getNativeConnection();</span><br><span class="line">    <span class="comment">//减一操作，这个命令需要获得底层连接才能操作</span></span><br><span class="line">    jedis.decr(<span class="string">"int"</span>);</span><br><span class="line"></span><br><span class="line">    Map&lt;String,String&gt; hash=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    hash.put(<span class="string">"field1"</span>,<span class="string">"value1"</span>);</span><br><span class="line">    hash.put(<span class="string">"field2"</span>,<span class="string">"value2"</span>);</span><br><span class="line">    <span class="comment">//存入一个散列数据类型</span></span><br><span class="line">    stringRedisTemplate.opsForHash().putAll(<span class="string">"hash"</span>,hash);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新增一个字段</span></span><br><span class="line">    stringRedisTemplate.opsForHash().put(<span class="string">"hash"</span>,<span class="string">"field3"</span>,<span class="string">"value3"</span>);</span><br><span class="line">    <span class="comment">//绑定散列操作的Key，这样可以连续对同一个散列数据类型进行操作</span></span><br><span class="line">    BoundHashOperations hashOperations=stringRedisTemplate.boundHashOps(<span class="string">"hash"</span>);</span><br><span class="line">    <span class="comment">//删除两个字段</span></span><br><span class="line">    hashOperations.delete(<span class="string">"field1"</span>,<span class="string">"field2"</span>);</span><br><span class="line">    <span class="comment">//新增一个字段</span></span><br><span class="line">    hashOperations.put(<span class="string">"field4"</span>,<span class="string">"value4"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的＠Autowired注入了SpringBoot为我们自动初始化RedisTemplate和StringRedisTemplate对象。看到testStringAndHash法，先是存入了一个“key1”的数据，然后是“int_key”但是请注意这个“int_key”存入到Redis服务器中，因为采用了JDK序列化器，所以在Redis服务器中它不是整数，而是一个被JDK序列化器序列化后的二进制字符串，是没有办法使用Redis命令进行运算的。</p><p>为了克服这个问题，这里使用StringRedisTemplate对象保存了一个键为“int”的整数，这样就能够运算了。接着进行了加一运算，但是因为RedisTemplate并不能支持底层所有的Redis命令，所以这里先获取了原始的Redis连接的Jedis对象，用它来做减一运算。</p><p>然后是操作散列数据类型，在插入多个散列的field时可以采用Map，然后为了方便对同一个数据操作，这里代码还获取了BoundHashOperations对象进行操作，这样对同一个数据操作就方便许多了。</p><p>测试结果如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/1014.jpg" alt=""></p><p>列表也是常用的数据类型。在Redis中列表是一种链表结构，这就意味着查询性能不高，而增删节点的性能高，这是它的特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//插入两个列表</span></span><br><span class="line">    <span class="comment">//链表从左到右顺序为：v10、v8、v6...</span></span><br><span class="line">    stringRedisTemplate.opsForList().leftPushAll(<span class="string">"List1"</span>,<span class="string">"v2"</span>,<span class="string">"v4"</span>,<span class="string">"v6"</span>,<span class="string">"v8"</span>,<span class="string">"v10"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//链表从右到左顺序为：v1,v2,v3...</span></span><br><span class="line">    stringRedisTemplate.opsForList().rightPushAll(<span class="string">"List2"</span>,<span class="string">"v1"</span>,<span class="string">"v2"</span>,<span class="string">"v3"</span>,<span class="string">"v4"</span>,<span class="string">"v5"</span>,<span class="string">"v6"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定链表操作</span></span><br><span class="line">    BoundListOperations listOperations=stringRedisTemplate.boundListOps(<span class="string">"List2"</span>);</span><br><span class="line">    <span class="comment">//从右边弹出一个成员</span></span><br><span class="line">    Object result1=listOperations.rightPop();</span><br><span class="line">    <span class="comment">//获取定位元素，从下标0开始算，这里为v2</span></span><br><span class="line">    Object result2=listOperations.index(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//从左边插入链表</span></span><br><span class="line">    listOperations.leftPush(<span class="string">"v0"</span>);</span><br><span class="line">    <span class="comment">//求链表长度</span></span><br><span class="line">    Long size=listOperations.size();</span><br><span class="line">    <span class="comment">//求链表下标区间成员，整个链表下标范围为0，到size-1，这里不取最后一个元素</span></span><br><span class="line">    List elements=listOperations.range(<span class="number">0</span>,size-<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (Object a:elements) &#123;</span><br><span class="line">        System.out.println(a.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>述操作是基于StringRedisTemplate的，所以保存到Redis服务器的都是字符串类型，只是这里有两点需要注意。首先是列表元素的顺序问题，是从左到右还是从右到左，这是容易弄糊涂的问题：其次是下标问题，在Redis中是以0开始的，这与Java中的数组类似。</p><p>测试结果：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/1015.jpg" alt=""></p><p>接着是集合。对于集合，在Redis中是不允许成员重复的，它在数据结构上是一个散列表的结构，所以对于它而言是无序的，对于两个或者以上的集合，Redis还提供了交集、并集和差集的运算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">//重复两次v1，因为集合不允许重复，所以结果还是5个值</span></span><br><span class="line">     stringRedisTemplate.opsForSet().add(<span class="string">"set1"</span>,<span class="string">"v1"</span>,<span class="string">"v1"</span>,<span class="string">"v2"</span>,<span class="string">"v3"</span>,<span class="string">"v4"</span>,<span class="string">"v5"</span>);</span><br><span class="line">     stringRedisTemplate.opsForSet().add(<span class="string">"set2"</span>,<span class="string">"v2"</span>,<span class="string">"v4"</span>,<span class="string">"v6"</span>,<span class="string">"v8"</span>);</span><br><span class="line">     <span class="comment">//绑定集合</span></span><br><span class="line">     BoundSetOperations setOperations=stringRedisTemplate.boundSetOps(<span class="string">"set1"</span>);</span><br><span class="line">     <span class="comment">//增加两个元素</span></span><br><span class="line">     setOperations.add(<span class="string">"v6"</span>,<span class="string">"v7"</span>);</span><br><span class="line">     <span class="comment">//删除</span></span><br><span class="line">     setOperations.remove(<span class="string">"v1"</span>,<span class="string">"v7"</span>);</span><br><span class="line">     <span class="comment">//返回所有元素</span></span><br><span class="line">     Set set=setOperations.members();</span><br><span class="line">     <span class="comment">//求成员数量</span></span><br><span class="line">     Long size=setOperations.size();</span><br><span class="line"></span><br><span class="line">     <span class="comment">//求交集</span></span><br><span class="line">     setOperations.intersectAndStore(<span class="string">"set2"</span>,<span class="string">"inter"</span>);</span><br><span class="line">     <span class="comment">//求差集</span></span><br><span class="line">     setOperations.diff(<span class="string">"set2"</span>);</span><br><span class="line">     <span class="comment">//求差集并保存</span></span><br><span class="line">     setOperations.diffAndStore(<span class="string">"set2"</span>,<span class="string">"diff"</span>);</span><br><span class="line">     <span class="comment">//求并集</span></span><br><span class="line">     Set union=setOperations.union(<span class="string">"set2"</span>);</span><br><span class="line">     <span class="comment">//求并集并保存</span></span><br><span class="line">     setOperations.unionAndStore(<span class="string">"set2"</span>,<span class="string">"union"</span>);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>添加集合set1时，存在两个v1一样的元素。因为集合不允许重复，所以实际上在集合只算是一个元素。然后可以看到对集合各类操作，在最后还有交集、差集和并集的操作，这些是集合最常用的操作。</p><p>测试结果：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/1016.jpg" alt=""></p><h3 id="TypedTuple接口"><a href="#TypedTuple接口" class="headerlink" title="TypedTuple接口"></a>TypedTuple接口</h3><p>在一些网站中，经常会有排名，如最热门的商品或者最大的购买买家，都是常常见到的场景。对于这类排名，刷新往往需要及时，也涉及较大的统计，如果使用数据库会太慢。为了支持集合的排序，Redis还提供了有序集合（zset）。有序集合与集合的差异并不大，它也是一种散列表存储的方式，同时它的有序性只是靠它在数据结构中增加一个属性–score（分数）得以支持。为了支持这个变化，Spring提供了TypedTuple接口，它定义了两个方法，并且Spring还提供了其默认的实现类DefaultTypedTuple，如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/1007.jpg" alt=""></p><p>在TypedTuple接口的设计中，value是保存有序集合的值，score则是保存分数，Redis是使用分数来完成集合的排序的，这样如果把买家作为一个有序集合，而买家花的钱作为分数，就可以使用Redis进行快速排序了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">     Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">9</span> ; i++) &#123;</span><br><span class="line">         <span class="comment">//分数</span></span><br><span class="line">         <span class="keyword">double</span> score=i*<span class="number">0.1</span>;</span><br><span class="line">         <span class="comment">//创建一个TypedTuple对象，存入值和分数</span></span><br><span class="line">         ZSetOperations.TypedTuple&lt;String&gt; typedTuple=</span><br><span class="line">                 <span class="keyword">new</span> DefaultTypedTuple&lt;String&gt;(<span class="string">"value"</span>+i,score);</span><br><span class="line">         typedTuples.add(typedTuple);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//往有序集合插入元素</span></span><br><span class="line">     stringRedisTemplate.opsForZSet().add(<span class="string">"zset1"</span>,typedTuples);</span><br><span class="line">     <span class="comment">//绑定属性</span></span><br><span class="line">     BoundZSetOperations&lt;String ,String &gt; zSetOperations=</span><br><span class="line">             stringRedisTemplate.boundZSetOps(<span class="string">"zset1"</span>);</span><br><span class="line">     <span class="comment">//增加一个元素</span></span><br><span class="line">     zSetOperations.add(<span class="string">"value10"</span>,<span class="number">0.26</span>);</span><br><span class="line">     Set&lt;String &gt; setRange=zSetOperations.range(<span class="number">1</span>,<span class="number">6</span>);</span><br><span class="line">     Set&lt;String &gt; setScore=zSetOperations.rangeByScore(<span class="number">0.2</span>,<span class="number">0.6</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//定义值范围</span></span><br><span class="line">     RedisZSetCommands.Range range=<span class="keyword">new</span> RedisZSetCommands.Range();</span><br><span class="line">     range.gt(<span class="string">"value3"</span>);<span class="comment">// 大于value3</span></span><br><span class="line">     <span class="comment">// range.gte("value3");// 大于等于value3</span></span><br><span class="line">     <span class="comment">// range.lt("value8");// 小于value8</span></span><br><span class="line">     range.lte(<span class="string">"value8"</span>);<span class="comment">// 小于等于value8</span></span><br><span class="line">     <span class="comment">// 按值排序，请注意这个排序是按字符串排序</span></span><br><span class="line">     Set&lt;String&gt; setLex = zSetOperations.rangeByLex(range);</span><br><span class="line">     <span class="comment">// 删除元素</span></span><br><span class="line">     zSetOperations.remove(<span class="string">"value9"</span>, <span class="string">"value2"</span>);</span><br><span class="line">     <span class="comment">// 求分数</span></span><br><span class="line">     Double score = zSetOperations.score(<span class="string">"value8"</span>);</span><br><span class="line">     <span class="comment">// 在下标区间下，按分数排序，同时返回value和score</span></span><br><span class="line">     Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; rangeSet = zSetOperations.rangeWithScores(<span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line">     <span class="comment">// 在分数区间下，按分数排序，同时返回value和score</span></span><br><span class="line">     Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; scoreSet = zSetOperations.rangeByScoreWithScores(<span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line">     <span class="comment">// 按从大到小排序</span></span><br><span class="line">     Set&lt;String&gt; reverseSet = zSetOperations.reverseRange(<span class="number">2</span>, <span class="number">8</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>代码中使用了TypedTuple保存有序集合的元素，在默认的情况下，有序集合是从小到大地排序的，按下标、分数和值进行排序获取有序集合的元素，或者连同分数一起返回，有时候还可以进行从大到小的排序，只是在使用值排序时，我们可以使用Spring为我们创建的Range类，它可以定义值的范围，还有大于、等于、大于等于、小于等于等范围定义，方便我们筛选对应的元素。</p><p>测试结果：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/1017.jpg" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode：1、2、3、4、7、9。</title>
      <link href="/2020/03/19/leetcode1/"/>
      <url>/2020/03/19/leetcode1/</url>
      
        <content type="html"><![CDATA[<h3 id="第一题：两数之和"><a href="#第一题：两数之和" class="headerlink" title="第一题：两数之和"></a>第一题：两数之和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        示例:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        给定 nums = [2, 7, 11, 15], target = 9</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        因为 nums[0] + nums[1] = 2 + 7 = 9</span></span><br><span class="line"><span class="comment">//        所以返回 [0, 1]</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">No1</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//思考：此数值是唯一的 2+7=9，能被9减掉7后的数字一定2，</span></span><br><span class="line">    <span class="comment">// 当你利用 target减去值的时候，一定会出现一个符合的值</span></span><br><span class="line">    <span class="comment">//利用数据结构的图</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;nums.length ; i++) &#123;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;nums.length ; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> com=target-nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(com) &amp;&amp; map.get(com)!=i)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i,map.get(com)&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] s=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">9</span>;</span><br><span class="line">        <span class="keyword">int</span> [] r=twoSum(s,t);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a: r) &#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二题：两数相加"><a href="#第二题：两数相加" class="headerlink" title="第二题：两数相加"></a>第二题：两数相加</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"><span class="comment">//给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，</span></span><br><span class="line"><span class="comment">// 并且它们的每个节点只能存储 一位 数字。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        示例：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span></span><br><span class="line"><span class="comment">//        输出：7 -&gt; 0 -&gt; 8</span></span><br><span class="line"><span class="comment">//        原因：342 + 465 = 807</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">No2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line"></span><br><span class="line">        ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">            val = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//面对这种情形，首先想到循环，或者是递归，但是考虑到有两个链表，还是循环比较简单</span></span><br><span class="line">    <span class="comment">//但是要注意，两个ListNode可能不等长</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//此题考验对数据结构的熟悉程度</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//要定义一个加起来的数字总值</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//再定义一个大于10的余数</span></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回的结果是一个链表，依据返回的值来看，是 7，0,8，所以返回的链表的头结点，</span></span><br><span class="line">        <span class="comment">//为了保证再后续相加之后，还能返回头结点，所以一开始就要将头结点定死</span></span><br><span class="line">        ListNode result = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//再让一个临时节点，去获取头结点的地址，进行后续的相加</span></span><br><span class="line">        ListNode listNode=result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l1!= <span class="keyword">null</span> || l2!= <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//这里要注意的是，链表可能不等长，所以使用三段式判断</span></span><br><span class="line">            sum = (l1!=<span class="keyword">null</span>?l1.val:<span class="number">0</span>)+(l2!=<span class="keyword">null</span>?l2.val:<span class="number">0</span>) + temp;</span><br><span class="line">            temp = sum / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//其实是这里，最为考验数据结构</span></span><br><span class="line">            listNode.next=<span class="keyword">new</span> ListNode(sum%<span class="number">10</span>);</span><br><span class="line">            <span class="comment">//好好理解 它等于它的next，到底发生了什么</span></span><br><span class="line">            listNode=listNode.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (l1!= <span class="keyword">null</span>) &#123;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果存在千分位的话</span></span><br><span class="line">            <span class="keyword">if</span> (temp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                listNode.next=<span class="keyword">new</span> ListNode(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ListNode l1=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode l3=l1;</span><br><span class="line">        l3.next=<span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">        l3=l3.next;</span><br><span class="line">        l3.next=<span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">        l3=l3.next;</span><br><span class="line">        l3.next=<span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">        l3=l3.next;</span><br><span class="line"></span><br><span class="line">        ListNode l2=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode l4=l2;</span><br><span class="line">        l4.next=<span class="keyword">new</span> ListNode(<span class="number">5</span>);</span><br><span class="line">        l4=l4.next;</span><br><span class="line">        l4.next=<span class="keyword">new</span> ListNode(<span class="number">6</span>);</span><br><span class="line">        l4=l4.next;</span><br><span class="line">        l4.next=<span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">        l4=l4.next;</span><br><span class="line"></span><br><span class="line">        ListNode l5=addTwoNumbers(l1.next,l2.next);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">3</span> ; i++) &#123;</span><br><span class="line">            System.out.print(l5.val+<span class="string">"-&gt;"</span>);</span><br><span class="line">            l5=l5.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三题：无重复字符的最长子串"><a href="#第三题：无重复字符的最长子串" class="headerlink" title="第三题：无重复字符的最长子串"></a>第三题：无重复字符的最长子串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        示例 1:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        输入: "abcabcbb"</span></span><br><span class="line"><span class="comment">//        输出: 3</span></span><br><span class="line"><span class="comment">//        解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。</span></span><br><span class="line"><span class="comment">//        示例 2:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        输入: "bbbbb"</span></span><br><span class="line"><span class="comment">//        输出: 1</span></span><br><span class="line"><span class="comment">//        解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。</span></span><br><span class="line"><span class="comment">//        示例 3:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        输入: "pwwkew"</span></span><br><span class="line"><span class="comment">//        输出: 3</span></span><br><span class="line"><span class="comment">//        解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。</span></span><br><span class="line"><span class="comment">//             请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">No3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要注意的是，最长的无重复字符，可以理解为，在字符串的其中一段字符段中，</span></span><br><span class="line">    <span class="comment">// 这个字母，仅仅出现过一次，</span></span><br><span class="line">    <span class="comment">// 于是乎，你并不用将那段字母段的最后一个值拿去和其他值比较</span></span><br><span class="line">    <span class="comment">// 只需要的是，根据数据结构的图，判断一下下一个字母是否在字符段里面就好了，</span></span><br><span class="line">    <span class="comment">//如果存在，则直接跳过这一段</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), result = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">// 当前字符索引</span></span><br><span class="line">        <span class="comment">// 尝试扩大范围 [i, j]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, i = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">//如果有字符在滑动窗口（字符段）当中,则</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(s.charAt(j))) &#123;</span><br><span class="line">                <span class="comment">//将搜索到字符段（滑动窗口）的下一个值的下标，与“开始移动标记”，进行互换。</span></span><br><span class="line">                i = Math.max(map.get(s.charAt(j)), i);</span><br><span class="line">            &#125;</span><br><span class="line">            result = Math.max(result, j - i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//加入滑动窗口当中，并标记该字符的下一个字符下标，以用于地址交换</span></span><br><span class="line">            map.put(s.charAt(j), j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(lengthOfLongestSubstring(<span class="string">"abcab"</span>));</span><br><span class="line">        System.out.println(lengthOfLongestSubstring(<span class="string">"bbbbbb"</span>));</span><br><span class="line">        System.out.println(lengthOfLongestSubstring(<span class="string">"pwwkew"</span>));</span><br><span class="line">        System.out.println(lengthOfLongestSubstring2(<span class="string">"qw"</span>));</span><br><span class="line">        System.out.println(lengthOfLongestSubstring2(<span class="string">"aab"</span>));</span><br><span class="line">        System.out.println(lengthOfLongestSubstring2(<span class="string">""</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//失败,由于一开始觉得是使用移动窗口的方法，但是却直接使用了下标去实现</span></span><br><span class="line">    <span class="comment">// 而又为了少一点循环，</span></span><br><span class="line">    <span class="comment">// 导致最后越来越乱，从而导致失败</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;s.length()-<span class="number">1</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;f ; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((j+f)&lt;s.length()&amp;&amp;(s.charAt(j)!=s.charAt(j+f)) )&#123;</span><br><span class="line">                    f++;</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(f&gt;result)&#123;</span><br><span class="line">                        result=f;</span><br><span class="line">                    &#125;</span><br><span class="line">                    f=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第五题：最长回文串"><a href="#第五题：最长回文串" class="headerlink" title="第五题：最长回文串"></a>第五题：最长回文串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        示例 1：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        输入: "babad"</span></span><br><span class="line"><span class="comment">//        输出: "bab"</span></span><br><span class="line"><span class="comment">//        注意: "aba" 也是一个有效答案。</span></span><br><span class="line"><span class="comment">//        示例 2：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        输入: "cbbd"</span></span><br><span class="line"><span class="comment">//        输出: "bb"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">No5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不会</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(longestPalindrome(<span class="string">"babad"</span>));</span><br><span class="line">        System.out.println(longestPalindrome(<span class="string">"cbbd"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第七题：整数反转"><a href="#第七题：整数反转" class="headerlink" title="第七题：整数反转"></a>第七题：整数反转</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        示例 1:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        输入: 123</span></span><br><span class="line"><span class="comment">//        输出: 321</span></span><br><span class="line"><span class="comment">//        示例 2:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        输入: -123</span></span><br><span class="line"><span class="comment">//        输出: -321</span></span><br><span class="line"><span class="comment">//        示例 3:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        输入: 120</span></span><br><span class="line"><span class="comment">//        输出: 21</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">No7</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//太简单，直接判断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        Boolean flag=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            x=-x;</span><br><span class="line">           flag=<span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String a=x+<span class="string">""</span>;</span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = a.length()-<span class="number">1</span>; i &gt;-<span class="number">1</span> ; i--) &#123;</span><br><span class="line">            result+=a.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            result=<span class="string">"-"</span>+result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            s=Integer.parseInt(result);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (NumberFormatException e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(reverse(<span class="number">123</span>));</span><br><span class="line">        System.out.println(reverse(-<span class="number">123</span>));</span><br><span class="line">        System.out.println(reverse(<span class="number">120</span>));</span><br><span class="line">        System.out.println(reverse(<span class="number">1534236469</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第九题：回文数"><a href="#第九题：回文数" class="headerlink" title="第九题：回文数"></a>第九题：回文数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        示例 1:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        输入: 121</span></span><br><span class="line"><span class="comment">//        输出: true</span></span><br><span class="line"><span class="comment">//        示例 2:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        输入: -121</span></span><br><span class="line"><span class="comment">//        输出: false</span></span><br><span class="line"><span class="comment">//        解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span></span><br><span class="line"><span class="comment">//        示例 3:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        输入: 10</span></span><br><span class="line"><span class="comment">//        输出: false</span></span><br><span class="line"><span class="comment">//        解释: 从右向左读, 为 01 。因此它不是一个回文数。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">No9</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//太简单</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String s=x+<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.length()%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length()/<span class="number">2</span>-<span class="number">1</span>,j=i+<span class="number">1</span>; i &gt;-<span class="number">1</span>; i--,j++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i)!=s.charAt(j))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length()/<span class="number">2</span>-<span class="number">1</span>,j=i+<span class="number">2</span>; i &gt;-<span class="number">1</span> ; i--,j++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i)!=s.charAt(j))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(isPalindrome(<span class="number">121</span>));</span><br><span class="line">        System.out.println(isPalindrome(-<span class="number">121</span>));</span><br><span class="line">        System.out.println(isPalindrome(<span class="number">10</span>));</span><br><span class="line">        System.out.println(isPalindrome(<span class="number">11</span>));</span><br><span class="line">        System.out.println(isPalindrome(<span class="number">123</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机（九）类加载机制全解析</title>
      <link href="/2020/03/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA9/"/>
      <url>/2020/03/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA9/</url>
      
        <content type="html"><![CDATA[<h2 id="类加载机制全解析"><a href="#类加载机制全解析" class="headerlink" title="类加载机制全解析"></a>类加载机制全解析</h2><p>我们所编写的Java代码，在经过编译器的编译后，会把我们的.java 文件编译成可以被系统所识别的机器码，而虚拟机便会读取这些文件来运行，就算平台有所不同，也不受影响，这也就是Java的跨平台性。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/classload/1001.jpg" alt=""></p><p>那么，这么类文件是怎么被加载到JVM中使用的呢？我们自己随便改个Class后缀行不行？我们复写了JDK里面了根类，JVM又会运行哪个呢？现在，我们就来解读这个问题。</p><p>再看一下jvm的大致物理结构图</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/classload/1002.jpg" alt=""></p><h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><h4 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h4><p> 类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。它们开始的顺序如下图所示：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/classload/1003.jpg" alt=""></p><p>其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p><p> 这里简要说明下Java中的绑定：绑定指的是把一个方法的调用与方法所在的类(方法主体)关联起来，对java来说，绑定分为静态绑定和动态绑定：</p><ul><li>静态绑定：即前期绑定。在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。针对java，简单的可以理解为程序编译期的绑定。java当中的方法只有final，static，private和构造方法是前期绑定的。</li><li>动态绑定：即晚期绑定，也叫运行时绑定。在运行时根据具体对象的类型进行绑定。在java中，几乎所有的方法都是后期绑定的。</li></ul><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>类的装载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。<strong>也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。</strong></p><p>类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p><p>类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p><p>加载.class文件的方式有:</p><ul><li>1). 从本地系统中直接加载</li><li>2). 通过网络下载.class文件</li><li>3). 从zip，jar等归档文件中加载.class文件 </li><li>4). 从专有数据库中提取.class文件 </li><li>5). 将Java源文件动态编译为.class文件</li></ul><p>这些便是类的加载方式，了解了这些加载方式后，再来谈谈加载阶段，到底做了些什么。</p><p>加载是类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：</p><p><strong>1、通过一个类的全限定名来获取其定义的二进制字节流。</strong></p><p>这个全限定名，在之前讲述类文件结构的时候出现过，那个点可能很多人都没有看懂，这里再次被拿了出来。它的意思就是类的名字，就这么简单。</p><p><strong>2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</strong></p><p><strong>3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</strong></p><p>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，<strong>也可以自定义自己的类加载器来完成加载</strong>，后面会提到类加载器是什么东西。</p><p>加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。</p><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>  当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。<strong>类连接又可分为如下3个阶段：验证、准备、解析。</strong></p><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证：文件格式的验证、元数据的验证、字节码验证和符号引用验证。</p><ul><li>文件格式的验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。</li><li>元数据验证：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），保证不存在不符合Java语法规范的元数据信息。</li><li>字节码验证：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。</li><li>符号引用验证：这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。</li></ul><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p><p> 1、这时候进行内存分配的<strong>仅包括类变量（static）</strong>，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</p><p>这很明显，有时候你加载一个类并不代表就一定要实例化它，有可能你仅仅是利用了反射去加载这个类，没有创建出实例。</p><p>2、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</p><p> 假设一个类变量的定义为：public static int value = 3；这是一个类里面的静态值，我们的JVM会为其分配相应的内存空间，但是并不会赋予值。 </p><p>变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器 <strong><clinit>（）</strong>方法之中的，所以<strong>把value赋值为3的动作将在初始化阶段才会执行。</strong></p><p>下表列出了Java中所有基本数据类型以及reference类型的默认零值：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/classload/1005.jpg" alt=""></p><p>这里还需要注意如下几点：</p><ol><li>对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</li><li>对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</li><li>对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。</li><li>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</li></ol><p>3、如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，<strong>那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。</strong></p><p>  假设上面的类变量value被定义为：public static final int value = 3； 编译时Javac将会为value生成ConstantValue属性，<strong>在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。</strong></p><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p> <strong>解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。</strong></p><p>这里先说一下什么是符号引用，什么是直接引用：</p><ul><li>符号引用（Symbolic Reference）：符号引用以一组符号来描述所引用的目标，符号引用可以是任何形式的字面量，符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经在内存中。</li><li>直接引用（Direct Reference）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般都不相同，如果有了直接引用，那引用的目标必定已经在内存中存在。</li></ul><p>前面说解析阶段可能开始于初始化之前，也可能在初始化之后开始，虚拟机会根据需要来判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析（初始化之前），还是等到一个符号引用将要被使用前才去解析它（初始化之后）。</p><p>对同一个符号引用进行多次解析请求时很常见的事情，虚拟机实现可能会对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标示为已解析状态），从而避免解析动作重复进行。</p><p>解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行，分别对应于常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info四种常量类型。<br> <strong>1、类或接口的解析：</strong>判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。</p><p> <strong>2、字段解析：</strong>对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束，查找流程如下图所示：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/classload/1006.jpg" alt=""></p><p>从下面一段代码的执行结果中很容易看出来字段解析的搜索顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"执行了super类静态语句块"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">Super</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">33</span>;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"执行了父类静态语句块"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"执行了子类静态语句块"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">System.out.println(Child.m);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p>  执行了super类静态语句块<br>  执行了父类静态语句块<br>  33<br>  如果注释掉Father类中对m定义的那一行，则输出结果如下：</p><p>  执行了super类静态语句块<br>  11</p><p>最后需要注意：理论上是按照上述顺序进行搜索解析，但在实际应用中，虚拟机的编译器实现可能要比上述规范要求的更严格一些。如果有一个同名字段同时出现在该类的接口和父类中，或同时在自己或父类的接口中出现，编译器可能会拒绝编译。如果对上面的代码做些修改，将Super改为接口，并将Child类继承Father类且实现Super接口，那么在编译时会报出如下错误：<br><strong>StaticTest.java:24: 对 m 的引用不明确，Father 中的 变量 m 和 Super 中的 变量 m都匹配System.out.println(Child.m)^1 错误</strong></p><p> <strong>3、类方法解析：</strong>对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口。</p><p>  <strong>4、接口方法解析：</strong>与类方法解析步骤类似，知识接口不会有父类，因此，只递归向上搜索父接口就行了。</p><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p> 初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的Java程序代码。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源， 初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p><ul><li>①声明类变量时指定初始值</li><li>②使用静态代码块为类变量指定初始值</li></ul><p>JVM初始化步骤:</p><ul><li>1)、假如这个类还没有被加载和连接，则程序先加载并连接该类</li><li>2)、假如该类的直接父类还没有被初始化，则先初始化其直接父类</li><li>3)、假如类中有初始化语句，则系统依次执行这些初始化语句</li></ul><p>或者可以从另一个角度来表达：初始化阶段是执行类构造器<clinit>()方法的过程。<br> 这里简单说明下<clinit>（）方法(类构造器方法)的执行规则:</p><ol><li><p><clinit>（）方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句中可以赋值，但是不能访问。</p></li><li><p><clinit>（）方法与实例构造器<init>（）方法（类的构造函数）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<clinit>（）方法执行之前，父类的<clinit>（）方法已经执行完毕。因此，在虚拟机中第一个被执行的<clinit>（）方法的类肯定是java.lang.Object。</p></li><li><p><clinit>（）方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成<clinit>（）方法。</p></li><li><p>接口中不能使用静态语句块，但仍然有类变量（final static）初始化的赋值操作，因此接口与类一样会生成<clinit>（）方法。但是接口鱼类不同的是：执行接口的<clinit>（）方法不需要先执行父接口的<clinit>（）方法，只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit>（）方法。</p></li><li><p>虚拟机会保证一个类的<clinit>（）方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>（）方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>（）方法完毕。如果在一个类的<clinit>（）方法中有耗时很长的操作，那就可能造成多个线程阻塞，在实际应用中这种阻塞往往是很隐蔽的。</p><p>下面给出一个简单的例子，以便更清晰地说明如上规则：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> b = a;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClinitTest</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">System.out.println(Child.b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 执行上面的代码，会打印出2，也就是说b的值被赋为了2。</p><p>我们来看得到该结果的步骤。首先在准备阶段为类变量分配内存并设置类变量初始值，这样A和B均被赋值为默认值0，而后再在调用<clinit>（）方法时给他们赋予程序中指定的值。当我们调用Child.b时，触发Child的<clinit>（）方法，根据规则2，在此之前，要先执行完其父类Father的<clinit>（）方法，又根据规则1，在执行<clinit>（）方法时，需要按static语句或static变量赋值操作等在代码中出现的顺序来执行相关的static语句，<strong>因此当触发执行Father的<clinit>（）方法时，会先将a赋值为1，再执行static语句块中语句，将a赋值为2，而后再执行Child类的<clinit>（）方法，这样便会将b的赋值为2。</strong></p><p>  如果我们颠倒一下Father类中“public static int a = 1;”语句和“static语句块”的顺序，程序执行后，则会打印出1。很明显是根据规则1，执行Father的<clinit>（）方法时，根据顺序先执行了static语句块中的内容，后执行了“public static int a = 1;”语句。</p><p> 另外，在颠倒二者的顺序之后，如果在static语句块中对a进行访问（比如将a赋给某个变量），在编译时将会报错，因为根据规则1，它只能对a进行赋值，而不能访问。</p><h4 id="结束生命周期"><a href="#结束生命周期" class="headerlink" title="结束生命周期"></a>结束生命周期</h4><p>在以下情况的时候，Java虚拟机会结束生命周期：</p><ol><li><p>执行了System.exit()方法</p></li><li><p>程序正常执行结束</p></li><li><p>程序在执行过程中遇到了异常或错误而异常终止</p></li><li><p>由于操作系统出现错误而导致Java虚拟机进程终止</p></li></ol><h3 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h3><p>什么情况下需要开始类加载过程的第一个阶段:”加载”。虚拟机规范中并没强行约束，这点可以交给虚拟机的的具体实现自由把握，但是对于初始化阶段虚拟机规范是严格规定了如下几种情况，如果类未初始化会对类进行初始化。</p><ul><li><p>1、创建类的实例，也就是new一个对象</p></li><li><p>2、访问某个类或接口的静态变量，或者对该静态变量赋值</p></li><li><p>3、访问类的静态方法</p></li><li><p>4、反射如(Class.forName(“my.xyz.Test”))</p></li><li><p>5、当初始化一个类时，发现其父类还未初始化，则先出发父类的初始化</p></li><li><p>6、虚拟机启动时，定义了main()方法的那个类先初始化</p><p>除此之外，下面几种情形需要特别指出：</p><p>对于一个final类型的静态变量，如果该变量的值在编译时就可以确定下来，那么这个变量相当于“宏变量”。Java编译器会在编译时直接把这个变量出现的地方替换成它的值，因此即使程序使用该静态变量，也不会导致该类的初始化。反之，如果final类型的静态Field的值不能在编译时确定下来，则必须等到运行时才可以确定该变量的值，如果通过该类来访问它的静态变量，则会导致该类被初始化。</p></li></ul><p>以上情况称为称对一个类进行<strong>“主动引用”</strong>，除此种情况之外，均不会触发类的初始化。</p><p><strong>而称为“被动引用” 接口的加载过程与类的加载过程稍有不同。</strong>接口中不能使用static{}块。当一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有真正在使用到父接口时（例如引用接口中定义的常量）才会初始化。</p><p><strong>被动引用例子</strong></p><ul><li>1、子类调用父类的静态变量，子类不会被初始化。只有父类被初始化。。对于静态字段，只有直接定义这个字段的类才会被初始化.</li><li>2、通过数组定义来引用类，不会触发类的初始化</li><li>3、 访问类的常量，不会初始化类</li></ul><p>如下面代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">static</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">"superclass init"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">static</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">"subclass init"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        System.out.println(SubClass.value);<span class="comment">// 被动应用1  </span></span><br><span class="line">        SubClass[] sca = <span class="keyword">new</span> SubClass[<span class="number">10</span>];<span class="comment">// 被动引用2  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行输出 superclass init 123 从上面的输入结果证明了被动引用1与被动引用2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">static</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">"ConstClass init"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD = <span class="string">"hello world"</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        System.out.println(ConstClass.HELLOWORLD);<span class="comment">// 调用类常量  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出结果只有 hello world 从上面的输出结果证明了被动引用3</p><p>上面很详细的介绍了类的加载时机和类的加载过程，通过上面的理论来分析一些题目吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleTon singleTon = <span class="keyword">new</span> SingleTon();  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count1;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count2 = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleTon</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        count1++;  </span><br><span class="line">        count2++;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleTon <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> singleTon;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        SingleTon singleTon = SingleTon.getInstance();  </span><br><span class="line">        System.out.println(<span class="string">"count1="</span> + singleTon.count1);  </span><br><span class="line">        System.out.println(<span class="string">"count2="</span> + singleTon.count2);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析:<br>1 : SingleTon singleTon = SingleTon.getInstance();调用了类的SingleTon调用了类的静态方法，触发类的初始化</p><p>2 : 类加载的时候在准备过程中为类的静态变量分配内存并初始化默认值 singleton=null count1=0,count2=0</p><p>3 : 类初始化化，为类的静态变量赋值和执行静态代码快。singleton赋值为new SingleTon()调用类的构造方法</p><p>4 : 调用类的构造方法后count=1;count2=1</p><p>5 : 继续为count1与count2赋值,此时count1没有赋值操作,所有count1为1,但是count2执行赋值操作就变为0</p><h3 id="类初始化顺序"><a href="#类初始化顺序" class="headerlink" title="类初始化顺序"></a>类初始化顺序</h3><p>现在我们知道什么时候触发类的初始化了，他精确地写在Java语言规范中。但了解清楚 域（fields，静态的还是非静态的）、块（block静态的还是非静态的）、不同类（子类和超类）和不同的接口（子接口，实现类和超接口）的初始化顺序也很重要类。事实上很多核心Java面试题和SCJP问题都是基于这些概念，下面是类初始化的一些规则：</p><ul><li><p>1.类从顶至底的顺序初始化，所以声明在顶部的字段的早于底部的字段初始化</p></li><li><p>2.超类早于子类和衍生类的初始化</p></li><li><p>3.如果类的初始化是由于访问静态域而触发，那么只有声明静态域的类才被初始化，而不会触发超类的初始化或者子类的</p></li><li><p>4.初始化即使静态域被子类或子接口或者它的实现类所引用。</p></li><li><p>5.接口初始化不会导致父接口的初始化。</p></li><li><p>6.静态域的初始化是在类的静态初始化期间，非静态域的初始化时在类的实例创建期间。这意味这静态域初始化在非静态域之前。</p></li><li><p>7.非静态域通过构造器初始化，子类在做任何初始化之前构造器会隐含地调用父类的构造器，他保证了非静态或实例变量（父类）初始化早于子类</p></li></ul><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><h4 id="类加载器类型"><a href="#类加载器类型" class="headerlink" title="类加载器类型"></a>类加载器类型</h4><p> 类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识，<strong>这个唯一标识就是类的全限定名。</strong></p><blockquote><p>例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。</p></blockquote><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类的加载阶段。对于任意一个类，都需要由它的类加载器和这个类本身一同确定其在就Java虚拟机中的唯一性，也就是说，即使两个类来源于同一个Class文件，只要加载它们的类加载器不同，那这两个类就必定不相等。这里的“相等”包括了代表类的Class对象的equals（）、isAssignableFrom（）、isInstance（）等方法的返回结果，也包括了使用instanceof关键字对对象所属关系的判定结果。<br>站在Java虚拟机的角度来讲，只存在两种不同的类加载器：</p><ul><li><p>启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分。</p></li><li><p>所有其他的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</p><p>站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：</p></li></ul><p><strong>启动类加载器：Bootstrap ClassLoader</strong>：又叫根类加载器。跟上面相同，它负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。</p><p>下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line"><span class="keyword">for</span>(URL url : urls)&#123;</span><br><span class="line">System.out.println(url.toExternalForm());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果：</p><p>file:/D:/JAVA/jdk1.8/jre/lib/resources.jar<br>file:/D:/JAVA/jdk1.8/jre/lib/rt.jar<br>file:/D:/JAVA/jdk1.8/jre/lib/sunrsasign.jar<br>file:/D:/JAVA/jdk1.8/jre/lib/jsse.jar<br>file:/D:/JAVA/jdk1.8/jre/lib/jce.jar<br>file:/D:/JAVA/jdk1.8/jre/lib/charsets.jar<br>file:/D:/JAVA/jdk1.8/jre/lib/jfr.jar<br>file:/D:/JAVA/jdk1.8/jre/classes</p></blockquote><p><strong>扩展类加载器：Extension ClassLoader</strong>：该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。</p><p><strong>应用程序类加载器：Application ClassLoader</strong>：该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p><p> 应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：</p><p> 1）在执行非置信代码之前，自动验证数字签名。</p><p> 2）动态地创建符合用户特定需要的定制化构建类。</p><p> 3）从特定的场所取得java class，例如数据库中和网络中。</p><p>事实上当使用Applet的时候，就用到了特定的ClassLoader，因为这时需要从网络上加载java class，并且要检查相关的安全信息，应用服务器也大都使用了自定义的ClassLoader技术。</p><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>这几种类加载器的层次关系如下图所示：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/classload/1004.jpg" alt=""></p><p>这种层次关系称为类加载器的双亲委派模型。我们把每一层上面的类加载器叫做当前层类加载器的父加载器，当然，它们之间的父子关系并不是通过继承关系来实现的，而是使用组合关系来复用父加载器中的代码。该模型在JDK1.2期间被引入并广泛应用于之后几乎所有的Java程序中，但它并不是一个强制性的约束模型，而是Java设计者们推荐给开发者的一种类的加载器实现方式。</p><p>  双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p><p>使用这种模型来组织类加载器之间的关系的好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如java.lang.Object类，无论哪个类加载器去加载该类，最终都是由启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。否则的话，如果不使用该模型的话，如果用户自定义一个java.lang.Object类且存放在classpath中，那么系统中将会出现多个Object类，应用程序也会变得很混乱。如果我们自定义一个rt.jar中已有类的同名Java类，会发现JVM可以正常编译，但该类永远无法被加载运行。<br>在rt.jar包中的java.lang.ClassLoader类中，我们可以查看类加载实现过程的代码，具体源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class <span class="title">loadClass</span><span class="params">(String name, <span class="keyword">boolean</span> resolve)</span>  </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ClassNotFoundException </span>&#123;  </span><br><span class="line">    <span class="comment">// 首先检查该name指定的class是否有被加载  </span></span><br><span class="line">    Class c = findLoadedClass(name);  </span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                <span class="comment">// 如果parent不为null，则调用parent的loadClass进行加载  </span></span><br><span class="line">                c = parent.loadClass(name, <span class="keyword">false</span>);  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="comment">// parent为null，则调用BootstrapClassLoader进行加载  </span></span><br><span class="line">                c = findBootstrapClass0(name);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;  </span><br><span class="line">            <span class="comment">// 如果仍然无法加载成功，则调用自身的findClass进行加载  </span></span><br><span class="line">            c = findClass(name);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (resolve) &#123;  </span><br><span class="line">        resolveClass(c);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> c;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面代码可以看出，双亲委派模型是通过loadClass()方法来实现的，根据代码以及代码中的注释可以很清楚地了解整个过程其实非常简单：先检查是否已经被加载过，如果没有则调用父加载器的loadClass()方法，如果父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载器加载失败，则先抛出ClassNotFoundException，然后再调用自己的findClass()方法进行加载。</p><p><strong>当然，除了双亲委派之外，类的加载还有两种机制：全盘负责和缓存。</strong></p><h4 id="全盘负责"><a href="#全盘负责" class="headerlink" title="全盘负责"></a>全盘负责</h4><p>所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。</p><h4 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h4><p>缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。</p><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a><strong>自定义类加载器</strong></h3><p>若要实现自定义类加载器，只需要继承java.lang.ClassLoader 类，并且重写其findClass()方法即可。java.lang.ClassLoader 类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个 Java 类，即 java.lang.Class 类的一个实例。除此之外，ClassLoader 还负责加载 Java 应用所需的资源，如图像文件和配置文件等，ClassLoader 中与加载类相关的方法如下：</p><p>方法说明 getParent()  返回该类加载器的父类加载器。</p><p>loadClass(String name) 加载名称为 二进制名称为name 的类，返回的结果是 java.lang.Class 类的实例。</p><p>findClass(String name) 查找名称为 name 的类，返回的结果是 java.lang.Class 类的实例。</p><p>findLoadedClass(String name) 查找名称为 name 的已经被加载过的类，返回的结果是 java.lang.Class 类的实例。</p><p>resolveClass(Class&lt;?&gt; c) 链接指定的 Java 类。</p><p>注意：在JDK1.2之前，类加载尚未引入双亲委派模式，因此实现自定义类加载器时常常重写loadClass方法，提供双亲委派逻辑，从JDK1.2之后，双亲委派模式已经被引入到类加载体系中，自定义类加载器时不需要在自己写双亲委派的逻辑，因此不鼓励重写loadClass方法，而推荐重写findClass方法。</p><p>在Java中，任意一个类都需要由加载它的类加载器和这个类本身一同确定其在java虚拟机中的唯一性，即比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提之下才有意义，否则，即使这两个类来源于同一个Class类文件，只要加载它的类加载器不相同，那么这两个类必定不相等(这里的相等包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法和instanceof关键字的结果)。例子代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 一、ClassLoader加载类的顺序 </span></span><br><span class="line"><span class="comment">     *  1.调用 findLoadedClass(String) 来检查是否已经加载类。 </span></span><br><span class="line"><span class="comment">     *  2.在父类加载器上调用 loadClass 方法。如果父类加载器为 null，则使用虚拟机的内置类加载器。 </span></span><br><span class="line"><span class="comment">     *  3.调用 findClass(String) 方法查找类。 </span></span><br><span class="line"><span class="comment">     * 二、实现自己的类加载器 </span></span><br><span class="line"><span class="comment">     *  1.获取类的class文件的字节数组 </span></span><br><span class="line"><span class="comment">     *  2.将字节数组转换为Class类的实例 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> lei 2011-9-1 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException </span>&#123;  </span><br><span class="line">            <span class="comment">//新建一个类加载器  </span></span><br><span class="line">            MyClassLoader cl = <span class="keyword">new</span> MyClassLoader(<span class="string">"myClassLoader"</span>);  </span><br><span class="line">            <span class="comment">//加载类，得到Class对象  </span></span><br><span class="line">            Class&lt;?&gt; clazz = cl.loadClass(<span class="string">"classloader.Animal"</span>);  </span><br><span class="line">            <span class="comment">//得到类的实例  </span></span><br><span class="line">            Animal animal=(Animal) clazz.newInstance();  </span><br><span class="line">            animal.say();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;  </span><br><span class="line">            System.out.println(<span class="string">"hello world!"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//类加载器的名称  </span></span><br><span class="line">        <span class="keyword">private</span> String name;  </span><br><span class="line">        <span class="comment">//类存放的路径  </span></span><br><span class="line">        <span class="keyword">private</span> String path = <span class="string">"E:\\workspace\\Algorithm\\src"</span>;  </span><br><span class="line">        MyClassLoader(String name) &#123;  </span><br><span class="line">            <span class="keyword">this</span>.name = name;  </span><br><span class="line">        &#125;  </span><br><span class="line">        MyClassLoader(ClassLoader parent, String name) &#123;  </span><br><span class="line">            <span class="keyword">super</span>(parent);  </span><br><span class="line">            <span class="keyword">this</span>.name = name;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * 重写findClass方法 </span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; findClass(String name) &#123;  </span><br><span class="line">            <span class="keyword">byte</span>[] data = loadClassData(name);  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.defineClass(name, data, <span class="number">0</span>, data.length);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">byte</span>[] loadClassData(String name) &#123;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                name = name.replace(<span class="string">"."</span>, <span class="string">"//"</span>);  </span><br><span class="line">                FileInputStream is = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(path + name + <span class="string">".class"</span>));  </span><br><span class="line">                ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();  </span><br><span class="line">                <span class="keyword">int</span> b = <span class="number">0</span>;  </span><br><span class="line">                <span class="keyword">while</span> ((b = is.read()) != -<span class="number">1</span>) &#123;  </span><br><span class="line">                    baos.write(b);  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">return</span> baos.toByteArray();  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>类加载器双亲委派模型是从JDK1.2以后引入的，并且只是一种推荐的模型，不是强制要求的，因此有一些没有遵循双亲委派模型的特例：(了解)</p><p>(1).在JDK1.2之前，自定义类加载器都要覆盖loadClass方法去实现加载类的功能，JDK1.2引入双亲委派模型之后，loadClass方法用于委派父类加载器进行类加载，只有父类加载器无法完成类加载请求时才调用自己的findClass方法进行类加载，因此在JDK1.2之前的类加载的loadClass方法没有遵循双亲委派模型，因此在JDK1.2之后，自定义类加载器不推荐覆盖loadClass方法，而只需要覆盖findClass方法即可。</p><p>(2).双亲委派模式很好地解决了各个类加载器的基础类统一问题，越基础的类由越上层的类加载器进行加载，但是这个基础类统一有一个不足，当基础类想要调用回下层的用户代码时无法委派子类加载器进行类加载。为了解决这个问题JDK引入了ThreadContext线程上下文，通过线程上下文的setContextClassLoader方法可以设置线程上下文类加载器。</p><p>JavaEE只是一个规范，sun公司只给出了接口规范，具体的实现由各个厂商进行实现，因此JNDI，JDBC,JAXB等这些第三方的实现库就可以被JDK的类库所调用。线程上下文类加载器也没有遵循双亲委派模型。</p><p>(3).近年来的热码替换，模块热部署等应用要求不用重启java虚拟机就可以实现代码模块的即插即用，催生了OSGi技术，在OSGi中类加载器体系被发展为网状结构。OSGi也没有完全遵循双亲委派模型。</p><h3 id="动态加载Jar-amp-amp-ClassLoader-隔离问题"><a href="#动态加载Jar-amp-amp-ClassLoader-隔离问题" class="headerlink" title="动态加载Jar &amp;&amp; ClassLoader 隔离问题"></a><strong>动态加载Jar &amp;&amp; ClassLoader 隔离问题</strong></h3><h4 id="动态加载Jar"><a href="#动态加载Jar" class="headerlink" title="动态加载Jar"></a>动态加载Jar</h4><p>Java 中动态加载 Jar 比较简单，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URL[] urls = <span class="keyword">new</span> URL[] &#123;<span class="keyword">new</span> URL(<span class="string">"file:libs/jar1.jar"</span>)&#125;;  </span><br><span class="line">URLClassLoader loader = <span class="keyword">new</span> URLClassLoader(urls, parentLoader);</span><br></pre></td></tr></table></figure><p>表示加载 libs 下面的 jar1.jar，其中 parentLoader 就是上面1中的 parent，可以为当前的 ClassLoader。</p><h4 id="ClassLoader-隔离问题"><a href="#ClassLoader-隔离问题" class="headerlink" title="ClassLoader 隔离问题"></a>ClassLoader 隔离问题</h4><p>大家觉得一个运行程序中有没有可能同时存在两个包名和类名完全一致的类？ JVM 及 Dalvik 对类唯一的识别是 ClassLoader id + PackageName + ClassName，所以一个运行程序中是有可能存在两个包名和类名完全一致的类的。并且如果这两个”类”不是由一个 ClassLoader 加载，是无法将一个类的示例强转为另外一个类的，这就是 ClassLoader 隔离。 如 Android 中碰到如下异常 [java] view plain copy</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android.support.v4.view.ViewPager can not be cast to android.support.v4.view.ViewPager</span><br></pre></td></tr></table></figure><p>当碰到这种问题时可以通过 instance.getClass().getClassLoader(); 得到 ClassLoader，看 ClassLoader 是否一样。</p><h4 id="加载不同-Jar-包中公共类"><a href="#加载不同-Jar-包中公共类" class="headerlink" title="加载不同 Jar 包中公共类"></a>加载不同 Jar 包中公共类</h4><p>现在 Host 工程包含了 common.jar, jar1.jar, jar2.jar，并且 jar1.jar 和 jar2.jar 都包含了 common.jar，我们通过 ClassLoader 将 jar1, jar2 动态加载进来，这样在 Host 中实际是存在三份 common.jar，如下图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/classload/1007.jpg" alt=""></p><p>我们怎么保证 common.jar 只有一份而不会造成上面3中提到的 ClassLoader 隔离的问题呢，其实很简单，在生成 jar1 和 jar2 时把 common.jar 去掉，只保留 host 中一份，以 host ClassLoader 为 parentClassLoader 即可。</p><h4 id="总结：一道面试题"><a href="#总结：一道面试题" class="headerlink" title="总结：一道面试题"></a><strong>总结：一道面试题</strong></h4><p>能不能自己写个类叫java.lang.System？<br>答案：通常不可以，但可以采取另类方法达到这个需求。<br>解释：为了不让我们写System类，类加载采用委托机制，这样可以保证爸爸们优先，爸爸们能找到的类，儿子就没有机会加载。而System类是Bootstrap加载器加载的，就算自己重写，也总是使用Java系统提供的System，自己写的System类根本没有机会得到加载。<br>但是，我们可以自己定义一个类加载器来达到这个目的，为了避免双亲委托机制，这个类加载器也必须是特殊的。由于系统自带的三个类加载器都加载特定目录下的类，如果我们自己的类加载器放在一个特殊的目录，那么系统的加载器就无法加载，也就是最终还是由我们自己的加载器加载。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机（八）Class文件基本组织结构</title>
      <link href="/2020/03/11/Java%E8%99%9A%E6%8B%9F%E6%9C%BA8/"/>
      <url>/2020/03/11/Java%E8%99%9A%E6%8B%9F%E6%9C%BA8/</url>
      
        <content type="html"><![CDATA[<h2 id="Class文件基本组织结构"><a href="#Class文件基本组织结构" class="headerlink" title="Class文件基本组织结构"></a>Class文件基本组织结构</h2><p>关于类和对象，已经是老生常谈的事情了。关于对象的结构，在讲述Synchronized的时候，大致的讲述了一遍，而现在开始学习，关于Class文件的结构。</p><p>我们先放一个示意图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/2020%E5%B9%B43%E6%9C%8811%E6%97%A5142543.png" alt=""></p><p>这就是Class文件的组织结构，下面我们一步一步讲解，它们是什么。</p><h4 id="魔数-magic"><a href="#魔数-magic" class="headerlink" title="魔数(magic)"></a>魔数(magic)</h4><p>当JVM在尝试加载某个文件到内存中来的时候，会首先判断此class文件有没有JVM认为可以接受的“签名”，即JVM会首先读取文件的前4个字节，判断该4个字节是否是“0xCAFEBABE”，如果是，则JVM会认为可以将此文件当作class文件来加载并使用。</p><p>可以看作为，这是一个最基本的保险，它会对文件进行基本的验证，以致于不会随便改一个后缀名，就能入JVM的法眼。</p><h4 id="版本号-minor-version-major-version"><a href="#版本号-minor-version-major-version" class="headerlink" title="版本号(minor_version,major_version)"></a>版本号(minor_version,major_version)</h4><p>Java有很多不同的版本，不同的JDK里面，Class的结构多少都会有着轻微的调动，面对这样情况，Java虚拟机会让每一个类文件中包含自己的JDK版本。</p><p>主版本号和次版本号在class文件中各占两个字节，副版本号占用第5、6两个字节，而主版本号则占用第7，8两个字节。JDK1.0的主版本号为45，以后的每个新主版本都会在原先版本的基础上加1。若现在使用的是JDK1.7编译出来的class文件，则相应的主版本号应该是51,对应的7，8个字节的十六进制的值应该是 0x33。</p><p> 一个 JVM实例只能支持特定范围内的主版本号 （Mi 至Mj） 和 0 至特定范围内 （0 至 m） 的副版本号。假设一个 Class 文件的格式版本号为 V， 仅当Mi.0 ≤ v ≤ Mj.m成立时，这个 Class 文件才可以被此 Java 虚拟机支持。不同版本的 Java 虚拟机实现支持的版本号也不同，高版本号的 Java 虚拟机实现可以支持低版本号的 Class 文件，反之则不成立。</p><p>JVM在加载class文件的时候，会读取出主版本号，然后比较这个class文件的主版本号和JVM本身的版本号，如果JVM本身的版本号 &lt; class文件的版本号，JVM会认为加载不了这个class文件，会抛出我们经常见到的<strong>“java.lang.UnsupportedClassVersionError: Bad version number in .class file “</strong> Error 错误；反之，JVM会认为可以加载此class文件，继续加载此class文件。</p><h4 id="常量池计数器-constant-pool-count"><a href="#常量池计数器-constant-pool-count" class="headerlink" title="常量池计数器(constant_pool_count)"></a>常量池计数器(constant_pool_count)</h4><p>常量池是class文件中非常重要的结构，它描述着整个class文件的字面量信息。 常量池是由一组constant_pool结构体数组组成的，而数组的大小则由常量池计数器指定。常量池计数器constant_pool_count 的值 =constant_pool表中的成员数+ 1。constant_pool表的索引值只有在大于 0 且小于constant_pool_count时才会被认为是有效的。</p><h4 id="常量池数据区-constant-pool-contstant-pool-count-1"><a href="#常量池数据区-constant-pool-contstant-pool-count-1" class="headerlink" title="常量池数据区(constant_pool[contstant_pool_count-1])"></a>常量池数据区(constant_pool[contstant_pool_count-1])</h4><p>常量池，constant_pool是一种表结构,它包含 Class 文件结构及其子结构中引用的所有字符串常量、 类或接口名、字段名和其它常量。 常量池中的每一项都具备相同的格式特征——第一个字节作为类型标记用于识别该项是哪种类型的常量，称为 “tag byte” 。常量池的索引范围是 1 至constant_pool_count−1。</p><h4 id="访问标志-access-flags"><a href="#访问标志-access-flags" class="headerlink" title="访问标志(access_flags)"></a>访问标志(access_flags)</h4><p>访问标志，access_flags 是一种掩码标志，用于表示某个类或者接口的访问权限及基础属性。如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/2020%E5%B9%B43%E6%9C%8811%E6%97%A5142550.png" alt=""></p><h4 id="类索引-this-class"><a href="#类索引-this-class" class="headerlink" title="类索引(this_class)"></a>类索引(this_class)</h4><p>类索引，this_class的值必须是对constant_pool表中项目的一个有效索引值。constant_pool表在这个索引处的项必须为CONSTANT_Class_info 类型常量，表示这个 Class 文件所定义的类或接口。通俗点讲，它表示的就是类本身的名字。</p><h4 id="父类索引-super-class"><a href="#父类索引-super-class" class="headerlink" title="父类索引(super_class)"></a>父类索引(super_class)</h4><p>对于类来说，super_class 的值必须为 0 或者是对constant_pool 表中项目的一个有效索引值。如果它的值不为 0，那 constant_pool 表在这个索引处的项必须为CONSTANT_Class_info 类型常量，表示这个 Class 文件所定义的类的直接父类。当前类的直接父类，以及它所有间接父类的access_flag 中都不能带有ACC_FINAL 标记。如果 Class 文件的 super_class的值为 0，那这个Class文件只可能是定义的是java.lang.Object类，只有它是唯一没有父类的类。因此除了java.lang.Object外，所有Java类的父类索引都不为0。</p><p>对于接口来说，它的Class文件的super_class项的值必须是对constant_pool表中项目的一个有效索引值。constant_pool表在这个索引处的项必须为代表 java.lang.Object 的 CONSTANT_Class_info 类型常量 。</p><h4 id="接口计数器-interfaces-count"><a href="#接口计数器-interfaces-count" class="headerlink" title="接口计数器(interfaces_count)"></a>接口计数器(interfaces_count)</h4><p>接口计数器，interfaces_count的值表示当前类或接口的直接父接口数量。</p><h4 id="接口信息数据区-interfaces-interfaces-count"><a href="#接口信息数据区-interfaces-interfaces-count" class="headerlink" title="接口信息数据区(interfaces[interfaces_count])"></a>接口信息数据区(interfaces[interfaces_count])</h4><p>接口表，interfaces[]数组中的每个成员的值必须是一个对constant_pool表中项目的一个有效索引值， 它的长度为 interfaces_count。每个成员 interfaces[i]  必须为 CONSTANT_Class_info类型常量，其中 0 ≤ i &lt;interfaces_count。在interfaces[]数组中，成员所表示的接口顺序和对应的源代码中给定的接口顺序（从左至右）一样，即interfaces[0]对应的是源代码中最左边的接口。</p><h4 id="字段计数器-fields-count"><a href="#字段计数器-fields-count" class="headerlink" title="字段计数器(fields_count)"></a>字段计数器(fields_count)</h4><p> 字段计数器，fields_count的值表示当前 Class 文件 fields[]数组的成员个数。 fields[]数组中每一项都是一个field_info结构的数据项，它用于表示该类或接口声明的类字段或者实例字段。这是Java的特性，可以以任意一个类作为数组，这是C++所不具有的。</p><h4 id="字段信息数据区-fields-fields-count"><a href="#字段信息数据区-fields-fields-count" class="headerlink" title="字段信息数据区(fields[fields_count])"></a>字段信息数据区(fields[fields_count])</h4><p> 字段表，fields[]数组中的每个成员都必须是一个fields_info结构的数据项，用于表示当前类或接口中某个字段的完整描述。 fields[]数组描述当前类或接口声明的所有字段，但不包括从父类或父接口继承的部分。</p><h4 id="方法计数器-methods-count"><a href="#方法计数器-methods-count" class="headerlink" title="方法计数器(methods_count)"></a>方法计数器(methods_count)</h4><p>  方法计数器， methods_count的值表示当前Class 文件 methods[]数组的成员个数。Methods[]数组中每一项都是一个 method_info 结构的数据项。</p><h4 id="方法信息数据区-methods-methods-count"><a href="#方法信息数据区-methods-methods-count" class="headerlink" title="方法信息数据区(methods[methods_count])"></a>方法信息数据区(methods[methods_count])</h4><p> 方法表，methods[] 数组中的每个成员都必须是一个 method_info 结构的数据项，用于表示当前类或接口中某个方法的完整描述。如果某个method_info 结构的access_flags 项既没有设置 ACC_NATIVE 标志也没有设置ACC_ABSTRACT 标志，那么它所对应的方法体就应当可以被 Java 虚拟机直接从当前类加载，而不需要引用其它类。 method_info结构可以表示类和接口中定义的所有方法，包括实例方法、类方法、实例初始化方法方法和类或接口初始化方法方法 。methods[]数组只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法。</p><h4 id="属性计数器-attributes-count"><a href="#属性计数器-attributes-count" class="headerlink" title="属性计数器(attributes_count)"></a>属性计数器(attributes_count)</h4><p> 属性计数器，attributes_count的值表示当前 Class 文件attributes表的成员个数。attributes表中每一项都是一个attribute_info 结构的数据项。</p><h4 id="属性信息数据区-attributes-attributes-count"><a href="#属性信息数据区-attributes-attributes-count" class="headerlink" title="属性信息数据区(attributes[attributes_count])"></a>属性信息数据区(attributes[attributes_count])</h4><p>属性表，attributes 表的每个项的值必须是attribute_info结构。</p><p> 在Java 7 规范里，Class文件结构中的attributes表的项包括下列定义的属性： InnerClasses  、 EnclosingMethod 、 Synthetic  、Signature、SourceFile，SourceDebugExtension 、Deprecated、RuntimeVisibleAnnotations 、RuntimeInvisibleAnnotations以及BootstrapMethods属性。</p><p>  对于支持 Class 文件格式版本号为 49.0 或更高的 Java 虚拟机实现，必须正确识别并读取attributes表中的Signature、RuntimeVisibleAnnotations和RuntimeInvisibleAnnotations属性。对于支持Class文件格式版本号为 51.0 或更高的 Java 虚拟机实现，必须正确识别并读取 attributes表中的BootstrapMethods属性。Java 7 规范 要求任一 Java 虚拟机实现可以自动忽略 Class 文件的 attributes表中的若干 （甚至全部） 它不可识别的属性项。任何本规范未定义的属性不能影响Class文件的语义，只能提供附加的描述信息 。</p><p>以上就是类文件结构了，可以概括为以下的一张图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/2020%E5%B9%B43%E6%9C%8811%E6%97%A5142555.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目设计：一个服装定制商城</title>
      <link href="/2020/03/09/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C1/"/>
      <url>/2020/03/09/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C1/</url>
      
        <content type="html"><![CDATA[<h2 id="服装定制商城"><a href="#服装定制商城" class="headerlink" title="服装定制商城"></a>服装定制商城</h2><p>最近，花七天做了一个商城的项目，是一个服装定制商城，这个商城集合了我自己所学习的大部分技术。我先列一下这个商城用到的技术：</p><ol><li>springmvc</li><li>thymeleaf</li><li>mybatis</li><li>webSecurity</li><li>WebSocket</li><li>rest风格</li><li>redis</li><li>docker</li></ol><p>这个商城的前端是来自一位GitHub的开发者，而后端则是完全由自己完成的，在这个过程中，以我的角度来说，三分之二的时间都在写thymeleaf和Controller。尤其是在写的时候一遍又一遍的体会thymeleaf的各种语法，以及把DAO层的一些数据拿到Controller层进行转发，当然，都进行了REST风格化。而还有三分之一的时间在mybatis和Security身上，对mybatis的各种获取数据和Security的对各个页面的权限，其实最让我满意的就是这一部分了。</p><p>在这个项目过程中，我主要做对了一件事情，就是先进行了对Security的设计，而做错了很多事情，那就是没有先设计好数据库和页面，对页面跳转的各种方法，非常的粗糙，但这也让我领悟到了很关键的一层，一开始有一个对系统架构的完整设计，是多么重要的事情，我们接到一个需求的时候，就先应该设计好数据库表，在去对各种功能的完善。</p><p>做这个项目难吗？我觉得，并不难，也许是我才学浅，大部分的时间都浪费在了CRUD身上，不过，确实很多程序员都是干CRUD的:happy:。</p><p>在一些技术的运用，例如Security，Socket，本人认为并没有什么差错，倒是简单的SpringMVC，运用的有些糟糕，但我也从中吸取到了很多教训，比如前端的很多请求，最好都使用POST表单提交，而少使用一些 直接定位的GET请求，而后端在控制器层最好少使用一些对数据库的采集，最好反复利用Session。</p><p>下面我开始简单的讲述一下，这个服装定制商城。</p><p>这个项目在设计之初，我就想到了要做前台和后台，这样的Security是必不可少的，我首先列出了有哪一些用户，然后将数据库的用户进行了分开的处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">      <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String s)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        UserModel user = userService.getUserName(s);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UsernameNotFoundException(<span class="string">"用户不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(user.getUsername() ,user.getPassword(),</span><br><span class="line">                createAuthority(user.getRoles()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里是将数据库的角色分割，构造GrantedAuthority</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;SimpleGrantedAuthority&gt; <span class="title">createAuthority</span><span class="params">(String roles)</span> </span>&#123;</span><br><span class="line">        String[] roleArray = roles.split(<span class="string">","</span>);</span><br><span class="line">        List&lt;SimpleGrantedAuthority&gt; authorityList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String role : roleArray) &#123;</span><br><span class="line">            authorityList.add(<span class="keyword">new</span> SimpleGrantedAuthority(role));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> authorityList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>基于Security的特性，权限都是：ROLE_USER 这样的类型，然后会 割开“_”，来选择权限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">"/"</span>).permitAll()<span class="comment">//允许/、/login的访问</span></span><br><span class="line">                .antMatchers(<span class="string">"/user/**"</span>).hasRole(<span class="string">"USER"</span>)<span class="comment">//用户USER角色的用户访问有关/user下面的所有</span></span><br><span class="line">                .antMatchers(<span class="string">"/admin/**"</span>).hasRole(<span class="string">"ADMIN"</span>)<span class="comment">//同上</span></span><br><span class="line"><span class="comment">//                .anyRequest().authenticated()//其它所有访问都拦截</span></span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()<span class="comment">//添加登陆</span></span><br><span class="line">                .loginPage(<span class="string">"/login"</span>).permitAll()<span class="comment">//登陆页面“/login"允许访问</span></span><br><span class="line">                .defaultSuccessUrl(<span class="string">"/"</span>)<span class="comment">//成功默认跳转 url</span></span><br><span class="line">                .usernameParameter(<span class="string">"user"</span>)</span><br><span class="line">                .passwordParameter(<span class="string">"password"</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line">                .exceptionHandling().accessDeniedPage(<span class="string">"/error"</span>);</span><br><span class="line"></span><br><span class="line">        http.rememberMe();</span><br><span class="line">        http.logout().logoutSuccessUrl(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>有着Security的帮助，从某种程度而言，也是一个架构的雏形呢，起码一个CRUD操作，不会越写越乱。</p><p>然后，就是把图片与本地的数据库分离，进一步降低数据库的压力：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 华南机房,配置自己空间所在的区域</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> com.qiniu.storage.<span class="function">Configuration <span class="title">qiniuConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> com.qiniu.storage.Configuration(Zone.zone2());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建一个七牛上传工具实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UploadManager <span class="title">uploadManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UploadManager(qiniuConfig());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 认证信息实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Auth <span class="title">auth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Auth.create(qiniuProperties.getAccessKey(), qiniuProperties.getSecretKey());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建七牛空间管理实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BucketManager <span class="title">bucketManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BucketManager(auth(), qiniuConfig());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Gson <span class="title">gson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Gson();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以流的形式上传图片</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回访问路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"upload"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">uploadFile</span><span class="params">(@RequestParam(value = <span class="string">"file"</span>)</span> MultipartFile file) <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> qiniuService.uploadFile(file.getInputStream());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"delete/&#123;key&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">deleteFile</span><span class="params">(@PathVariable String key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> qiniuService.delete(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这方面，有着各自的接口是辅助实现。</p><p>然后，是在思考如何生成一个全局唯一的ID，那时候想了很久，最后在网络上找到了，雪花算法。</p><p>并且，算是会熟练的使用MyBatis写SQL语句了吧。下面列一些拙劣的操作：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- 展示产品 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"showProduct"</span> <span class="attr">resultType</span>=<span class="string">"product"</span>&gt;</span></span><br><span class="line">select * from product_table</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--获取单个产品--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getProduct"</span> <span class="attr">resultType</span>=<span class="string">"product"</span>&gt;</span></span><br><span class="line">select * from product_table where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--获取图片群--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getimgs"</span> <span class="attr">resultType</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">select * from item_table where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--增加产品--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addProduct"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span></span></span><br><span class="line"><span class="tag"><span class="attr">parameterType</span>=<span class="string">"product"</span>&gt;</span></span><br><span class="line">insert into product_table(product_name, stock,price,version,note,img)</span><br><span class="line">values(#&#123;productName&#125;,#&#123;stock&#125;,#&#123;price&#125;,#&#123;version&#125;,#&#123;note&#125;,#&#123;img&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 减少产品 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteProduct"</span> <span class="attr">parameterType</span>=<span class="string">"long"</span>&gt;</span></span><br><span class="line">delete from product_table where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--搜索功能  =--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"searchProduct"</span> <span class="attr">resultType</span>=<span class="string">"product"</span>&gt;</span></span><br><span class="line">select * from product_table where product_name LIKE CONCAT('%',#&#123;productname&#125;,'%' )</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然，这些操作并没有多么的出彩，甚至可以说是污点。</p><p>当然，我也有很多自以为是的骚操作：</p><p>比如，实现聊天信息的字符串拼接，每当有一句话被写回到后端时，不急于写进数据库，而是将它们给拼进session中，等聊天结束了，再某一个页面，写回数据库：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (session.getAttribute(<span class="string">"msg"</span>)==<span class="keyword">null</span>)&#123;</span><br><span class="line">    session.setAttribute(<span class="string">"msg"</span>,<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String text=username+<span class="string">":"</span>+msg+<span class="string">"。"</span>+<span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">session.setAttribute(<span class="string">"msg"</span>,session.getAttribute(<span class="string">"msg"</span>)+text);</span><br></pre></td></tr></table></figure><p>当然本人也有自己的职业操守的，比如@PathVariable这个注解，就使用了很多，时刻注意的规范。</p><p>同时，也伴随着一些失败的操作，比如说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location.href = <span class="string">'/user/design/'</span>+[[$&#123;product.getId()&#125;]];</span><br></pre></td></tr></table></figure><p>过多的使用了直接定位，这使得网页的传参变得不那么安全。</p><p>以及为了急于放行，对数据库表的设计，非常的混乱，这也是必须注意的一个点。虽然它也就做了七天。</p><p>最后，再放一下这个项目的源码吧：</p>]]></content>
      
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B+树索引和算法</title>
      <link href="/2020/03/01/mysql4/"/>
      <url>/2020/03/01/mysql4/</url>
      
        <content type="html"><![CDATA[<h2 id="B-树索引和算法"><a href="#B-树索引和算法" class="headerlink" title="B+树索引和算法"></a>B+树索引和算法</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>数据结构是在学习编程的过程中，必须越过的坎。很多数据结构理解起来并不会太难，但是要说到会灵活运用，那就有很长一段路需要走。</p><p>而现在要学习的，就是运用在MySQL数据库里面的数据结构——B+树。</p><p>但是在了解B+树之前，先说说它的来源。</p><h4 id="二叉查找法"><a href="#二叉查找法" class="headerlink" title="二叉查找法"></a>二叉查找法</h4><p>我们需要查询这个值的时，最基本的算法就是使用二叉查找法，它能在一个已排序好的数组中，极大的提高查找的效率，这种算法思想被广泛地运用到了生活的各个领域。但是值得注意的是，二叉查找法也仅仅是给众多人提供一个足够好的思路而已，它所衍生出来的各种算法，才是真正被运用的算法。</p><p>二叉查找法非常的简单，这里懒得讲了:sleeping:</p><h4 id="二叉查找树与平衡二叉树"><a href="#二叉查找树与平衡二叉树" class="headerlink" title="二叉查找树与平衡二叉树"></a>二叉查找树与平衡二叉树</h4><p>B+树，就是先通过二叉查找树，再通过平衡二叉树，所衍生出来的。</p><p>二叉搜索树也是一种树，适用与一般二叉树的全部操作，但二叉搜索树能够实现数据的快速查找。</p><p>性质：</p><ul><li>非空左子树的所有键值小于其根节点的键值</li><li>非空右子树的所有键值大于其根节点的键值</li><li>左右子树都是二叉查找树</li></ul><p>可以浅显的理解为，将一个排序好的数组，转为二叉树的形式，去查找。</p><p>但是，你也要想，如果这个树被广泛的使用后，添加了非常多，非常大的数字，那么这个二叉树的中心节点不变的话，岂不是形成了“右重左轻”的二叉树呢？</p><p>于是，便由这个思想，改进成了一个，平衡二叉树。</p><p>平衡二叉树的提出就是为了保证树不至于太倾斜，尽量保证两边平衡。因此它的定义如下：</p><ul><li>平衡二叉树要么是一棵空树</li><li>要么保证左右子树的高度之差不大于 1</li><li>子树也必须是一颗平衡二叉树</li></ul><p>也就是说，树的两个左子树的高度差别不会太大，一旦有了新的节点加入，则会通过左旋或者是右旋的方式，去稳定的保持根节点必须为中心节点。</p><h4 id="B-树"><a href="#B-树" class="headerlink" title="B+ 树"></a>B+ 树</h4><p>B+树是为磁盘或其他直接存取辅助设备而设计的一种平衡二叉树，在B+树中，所有记录节点都是按键值的大小顺序存放在同一层的叶节点中，各叶节点指针进行连接。</p><p><img src="https://box.kancloud.cn/eccb1d67a2b49c28bfdb9eee8e93c685_897x237.png" alt=""></p><p>可以看出，所有记录都在叶节点中，并且是顺序存放的，如果我们从最左边的叶节点开始顺序遍历，可以得到所有键值的顺序排序：5、10、15、20、25、30、50、55、60、65、75、80、85、90。</p><p>一个最形象的比喻是：把它看作为一个刻度尺，我们总是先看到厘米，再由厘米，找到毫米。</p><h5 id="B-树的插入操作"><a href="#B-树的插入操作" class="headerlink" title="B+树的插入操作"></a>B+树的插入操作</h5><p>B+树的插入必须保证插入后叶节点中的记录依然排序，同时需要考虑插入B+树的三种情况，每种情况都可能会导致不同的插入算法：</p><p><img src="https://box.kancloud.cn/2122478de5826e7d6581f0a441598087_903x400.png" alt=""></p><p>我们用实例来分析B+树的插入，我们插入28这个键值，发现当前Leaf Page和Index Page都没有满，我们直接插入就可以了。</p><p><img src="https://box.kancloud.cn/03518dfdb10771c4bda7bb4e472ea021_898x220.png" alt=""></p><p>这次我们再插入一条70这个键值，这时原先的Leaf Page已经满了，但是Index Page还没有满，符合表的第二种情况，这时插入Leaf Page后的情况为50、55、60、65、70。我们根据中间的值60拆分叶节点。</p><p><img src="https://box.kancloud.cn/1808b3e428e0aa74fd7e6cd2c976f6e1_836x294.png" alt=""></p><p>因为图片显示的关系，这次我没有能在各叶节点加上双向链表指针。最后我们来插入记录95，这时符合表5-1讨论的第三种情况，即Leaf Page和Index Page都满了，这时需要做两次拆分。</p><p><img src="https://box.kancloud.cn/938eab2179096474f075120bdb81663e_869x393.png" alt=""></p><p>可以看到，不管怎么变化，B+树总是会保持平衡。但是为了保持平衡，对于新插入的键值可能需要做大量的拆分页（split）操作，而B+树主要用于磁盘，因此页的拆分意味着磁盘的操作，应该在可能的情况下尽量减少页的拆分。因此，B+树提供了旋转（rotation）的功能。</p><p>旋转发生在Leaf Page已经满了、但是其左右兄弟节点没有满的情况下。这时B+树并不会急于去做拆分页的操作，而是将记录移到所在页的兄弟节点上。通常情况下，左兄弟被首先检查用来做旋转操作，这时我们插入键值70，其实B+树并不会急于去拆分叶节点，而是做旋转，50，55，55旋转。</p><p><img src="https://box.kancloud.cn/b193456c7db65d4257612f48a8064e17_901x225.png" alt=""></p><p>可以看到，采用旋转操作使B+树减少了一次页的拆分操作，而这时B+树的高度依然还是2。</p><h5 id="B-树的删除操作"><a href="#B-树的删除操作" class="headerlink" title="B+树的删除操作"></a>B+树的删除操作</h5><p>B+树使用填充因子（fill factor）来控制树的删除变化，50%是填充因子可设的最小值。B+树的删除操作同样必须保证删除后叶节点中的记录依然排序，同插入一样，B+树的删除操作同样需要考虑如表5-2所示的三种情况，与插入不同的是，删除根据填充因子的变化来衡量。</p><p><img src="https://box.kancloud.cn/ba29654ad6ef9445a0fc01251198e620_903x246.png" alt=""></p><p>首先，删除键值为70的这条记录，该记录符合表5-2讨论的第一种情况，删除后。</p><p><img src="https://box.kancloud.cn/92e83659ef72c970cb6aed620dc33e56_905x393.png" alt=""></p><p>接着我们删除键值为25的记录，这也是表5-2讨论的第一种情况，但是该值还是Index Page中的值，因此在删除Leaf Page中25的值后，还应将25的右兄弟节点的28更新到Page Index中，最后可得到图。</p><p><img src="https://box.kancloud.cn/aa292aa7671d2859709bc1cae0e6b28f_897x401.png" alt=""></p><p>最后我们来看删除键值为60的情况，删除Leaf Page中键值为60的记录后，填充因子小于50%，这时需要做合并操作，同样，在删除Index Page中相关记录后需要做Index Page的合并操作，最后得到图。</p><p><img src="https://box.kancloud.cn/e65eff5a8a50f72ce99baf4a7b633c2f_795x289.png" alt=""></p><h3 id="InnoDB的B-树索引"><a href="#InnoDB的B-树索引" class="headerlink" title="InnoDB的B+树索引"></a>InnoDB的B+树索引</h3><p>B+树索引其本质就是B+树在数据库中的实现，但是B+索引在数据库中有一个特点就是其高扇出性，因此在数据库中，B+树的高度一般都在2～3层，也就是对于查找某一键值的行记录，最多只需要2到3次IO，这倒不错。因为我们知道现在一般的磁盘每秒至少可以做100次IO，2～3次的IO意味着查询时间只需0.02～0.03秒。</p><p>数据库中的B+树索引可以分为聚集索引（clustered index）和辅助聚集索引（secondary index）辅助聚集索引有时也称非聚集索引（non-clustered index）。</p><p>但是不管是聚集还是非聚集的索引，其内部都是B+树的，即高度平衡的，叶节点存放着所有的数据。聚集索引与非聚集索引不同的是，叶节点存放的是否是一整行的信息。</p><h4 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h4><p>InnoDB存储引擎表是索引组织表，即表中数据按照主键顺序存放。而聚集索引就是按照每张表的主键构造一颗B+树，并且叶节点中存放着整张表的行记录数据，因此也让聚集索引的叶节点成为数据页。聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。同B+树数据结构一样，每个数据页都通过一个双向链表来进行链接。</p><p>由于实际的数据页只能按照一颗B+树进行排序，因此每张表只能拥有一个聚集索引。在许多情况下，查询优化器非常倾向于采用聚集索引，因为聚集索引能够让我们在索引的叶节点上直接找到数据。此外，由于定义了数据的逻辑顺序，聚集索引能够特别快地访问针对范围值的查询。查询优化器能够快速发现某一段范围的数据页需要扫描。</p><p>现在我们来看一张表，我们以人为的方式让其每个页只能存放两个行记录，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MySQL [qiushibaike]&gt; create table t(</span><br><span class="line">    -&gt; a int not null, </span><br><span class="line">    -&gt; b varchar(8000),</span><br><span class="line">    -&gt; c int not null,</span><br><span class="line">    -&gt; primary key (a),</span><br><span class="line">    -&gt; key idx_c(c)</span><br><span class="line">    -&gt; )engine&#x3D;INNODB;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">insert into t select 1,repeat(&#39;a&#39;,7000),-1;</span><br><span class="line"></span><br><span class="line">insert into t select 2,repeat(&#39;a&#39;,7000),-2;</span><br><span class="line"></span><br><span class="line">insert into t select 3,repeat(&#39;a&#39;,7000),-3;</span><br><span class="line"></span><br><span class="line">insert into t select 4,repeat(&#39;a&#39;,7000),-4;</span><br></pre></td></tr></table></figure><p>可以看到，我们表的定义和插入方式使得目前每个页只能存放两个行记录，我们用py_innodb_page_info工具来分析表空间，可得：py_innodb_page_info.py-v mytest/t.ibd</p><p>page level为0000的即是数据页。我们要分析的是page level为0001的页，该页是B+树的根，我们来看看索引的根页中存放的数据。</p><p>我们直接通过页尾的Page Directory来分析，从00 63可以知道该页中行开始的位置。接着通过Recorder Header来分析，0xc063开始的值为69 6e 66 69 6d 75 6d 00，就代表infimum伪行记录。之前的5个字节01 00 02 00 1b就是Recorder Header，分析第4位到第8位的值1代表该行记录中只有一个记录（需要记住的是，InnoDB的Page Directory是稀疏的），即infimum记录本身。我们通过Recorder Header中最后的两个字节00 1b来判断下一条记录的位置，即c063+1b=c073，读取键值可得80 01，就是主键为1的键值（我们制定的INT是无符号的，因此二进制是0x8001，而不是0x0001），80 01后值00 00 00 04代表指向数据页的页号。以同样的方式，可以找到80 02和80 04这两个键值以及它们指向的数据页。</p><p>通过以上对于非数据页节点的分析，我们发现数据页上存放的是完整的行记录，而在非数据页的索引页中，存放的仅仅是键值以及指向数据页的偏移量，而不是一个完整的行记录。因此我们构造的这颗二叉树大致如图所示。</p><p><img src="https://box.kancloud.cn/052bf51b4267db01fcee3330315327a4_717x367.png" alt=""></p><p>许多数据库的文档会这样告诉读者：聚集索引按照顺序物理地存储数据。但是试想，如果聚集索引必须按照特定顺序存放物理记录的话，则维护成本即显得非常之高了。所以，聚集索引的存储并不是物理上的连续，相反是逻辑上连续的。这其中有两点：一是我们前面说过的页通过双向链表链接，页按照主键的顺序排列。另一点是每个页中的记录也是通过双向链表进行维护，物理存储上可以同样不按照主键存储。</p><p>聚集索引的另一个好处是，它对于主键的排序查找和范围查找速度非常快。叶节点的数据就是我们要查询的数据，如我们要查询一张注册用户的表，查询最后注册的10位用户，由于B+树索引是双向链表的，我们可以快速找到最后一个数据页，并取出10条记录，我们用Explain进行分析，可得：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from Profile order by id limit 10;</span><br></pre></td></tr></table></figure><p>另一个是范围查询（range query），如果要查找主键某一范围内的数据，通过叶节点的上层中间节点就可以得到页的范围，之后直接读取数据页即可，又如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from Profile where id＞10 and id＜10000;</span><br></pre></td></tr></table></figure><p>Explain得到了MySQL的执行计划（execute plan），并且rows列给出了一个查询结果的预估返回行数。要注意的是，rows代表的是一个预估值，不是确切的值，如果我们实际进行这句SQL的查询，可以看到实际上只有9 946行记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from Profile where id＞10 and id＜10000;</span><br></pre></td></tr></table></figure><h4 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h4><p>对于辅助索引（也称非聚集索引），叶级别不包含行的全部数据。叶节点除了包含键值以外，每个叶级别中的索引行中还包含了一个书签（bookmark），该书签用来告诉InnoDB存储引擎，哪里可以找到与索引相对应的行数据。因为InnoDB存储引擎表是索引组织表，因此InnoDB存储引擎的辅助索引的书签就是相应行数据的聚集索引键。显示了InnoDB存储引擎中辅助索引与聚集索引的关系。</p><p><img src="https://box.kancloud.cn/df601c6a557b2ed7a53ad0b5936493df_553x578.png" alt=""></p><p>辅助索引的存在并不影响数据在聚集索引中的组织，因此每张表上可以有多个辅助索引。当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，然后再通过主键索引来找到一个完整的行记录。举例来说，如果在一颗高度为3的辅助索引树中查找数据，那么需要对这颗辅助索引遍历3次找到指定主键；如果聚集索引树的高度同样为3，那么还需要对聚集索引进行3次查找，才能最终找到一个完整的行数据所在的页，因此一共需要6次逻辑IO来访问最终的一个数据页。</p><p>对于其他的一些数据库，如Microsoft SQL Server数据库，其表类型有一种不是索引组织表，称为堆表。在数据的存放按插入顺序方面，与MySQL的MyISAM存储引擎有些类似。堆表的特性决定了堆表上的索引都是非聚集的，但是堆表没有主键。因此这时书签是一个行标识符（row identifier，RID），可以用如“文件号：页号：槽号”的格式来定位实际的行。</p><p>堆表的非聚集索引既然不需要再通过主键对聚集索引进行查找，那不是速度会更快吗？答案是也许，在某些只读的情况下，书签为行标识符方式的非聚集索引可能会比书签为主键方式的非聚集索引快。但是考虑在OLTP（OnLine Transaction Processing，在线事务处理）应用的情况下，表可能还需要发生插入、更新、删除等DML操作。当进行这类操作时，书签为行标识符方式的非聚集索引可能需要不断更新行标识符所指向数据页的位置，这时的开销可能就会大于书签为主键方式的非聚集索引了。</p><p>Microsoft SQL Server数据库DBA问过这样的问题，为什么在SQL Server上还要使用索引组织表？堆表的书签性使得非聚集查找可以比主键书签方式更快，并且非聚集可能在一张表中存在多个，我们需要对多个非聚集索引的查找。而且对于非聚集索引的离散读取，索引组织表上的非聚集索引会比堆表上的聚集索引慢一些。当然，在一些情况下，使用堆表的确会比索引组织表更快，但是我觉得大部分是由于存在于OLAP（On-Line Analytical Processing，在线分析处理）的应用。其次就是前面提到的，表中数据是否需要更新，并且更新会否影响到物理地址的变更。此外另一个不能忽视的是对于排序和范围查找，索引组织表可以通过B+树的中间节点就找到要查找的所有页，然后进行读取，而堆表的特性决定了这对其是不能实现的。最后，非聚集索引的离散读，的确是存在上述情况，但是一般的数据库都通过实现预读（read ahead）技术来避免多次的离散读操作。因此，具体是建堆表还是索引组织表，这取决于你的应用，不存在哪个更优的情况。这和InnoDB存储引擎好还是MyISAM存储引擎好的问题是一样的，具体情况具体分析。</p><p>接下来，我们通过阅读表空间文件来分析InnoDB存储引擎的非聚集索引，我们还是分析上一小节所用的表t。</p><p>不同的是，在表t上再建立一个列c，并对列c创建非聚集索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">alter table t add c int not null;</span><br><span class="line"></span><br><span class="line">update t set c&#x3D;0-a;</span><br><span class="line"></span><br><span class="line">alter table t add key idx_c(c); </span><br><span class="line"></span><br><span class="line">show index from t;</span><br><span class="line"></span><br><span class="line">select a,c from t;</span><br></pre></td></tr></table></figure><p>然后用py_innodb_page_info工具来分析表空间，可得：py_innodb_page_info.py-v t.ibd</p><p>对比前一次我们的分析，可以看到这次多了一个页。分析page offset为4的页，该页为非聚集索引所在页，通过工具hexdump分析可得：</p><p>因为只有4行数据，并且列c只有4个字节，因此在一个非聚集索引页中即可完成，整理分析可得下图所示的关系：</p><p><img src="https://box.kancloud.cn/f8cf1eed60ff8ed1c451aa70cef3da1b_692x529.png" alt=""></p><p>显示了表t中辅助索引idx_c和聚集索引的关系。可以看到辅助索引的叶节点中包含了列c的值和主键的值。这里键值因为我特意设为负值，你会发现-1以7f ff ff ff的方式进行内部存储。7（0111）最高位为0，代表负值，实际的值应该取反后，加1，即得-1。</p><h4 id="B-树索引的管理"><a href="#B-树索引的管理" class="headerlink" title="B+树索引的管理"></a>B+树索引的管理</h4><p>索引的创建和删除可以通过两种方法，一种是ALTER TABLE，另一种是CREATE/DROP INDEX。ALTER TABLE创建索引的语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tbl_name</span><br><span class="line"></span><br><span class="line">|ADD&#123;INDEX|KEY&#125;[index_name]</span><br><span class="line"></span><br><span class="line">[index_type] (index_col_name，……) [index_option]……</span><br><span class="line"></span><br><span class="line">ALTER TABLE tbl_name</span><br><span class="line"></span><br><span class="line">DROP PRIMARY KEY</span><br><span class="line"></span><br><span class="line">|DROP &#123;INDEX|KEY&#125; index_name</span><br><span class="line"></span><br><span class="line">CREATE&#x2F;DROP INDEX的语法同样很简单：</span><br><span class="line"></span><br><span class="line">CREATE [UNIQUE] INDEX index_name</span><br><span class="line"></span><br><span class="line">[index_type]</span><br><span class="line"></span><br><span class="line">ON tbl_name（index_col_name，……）</span><br><span class="line"></span><br><span class="line">DROP INDEX index_name ON tbl_name</span><br></pre></td></tr></table></figure><p>索引可以索引整个列的数据，也可以只索引一个列的开头部分数据，如前面我们创建的表t，b列为varchar(8000)，但是我们可以只索引前100个字段，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t add key idx_b (b(100));</span><br></pre></td></tr></table></figure><p>目前MySQL数据库存在的一个普遍问题是，所有对于索引的添加或者删除操作，MySQL数据库是先创建一张新的临时表，然后把数据导入临时表，删除原表，再把临时表重名为原来的表名。因此对于一张大表，添加和删除索引需要很长的时间。对于从Microsoft SQL Server或Oracle数据库的DBA来说，MySQL数据库的索引维护始终让他们非常苦恼。</p><p>InnoDB存储引擎从版本InnoDB Plugin开始，支持一种称为快速索引创建方法。当然这种方法只限定于辅助索引，对于主键的创建和删除还是需要重建一张表。对于辅助索引的创建，InnoDB存储引擎会对表加上一个S锁。在创建的过程中，不需要重建表，因此速度极快。但是在创建的过程中，由于上了S锁，因此创建的过程中该表只能进行读操作。删除辅助索引操作就更简单了，只需在InnoDB存储引擎的内部视图更新下，将辅助索引的空间标记为可用，并删除MySQL内部视图上对于该表的索引定义即可。</p><p>查看表中索引的信息可以使用SHOW INDEX语句。如我们来分析表t，之前先加一个联合索引，可得：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table t add key idx_a_b(a,c);</span><br><span class="line">show index from t;</span><br></pre></td></tr></table></figure><p><img src="https://box.kancloud.cn/22711aeae934f7f594f2ba9c5b8a8c1a_668x214.png" alt=""></p><p>因为在表t上有3个索引：一个主键索引，c列上的索引，和b列前100个字节构成的索引。</p><p>接着我们来具体讲解每个列的含义：</p><p><strong>Table</strong>：索引所在的表名。<br><strong>Non_unique</strong>：非唯一的索引，可以看到primary key是0，因为必须是唯一的。<br><strong>Key_name</strong>：索引的名称，我们可以通过这个名称来DROP INDEX。<br><strong>Seq_in_index</strong>：索引中该列的位置，如果看联合索引idx_a_b就比较直观了。<br><strong>Column_name</strong>：索引的列<br><strong>Collation</strong>：列以什么方式存储在索引中。可以是’A’或者NULL。B+树索引总是A，即排序的。如果使用了Heap存储引擎，并且建立了Hash索引，这里就会显示NULL了。因为Hash根据Hash桶来存放索引数据，而不是对数据进行排序。<br><strong>Cardinality</strong>：非常关键的值，表示索引中唯一值的数目的估计值。Cardinality/表的行数应尽可能接近1，如果非常小，那么需要考虑是否还需要建这个索引。<br><strong>Sub_part</strong>：是否是列的部分被索引。如果看idx_b这个索引，这里显示100，表示我们只索引b列的前100个字符。如果索引整个列，则该字段为NULL。<br><strong>Packed</strong>：关键字如何被压缩。如果没有被压缩，则为NULL。<br><strong>Null</strong>：是否索引的列含有NULL值。可以看到idx_b这里为Yes。因为我们定义的b列允许NULL值。<br><strong>Index_type</strong>：索引的类型。InnoDB存储引擎只支持B+树索引，所以这里显示的都是BTREE。<br><strong>Comment</strong>：注释。<br><strong>Cardinality</strong>值非常关键，优化器会根据这个值来判断是否使用这个索引。但是这个值并不是实时更新的，并非每次索引的更新都会更新该值，因为这样代价太大了。因此这个值是不太准确的，只是一个大概的值。上面显示的结果主键的Cardinality为2，但是很显然我们表中有4条记录，这个值应该是4。如果需要更新索引Cardinality的信息，可以使用ANALYZE TABLE命令。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">analyze table t;</span><br><span class="line"></span><br><span class="line">show index from t;</span><br></pre></td></tr></table></figure><p>这时的Cardinality的值就对了。不过，在每个系统上可能得到的结果不一样，因为ANALYZE TABLE现在还存在一些问题，可能会影响得到最后的结果。</p><p>另一个问题是MySQL数据库对于Cardinality计数的问题，在运行一段时间后，可能会看到下面的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show index from Profile;</span><br></pre></td></tr></table></figure><p>Cardinality为NULL，在某些情况下可能会发生索引建立了、但是没有用到，或者explain两条基本一样的语句，但是最终出来的结果不一样。一个使用索引，另外一个使用全表扫描，这时最好的解决办法就是做一次ANALYZE TABLE的操作。因此我建议在一个非高峰时间，对应用程序下的几张核心表做ANALYZE TABLE操作，这能使优化器和索引更好地为你工作。</p><h3 id="Cardinality值"><a href="#Cardinality值" class="headerlink" title="Cardinality值"></a>Cardinality值</h3><h4 id="什么是Cardinality值"><a href="#什么是Cardinality值" class="headerlink" title="什么是Cardinality值"></a>什么是Cardinality值</h4><p>不是所有的查询条件出现的列都需要添加索引。对于什么时候添加B+树索引。一般的经验是，在访问表中很少一部分时使用B+树索引才有意义。对于性别字段、地区字段、类型字段，他们可取值范围很小，称为低选择性。如</p><p>SELECT * FROM student WHERE sex=’M’</p><p>按性别进行查询时，可取值一般只有M、F。因此SQL语句得到的结果可能是该表50%的数据(加入男女比例1:1)这时添加B+树索引是完全没有必要的。相反，如果某个字段的取值范围很广，几乎没有重复，属于高选择性。则此时使用B+树的索引是最合适的。例如对于姓名字段，基本上在一个应用中不允许重名的出现</p><p>怎样查看索引是否有高选择性？通过SHOW INDEX结果中的列Cardinality来观察。非常关键，表示所以中不重复记录的预估值，需要注意的是Cardinality是一个预估值，而不是一个准确值基本上用户也不可能得到一个准确的值，在实际应用中，Cardinality/n_row_in_table应尽可能的接近1，如果非常小,那用户需要考虑是否还有必要创建这个索引。故在访问高选择性属性的字段并从表中取出很少一部分数据时，对于字段添加B+树索引是非常有必要的。如</p><p>SELECT * FROM member WHERE usernick=’David’;</p><p>表member大约有500W行数据,usernick字段上有一个唯一索引。这是如果查找用户名为David的用户，将得到如下执行计划:</p><p><img src="https://box.kancloud.cn/9f039a02e8b70586f3ea8e6fee66efc1_783x337.png" alt=""></p><p>可以看到使用了usernick这个索引。这也符合之前提到的高可选择性，即SQL语句取表中较少行的原则。</p><h4 id="InnoDB存储引擎的Cardinality统计"><a href="#InnoDB存储引擎的Cardinality统计" class="headerlink" title="InnoDB存储引擎的Cardinality统计"></a>InnoDB存储引擎的Cardinality统计</h4><p>建立索引的前提是高选择性。这对数据库来说才具有实际意义，那么数据库是怎样统计Cardinality的信息呢?因为MySQL数据库中有各种不同的存储引擎，而每种存储引擎对于B+树索引的实现又各不相同。所以对Cardinality统计时放在存储引擎层进行的</p><p>在生成环境中，索引的更新操作可能非常频繁。如果每次索引在发生操作时就对其进行Cardinality统计，那么将会对数据库带来很大的负担。另外需要考虑的是，如果一张表的数据非常大，如一张表有50G的数据，那么统计一次Cardinality信息所需要的时间可能非常长。这样的环境下，是不能接受的。因此，数据库对于Cardinality信息的统计都是通过采样的方法完成</p><p>在InnoDB存储引擎中，Cardinality统计信息的更新发生在两个操作中：insert和update。InnoDB存储引擎内部对更新Cardinality信息的策略为:</p><p><strong><em>表中1/16的数据已发生了改变</em></strong></p><p>stat_modified_counter&gt;2000 000 000</p><p>第一种策略为自从上次统计Cardinality信息后，表中的1/16的数据已经发生过变化，这是需要更新Cardinality信息</p><p>第二种情况考虑的是，如果对表中某一行数据频繁地进行更新操作，这时表中的数据实际并没有增加，实际发生变化的还是这一行数据，则第一种更新策略就无法适用这种情况，故在InnoDB存储引擎内部有一个计数器start_modified_counter,用来表示发生变化的次数,当start_modified_counter&gt;2 000 000 000 时，则同样更新Cardinality信息</p><p>接着考虑InnoDB存储引擎内部是怎样进行Cardinality信息统计和更新操作呢？同样是通过采样的方法。默认的InnoDB存储引擎对8个叶子节点Leaf Page进行采用。采用过程如下</p><p>取得B+树索引中叶子节点的数量，记为A</p><p>随机取得B+树索引中的8个叶子节点，统计每个页不同记录的个数，即为P1，P2….P8</p><p>通过采样信息给出Cardinality的预估值: Cardinality=(P1+P2+…+P8)*A/8</p><p>根据上述的说明可以发现，在InnoDB存储引擎中，Cardinality值通过对8个叶子节点预估而得的。而不是一个实际精确的值。再者，每次对Cardinality值的统计，都是通过随机取8个叶子节点得到的，这同时有暗示了另外一个Cardinality现象，即每次得到的Cardinality值可能不同的，如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM OrderDetails</span><br></pre></td></tr></table></figure><p>上述SQL语句会触发MySQL数据库对于Cardinality值的统计，第一次运行得到的结果如图:</p><p><img src="https://box.kancloud.cn/02290ed6797f9b0bb0cf39ec178f690e_836x121.png" alt=""></p><p>在上述测试过程中，并没有通过INSERT、UPDATE这类的操作来改变OrderDetails中的内容，但是当第二次运行SHOW INDEX FROM OrderDetails语句是，发生了变化，如图:</p><p><img src="https://box.kancloud.cn/3f3035101c02738ac7297c81edf8f474_830x134.png" alt=""></p><p>可以看到，当第二次运行SHOW INDEX FROM OrderDetails语句时，表OrderDetails索引中的Cardinality值发生了变化，虽然表OrderDetails本身并没有发生任何变化，但是由于Cardinality是随机取8个叶子节点进行分析，所以即使表没有发生变化，用户观察到索引Cardinality值还是会发生变化，这本身不是Bug,而是随机采样而导致的结果</p><p>当然，有一种情况可以使得用户每次观察到的索引Cardinality值是一样的。那就是表足够小，表的叶子节点树小于或者等于8个。这时即使随机采样，也总是会采取倒这些页，因此每次得到的Cardinality值是相同的</p><p>在InnoDB1.2版本之前，可以通过innodb_stats_sample_pages用来设置统计Cardinality时每次采样页的数量，默认为8.同时，参数innodb_stats_method用来判断如何对待索引中出现NULL值记录。该参数默认值为nulls_equal,表示将NULL值记录为相等的记录。其有效值还nulls_unequal,nulls_ignored,分别表示将NULL值记录视为不同的记录和忽略NULL值记录。例如某夜中索引记录为NULL、NULL、1、2、2、3、3、3,在参数innodb_stats_method默认设置下，该页的Cardinality为4；若参数innodb_stats_method为nulls_unequal,则该页的Cardinality为5，若参数innodb_stats_method为nulls_ignored，则Cardinality值为3</p><p>当执行ANALYZE TABLE、SHOW TABLE STATUS、SHOW INDEX 以及访问INFORMATION_SCHEMA架构下的表TABLES和STATISTICS时会导致InnoDB存储引擎会重新计算索引Cardinality值，若表中的数据量非常大，并且表中存在多个辅助索引时，执行上述操作可能会非常慢，虽然用户可能并不希望去更新Cardinality值</p><p>InnoDB1.2版本提供了更多参数对Cardinality进行设置。如表:</p><p><img src="https://box.kancloud.cn/2911102ff7b234496670844748bd3919_846x451.png" alt=""></p><h3 id="B-树索引的使用"><a href="#B-树索引的使用" class="headerlink" title="B+树索引的使用"></a>B+树索引的使用</h3><p>并不是在所有的查询条件下出现的列都需要添加索引。对于什么时候添加B+树索引，我的经验是访问表中很少一部分行时，使用B+树索引才有意义。对于性别字段、地区字段、类型字段，它们可取值的范围很小，即低选择性。<br>对于性别，可取值的范围只有’M’、’F’。对上述SQL语句得到的结果可能是该表50%的数据（我们假设男女比例1：1），这时添加B+树索引是完全没有必要的。相反，如果某个字段的取值范围很广，几乎没有重复，即高选择性，则此时使用B+树索引是最适合的，例如姓名字段，基本上在一个应用中都不允许重名的出现。</p><p>因此，当访问高选择性字段并从表中取出很少一部分行时，对这个字段添加B+树索引是非常有必要的。但是如果出现了访问字段是高选择性的，但是取出的行数据占表中大部分的数据时，这时MySQL数据库就不会使用B+树索引了。</p><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>联合索引 运用的是多个索引列。 创建方法跟单个索引一样。<br>这么做的好处就是</p><ul><li>第一：是使用了B+树索引</li><li>第二：已经对第二个键值进行排序了</li></ul><p>注意：但是对于单个列查询是不引起联合索引。<br>关联查询的查询语句: select * from 表名 where id = * * * and user=  * * *</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">create table buy_log(</span><br><span class="line">userid int unsigned not null,</span><br><span class="line">    buy_date date</span><br><span class="line">)engine&#x3D;InnoDB;</span><br><span class="line"></span><br><span class="line">insert into buy_log values(1,&#39;2009-01-01&#39;);</span><br><span class="line">insert into buy_log values(2,&#39;2009-01-01&#39;);</span><br><span class="line">insert into buy_log values(3,&#39;2009-01-01&#39;);</span><br><span class="line">insert into buy_log values(1,&#39;2009-02-01&#39;);</span><br><span class="line">insert into buy_log values(3,&#39;2009-02-01&#39;);</span><br><span class="line">insert into buy_log values(1,&#39;2009-03-01&#39;);</span><br><span class="line">insert into buy_log values(1,&#39;2009-04-01&#39;);</span><br><span class="line">insert into buy_log values(1,&#39;2009-05-01&#39;);</span><br><span class="line"></span><br><span class="line">alter table buy_log add key (userid);</span><br><span class="line">alter table buy_log add key (userid,buy_date);</span><br></pre></td></tr></table></figure><p>只对userid查询:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from buy_log where userid&#x3D;2</span><br></pre></td></tr></table></figure><p><img src="https://box.kancloud.cn/d97d0dfb5412d5c8e2087d611cc41812_942x76.png" alt=""></p><p>possible_keys 说明有两个索引可以用 userid,userid_2 但是优化器选择了userid</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from buy_log where userid&#x3D;1 order by buy_date limit 3</span><br></pre></td></tr></table></figure><p><img src="https://box.kancloud.cn/155f7a727cc4a8d887744b92807bd11e_1141x90.png" alt=""></p><p>这里运用到了两个字段 所以优化器会选择userid_2 因为联合索引userid_2 已经排序好 buy_date</p><p>也可以 (a,b,c)当做联合索引但是如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from buy_log where a&#x3D;*** order by c</span><br></pre></td></tr></table></figure><p>这个情况就运行不了联合索引 因为c并不需要排序</p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>InnoDB在1.0之后 或者 MySQL 在5.0或者以下的不支持覆盖索引。 就是从辅助索引中查询的记录，而不需要查询聚集索引中的记录。 好处就是辅助索引不包含整个行记录的所有信息，骨气大小远小于聚集索引。因此可以减少大量的IO操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select count(*) from buy_log;</span><br></pre></td></tr></table></figure><p><img src="https://box.kancloud.cn/b238db7600c4433df4cead41a06b9b03_981x89.png" alt=""></p><p>Using index：表示使用索引，如果只有 Using index，说明他没有查询到数据表，只用索引表就完成了这个查询，这个叫覆盖索引。</p><p>如果同时出现Using where，代表使用索引来查找读取记录， 也是可以用到索引的，但是需要查询到数据表。</p><h4 id="优化器选择不使用索引的情况"><a href="#优化器选择不使用索引的情况" class="headerlink" title="优化器选择不使用索引的情况"></a>优化器选择不使用索引的情况</h4><p>当执行 explain命令进行sql语句分析时,就会发现优化器并没有选择索引去查找数据,而是通过扫描聚集索引,也就是直接进行全表的扫描来得到的数据。 这种情况多发生与范围查找、JOIN链接操作等情况下。<br>可以通过show index from 表名查询索引:</p><p><img src="https://box.kancloud.cn/8442efc72a4a11803041d60214dab52a_1421x266.png" alt=""></p><p>可以看出该表是有使用(OrderID,ProductID)的联合主键,此外还有OrderID的单个索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from 表名 where orderid &gt; 10000 and orderid&lt;10200;s</span><br></pre></td></tr></table></figure><p><img src="https://box.kancloud.cn/52e0c6962730c212f6a3b362514791c4_1377x130.png" alt=""></p><p>选择的是聚集索引而非辅助索引,原因是:OrderID索引不能覆盖到我们要查询的信息。虽然OrderID索引数据是顺序存放，但是再次进行书签查找数据是无序的，因此变为磁盘上离散读操作。如果要求访问的数据量小，则优化器还是会选择辅助索引，但是数据大的时候（一般20%左右），优化器会选择通过聚集索引来查找数据。因为顺序读比离散读快，但是如果是固态硬盘，随机读猜中非常快，同时自信确定使用辅助索引可以带来更好的性能 可以使用关键词 FORCE INDEX 来强制使用摸个索引,如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from 表名 force index(OrderID) where orderid &gt; 10000 and orderid&lt;10200;</span><br></pre></td></tr></table></figure><p><img src="https://box.kancloud.cn/54698ca8ce531cecebb14dc70e8f2a7e_860x143.png" alt=""></p><h4 id="Multi-Range-Read-优化"><a href="#Multi-Range-Read-优化" class="headerlink" title="Multi-Range Read 优化"></a>Multi-Range Read 优化</h4><p>MySQL5.6版本开始 支持 Multi-Range Read (MRR)优化。其目的是为了减少磁盘的随机访问，并且将随机访问转化为顺序的数据访问 这对 IO-bound类型的SQL查询语句可带来性能极大的提升。MRR适用于range，ref，eq_ref类型的查询。</p><p>MRR优化有以下几个好处：<br>（1）MRR使数据访问变得较为顺序。在查询辅助索引时，首先根据得到的查询结果，按照主键进行排序，并按照主键排序的顺序进行书签查找。<br>（2）减少缓冲池中页被替换的次数。<br>（3）批量处理对键值的查询操作。</p><p>对InnoDB和MyISAM存储引擎的范围查询和JOIN查询操作MRR工作方式如下：<br>（1）讲查询得到的辅助索引键值存放在一个缓存中，这时缓存重点数据是根据辅助索引键值排序的。<br>（2）将缓存中的键值根据RowID进行排序。<br>（3）根据RowID的排序顺序来访问实际的数据文件。<br>此外 混吃次不是足够大，不能放下一张表中的所有数据，此时离散读操作会导致缓存中的页被替换出缓冲池，然后又不断读入换冲池。若是安装主键访问，则可以将此重复行为降为最低。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where key_part1 &gt;&#x3D;1000 and key_part1 &lt;2000 and key_part2 &#x3D;10000</span><br></pre></td></tr></table></figure><p>表中 ( key_part1,key_part2)的联合索引,因此索引根据key_part1,key_part2的位置关系排序 没有 MRR查询类型为Range,sql优化器会先将key_part1大于1000 且小于2000的数据都取出,即使key_part2不等于10000。取出后进行过滤。这导致无用数据被取出。 如果启用MRR 会使其性能大大的提升。<br>优化器会将查询条件拆分为（1000,10000）（1001,10000），….，（1999,10000），最后进行数据的查询。<br>速度也是相差很大的。<br>启动方法:optimizer_switch 中的标记(flag)来控制。 总是开启MRR。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET @@optimizer_switch &#x3D; &#39;mrr&#x3D;on,mrr_cost_based&#x3D;off&#39;;</span><br></pre></td></tr></table></figure><p>read_rnd_buffer_size 用来控制键值的缓冲区大小,默认为256k;</p><p>查看命令: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @@read_rnd_buffer_size\G;</span><br></pre></td></tr></table></figure><h4 id="Index-Condition-Pushdown-ICP-优化"><a href="#Index-Condition-Pushdown-ICP-优化" class="headerlink" title="Index Condition Pushdown( ICP )优化"></a>Index Condition Pushdown( ICP )优化</h4><p>需要在MySQL5.6版本支持这种根据索引进行查询的优化方式.之前的MySQL版本不支持Index Condition Pushdown, 首先是根据索引来查找记录,然后在根据where条件来过滤记录。 在支持Index Condition Pushdown后，MySQL数据库会取出索引的同时，判断是否进行where条件的过滤，也就是将where的部分过滤操作放在存储引擎层。在某些查询下，可以大大减少上层SQL层对记录的索取（fetch），从而提高数据库的整体性能。</p><p>Index Condition Pushdown( ICP )优化支持range，ref，eq_ref，ref_or_null类型的查询。当前支持MyISAM和InnoDB存储引擎。</p><p><img src="https://box.kancloud.cn/095a7816002971c6e7bbfb68910c5e4a_889x694.png" alt=""></p><p>Extra表示附加信息，常见的有如下几种（也按查询效率从高到低排列）：<br>Using index：表示使用索引，如果只有 Using index，说明他没有查询到数据表，只用索引表就完成了这个查询，这个叫覆盖索引。如果同时出现Using where，代表使用索引来查找读取记录， 也是可以用到索引的，但是需要查询到数据表。<br>Using where：表示条件查询，如果不读取表的所有数据，或不是仅仅通过索引就可以获取所有需要的数据，则会出现 Using where。如果type列是ALL或index，而没有出现该信息，则你有可能在执行错误的查询：返回所有数据。<br>Using filesort：不是“使用文件索引”的含义！filesort是MySQL所实现的一种排序策略，通常在使用到排序语句ORDER BY的时候，会出现该信息。<br>Using temporary：表示为了得到结果，使用了临时表，这通常是出现在多表联合查询，结果排序的场合。</p><p>如果EXPLAIN出现后面两个信息（Using filesort，Using temporary），而rows又比较大，通常意味着你需要调整查询语句，或者需要添加索引，总之需要尽量消除这两个信息。</p><h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>哈希表 也称为散列表,用一个数组(即直接寻址表)T[0..m-1]表示动态集合,其中每个位置(或称槽或者桶)对应全域U中的一个关键字。图说明了这个方法k指向集合中的一个关键字为K的元素。如果集合中没有关键词k的元素 则T[k]=NULL;</p><p>元素h（k）利用哈希函数h，根据关键字k计算出槽位置。函数h将关键词域U映射到哈希T[0..m-1]的槽位上。但是两个关键词可能映射到同一个槽上。这种情况称为碰撞。链接法解决碰撞问题。</p><p><img src="https://box.kancloud.cn/eb96e30db568d22a2c90d0901e063380_602x339.png" alt=""></p><p>一般使用除法散列法：哈希函数：h（k）=k mod m；</p><p><img src="https://box.kancloud.cn/ca1c30861432f42005053893dd7aabd6_847x230.png" alt=""></p><h4 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h4><p>哈希索引只能通过 等值条件查找如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from 表名 where id_x&#x3D;1;</span><br></pre></td></tr></table></figure><p>通过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engine innodb status\G;</span><br></pre></td></tr></table></figure><p><img src="https://box.kancloud.cn/c4c3b890efa62b43f167dd97e40c9520_696x380.png" alt=""></p><p>通过参数 innodb_adaptive_hash_index来禁用和启动特性,默认为开启。</p><h3 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h3><p>全文检索(full_test search)是将存储于数据库中的整本书或者整篇文章中的任意内容信息查找出来的技术。它可以根据需要获取全文中有关的章、节、段、句等信息，也可以进行各种统计和分析。<br>InnoDB在1.2.X开始之前支持全文检索，其支持MyISAM存储引擎的全部功能，并且还支持其他的一些特性。<br>如：select * from 表名 where title like ‘中午%’; 这个语句是可以通过 B+树索引进行查询<br>如：select * from 表名 where title like ‘%中午%’; 这个就不能用B+树能够更好的工作了</p><h4 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h4><p>全文检索通常使用倒排索引（inverted index）来实现。倒排索引在辅助表（auxiliary table） 中存储了单词与单词自身在一个或者多个文档中所在位置之间的映射。利用相关数组实现，其拥有两种表现形式：<br>（1） inverted file index，其表现形式为{ 单词,单词所在的文档的ID}<br>（2）full inverted index,其表现形式为{ 单词,( 单词,单词所在的文档的位置)}</p><p><img src="https://box.kancloud.cn/dfcafde3dcbe4af20aed33c451d7a3a5_834x576.png" alt=""></p><p>对 inverted file index 其仅存文档id,而full inverted index存储的是对(pair),即(DocumentId,Position),因此存储的倒排索引如下图：</p><p><img src="https://box.kancloud.cn/d5d661bbb6a71ae614d259a2b7bbac7a_828x257.png" alt=""></p><p>full inverted index存储了单词所在的位置信息,但是同时也暂用了更多的空间,但是能更好的的定位数据。</p><h4 id="InnoDB全文检索"><a href="#InnoDB全文检索" class="headerlink" title="InnoDB全文检索"></a>InnoDB全文检索</h4><p>将(DocumentId,Position)视为一个“ilist”。因此全文检索的表中，有一个是word 字，另一个是ilist字段，并且word字段上设有索引。<br>由于Innodb 存储引擎在ilist 字段中存放了Position信息，故可以进行Proximity Search（邻近搜索），而MyISAM存储不支持改特性。</p><p>在InnoDB存储引擎中，为了提高全文检索的并行性能，共有6张Auxiliary Table（辅助表），目前每张表根据word的Latin编码进行分区<br>Auxiliary Table（辅助表）是持久表，存放磁盘上。在全文索引中，还有另一个重要的概念FTS Index Cache（全文索引索引缓存）来听全文检索的性能。<br>FTS Index Cache是一个红黑树结构，其中根据（word，ilist）进行排序。意味着插入的数据已经更新到对应的表，但是全文索引更新可能在分词操作后还在FTS Index Cache中，Auxiliary Table 可能没有更新。 InnoDB存储索引会批量对Auxiliary Table 进行更新，而不是每次插入就更新一次Auxiliary Table。当对全文检索进行查询时，Auxiliary Table首先会对FTS Index Cache 中对应的word 字段合并到Auxiliary Table中在查询. 这种合并提高了InnoDB存储引擎的性能,并且由于红黑树排序后进行批量插入,其产生Auxiliary Table相对较小。</p><p>Innodb运行用户查看置顶倒排索引的Auxiliary Table种的分词信息，可以通过参数设置innodb_ft_aux_table 来观察倒排索引的Auxiliary Table。<br>test 架构下表fts_a的Auxiliary Table;<br>set global innodb_ft_aux_table = ‘test/fts_a’;</p><p>查询test架构下的表fts_a的分词信息select * from information_schema.INNODB_FT_INDEX_TABLE;</p><p>参数innodb_ft_cache_size 控制FTS Index Cache的大小,默认值为32M。当该缓存满时，会将掐中的（word，ilist）分词信息同步到磁盘的Auxiliary Table中。增大参该参数可以提高全文检索的性能，但是在宕机时，未同步到磁盘重点索引信息可能需要更长的时间恢复。</p><p>FTS Document ID 是另一种概念。Innodb存储引擎中，为了支持全文检索，必须有一个列与word进行映射，这个列为FTS_DOS_ID，类型必须是 BIGINT UNSIGNED NOT NULL,并且Innodb引擎会加入名为FTS_DOC_ID_INDEX 的Unique Index. 上述操作是有Innodb引擎自己完成的。 用户也可以自己在建表时自动添加FTS_DOC_ID，已经对应的Unique Index。但是类型必须是 BIGINT UNSIGNED NOT NULL</p><p>文档分词的插入是事务提交时完成的，而对于删除操作，其在事务提交时，不删除磁盘Auxiliary Table重点记录,而只是删除FTS Cache index中的记录,对于Auxiliary Table中被删除的记录,FTS Document ID,并将其保存在DELETED auxiliary table中.在 innodb_ft_aux_table设置之后,可以访问information_schema价格下的表innodb_ft_deleted 中观察删除的FTS Document ID。文档的DML操作并不能删除索引中的数据，相反还会在对应的DELETED表中插入记录，因此随着应用程序的允许，索引会变得非常大，用户可以手工将已经删除的记录从索引中彻底删除，改命令是OPTIMIZE TABLE。该命令可以做其他的操作 所以可以通过参数innodb_optimize_</p><p>_onle进行设置。如:<br>set global innodb_optimize_fulltext_onlt=1;<br>optimize tablefts_a;<br>可以通过innodb_ft_num_wird_optimize 进行限制分词数量。默认为2000。</p><p>当InnoDB存储引擎的全文检索还存在以下的限制：</p><ul><li><p>（1）一个表只能有一个全文检索的索引。</p></li><li><p>（2）有多列组成的全文检索的索引列必须使用相同的字符集与排序规则。</p></li><li><p>（3）不支持没有单词界定符（delimiter） 的语言。如中文、日语、韩语等。</p></li></ul><h4 id="全文检索-1"><a href="#全文检索-1" class="headerlink" title="全文检索"></a>全文检索</h4><p>MySQL 5.6.4里才添加了InnoDB引擎的Full-Text索引支持。</p><p>设置全文搜索:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE  &#96;表名&#96; ADD FULLTEXT (</span><br><span class="line">&#96;字段名&#96;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>MySQL数据库之前全文检索(Full-Text Search)的查询，其语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MATCH (col1,col2,....) AGAINST (expr [search_modifier])</span><br><span class="line">search_modifier:</span><br><span class="line">&#123;</span><br><span class="line"> IN NATURAL LANGUAGE MODE </span><br><span class="line"> | IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION</span><br><span class="line"> | IN BOOLEAN MODE</span><br><span class="line"> |WITH QUERY EXPANSION</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MySQL 数据库通过MATCH()…AGAINST()语法支持全文检索的查询,MATCH指定了需要被查询的列,AGAINST指定了使用何种方法去进行查询。下面将对各种查询模式进行详细的介绍。</p><h5 id="Natural-Language"><a href="#Natural-Language" class="headerlink" title="Natural Language"></a>Natural Language</h5><p>全文检索沟通过MATCH函数进行查询，默认采用Natural Language模式，其表示查询带有指定word的文档。对于创建的表fts_a，查询body 字段中带有pease的文档，若不使用全文索引技术，则允许使用下述sql语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from fts_a where body like &#39;%Pease%’;</span><br></pre></td></tr></table></figure><p>显然上述sql语句不能使用B+树索引.若采用全文检索技术,可以用下面的sql语句进行查询:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from fts_a </span><br><span class="line">where match(body)</span><br><span class="line">against (&#39;Pottidge&#39; in natural language mode);</span><br></pre></td></tr></table></figure><p>默认是in natural languagemode 所以可以省略:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from cco_images where match(label) against (&#39;Romanesco&#39;);</span><br></pre></td></tr></table></figure><p>查询计划:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from cco_images where match(label) against (&#39;Romanesco&#39;);</span><br></pre></td></tr></table></figure><p>可以看到 type这列显示的是fulltext,即表示使用全文检索技术。同时，若表没有创建倒排索引，则只需match 函数会抛出类错误：Can’t find FULLTEXT index matching the column list 意思是:”找不到与列列表匹配的FULLTEXT索引”。<br>如果使用innodb搜索引擎里的mysql版本低于3.6.4时回报：the used table type doesn’t support fulltest indexes<br>翻译是：“使用的表类型不支持完整索引”</p><p>查询的范围结果是根据相关性（relevance）进行降序排序的，即相关性最高的结果放在第一位。相关性的值是一个非负的浮点数字，0表示没有任何的相关性。根据mysql官方文档可知，相关性计算根据以下四个条件：</p><ul><li>（1）word是否在文档中出现。</li><li>（2）word在文档中出现的次数。</li><li>（3）word在索引列中的数量。</li><li>（4）多少个文档包含该word。</li></ul><p><img src="https://box.kancloud.cn/d7a3190a95553023abeb14fe42e20335_826x267.png" alt=""></p><p>该查询没有经过相关性的排序 所以该查询的速度比常规的 match查询速度要快。</p><p>对于InnoDB存储引擎的全文检索，还需要考虑以下的因素：</p><ul><li>（1）查询的word在stopword列中。忽略该字符串的查询。</li><li>（2）查询的word的字符串长度是否在区间【innodb_ft_min_token_size,innodb_ft_max_token_size】内 InnoDB存储引擎中，参数innodb_ft_min_token_size默认是3，innodb_ft_max_token_size默认是84 如果不在范围内 这会忽略</li></ul><h5 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h5><p>MySQL数据库允许使用IN BOOLEAN MODE修饰符来进行全文检索。当使用该修饰符时，查询字符串的前后字符会有特殊的含义，例如下面的语句要求查询有字符串Vitaminhaltig但没有Romanesco的文档，其中+和-分别表示这个单词必须出现，或者一定不存在。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * fromselect * from cco_images where match(label) against (&#39;-Romanesco +Vitaminhaltig &#39; in boolean mode);</span><br></pre></td></tr></table></figure><p>Boolean 全文检索支持一下几种操作符:</p><p>（1）+表示该word必须存在。<br>（2）-表示该word必须被排除<br>（3）（no operator）表示该word是可选的，但是如果出现，其相关性会更高<br>（4）@distance 表示查询的多个单词之间的距离是否在distance之内，distance的单位是字节。这种全文检索的查询也称为Proximity Search。 如MATCH(label) AGAINST (‘“Pease pot”@30’ IN BOOLEAN MODE) 表示字符串Peace和pot之间的距离需在30字节以内。<br>（5）&gt;表示出现该单词时增加相关性。<br>（6）&lt;表示出现该单词时降低相关性。<br>（7）~表示允许出现该单词，但是出现是相关性为负（全文检索查询运行负相关性）。<br>（8）* 表示以该单词开头的单词，如lik*，表示可以是lik、like，又或者likes。<br>（9） “ 表示短语。</p><p>如果在against（里面添加上“”这表示该两个单词是一个短语） 如下：</p><p><img src="https://box.kancloud.cn/7987472fb2b45b36230ce3478a5050a1_689x75.png" alt=""></p><h5 id="query-Expansion"><a href="#query-Expansion" class="headerlink" title="query Expansion"></a>query Expansion</h5><p>mysql数据库支持扩展查询。 这种查询在查询的关键词太短，用户需要implied knowledge（隐含知识）时进行。<br>通过查询短句中添加with query expansion 或 in natural languange mode with query expansion 可以开启blind query expamsoin（又称 automaticrelevance feedback）。该查询分为两个阶段。</p><ul><li>（1）第一阶段 根据单词进行全文索引查询。</li><li>（2）第二阶段：根据第一阶段产生的分词再进行一次全文检索的查询。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SnowFlake算法生成全局唯一ID</title>
      <link href="/2020/02/26/%E7%AE%97%E6%B3%951/"/>
      <url>/2020/02/26/%E7%AE%97%E6%B3%951/</url>
      
        <content type="html"><![CDATA[<h2 id="SnowFlake算法生成全局唯一ID"><a href="#SnowFlake算法生成全局唯一ID" class="headerlink" title="SnowFlake算法生成全局唯一ID"></a>SnowFlake算法生成全局唯一ID</h2><p>“有这么一种说法，自然界中并不存在两片完全一样的雪花的。每一片雪花都拥有自己漂亮独特的形状、独一无二。”</p><p>有时候在等快递，想着刚买的火锅底料什么时候会到，就用那一长串的订单编号，去查询物流。在这过程中，我会想到(其实也没有)，订单编号是怎么在一个巨大的商城中保持唯一性的？</p><p>在我做一个开始制作一个订单表的时候，思考过订单编号这个问题，如果我每够买一个商品，下完单付款之后，就会在订单表写入商品信息和订单编号，那么这个时候订单的编号必定要全局唯一，想到全局唯一，那么我在前一个订单的订单编号上+1，保持这个订单编号的原子性，那不就好了？</p><p>但是也会诞生一个问题，比如你的订单编号一直都是以1、2、3、4、5、6这样的方式增长的话，那么别人也很容易猜到你当前的订单编号，而且如果把它作为一个奖券编号的话，那就很没逻辑性了。</p><p>所以，我想引入时间戳的方式，拼串，诞生一个全局唯一的ID，不过偶然间看到了Twitter上的雪花算法，便觉得很有意思，于是乎便拿来使用了。</p><h3 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h3><p>雪花算法并不复杂，它的本体是一个64bit：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mysql/sonw.jpeg" alt=""></p><h4 id="组成结构："><a href="#组成结构：" class="headerlink" title="组成结构："></a>组成结构：</h4><ul><li>1位，不用。二进制中最高位为1的都是负数，但是我们生成的id一般都使用整数，所以这个最高位固定是0</li><li>41位，用来记录时间戳（毫秒）。<ul><li>41位可以表示个数字，</li><li>如果只用来表示正整数（计算机中正数包含0），可以表示的数值范围是：0 至 ，减1是因为可表示的数值范围是从0开始算的，而不是1。</li><li>也就是说41位可以表示个毫秒的值，转化成单位年则是年</li></ul></li><li>10位，用来记录工作机器id。<ul><li>可以部署在个节点，包括5位datacenterId和5位workerId</li><li>5位（bit）可以表示的最大正整数是，即可以用0、1、2、3、….31这32个数字，来表示不同的datecenterId或workerId</li></ul></li><li>12位，序列号，用来记录同毫秒内产生的不同id。<ul><li>12位（bit）可以表示的最大正整数是，即可以用0、1、2、3、….4094这4095个数字，来表示同一机器同一时间截（毫秒)内产生的4095个ID序号</li></ul></li></ul><p>SnowFlake可以保证：</p><ul><li>所有生成的id按时间趋势递增</li><li>整个分布式系统内不会产生重复id</li></ul><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><p>标上了注释，后面会单独挑几个出来仔细说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Twitter_Snowflake</span></span><br><span class="line"><span class="comment"> * SnowFlake的结构如下(每部分用-分开):</span></span><br><span class="line"><span class="comment"> * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 &lt;br&gt;</span></span><br><span class="line"><span class="comment"> * SnowFlake的优点是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdWorker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 开始时间截 (2015-01-01) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> twepoch = <span class="number">1420041600000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 机器id所占的位数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> workerIdBits = <span class="number">5L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 数据标识id所占的位数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> datacenterIdBits = <span class="number">5L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxWorkerId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; workerIdBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 支持的最大数据标识id，结果是31 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxDatacenterId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; datacenterIdBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 序列在id中占的位数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceBits = <span class="number">12L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 机器ID向左移12位 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> workerIdShift = sequenceBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 数据标识id向左移17位(12+5) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> datacenterIdShift = sequenceBits + workerIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 时间截向左移22位(5+5+12) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceMask = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; sequenceBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 工作机器ID(0~31) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> workerId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 数据中心ID(0~31) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> datacenterId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 毫秒内序列(0~4095) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequence = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 上次生成ID的时间截 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastTimestamp = -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workerId 工作ID (0~31)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> datacenterId 数据中心ID (0~31)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IdWorker</span><span class="params">(<span class="keyword">long</span> workerId, <span class="keyword">long</span> datacenterId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"worker Id can't be greater than %d or less than 0"</span>, maxWorkerId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"datacenter Id can't be greater than %d or less than 0"</span>, maxDatacenterId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.workerId = workerId;</span><br><span class="line">        <span class="keyword">this</span>.datacenterId = datacenterId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得下一个ID (该方法是线程安全的)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> SnowflakeId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = timeGen();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    String.format(<span class="string">"Clock moved backwards.  Refusing to generate id for %d milliseconds"</span>, lastTimestamp - timestamp));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果是同一时间生成的，则进行毫秒内序列</span></span><br><span class="line">        <span class="keyword">if</span> (lastTimestamp == timestamp) &#123;</span><br><span class="line">            sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask;</span><br><span class="line">            <span class="comment">//毫秒内序列溢出</span></span><br><span class="line">            <span class="keyword">if</span> (sequence == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//阻塞到下一个毫秒,获得新的时间戳</span></span><br><span class="line">                timestamp = tilNextMillis(lastTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//时间戳改变，毫秒内序列重置</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sequence = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//上次生成ID的时间截</span></span><br><span class="line">        lastTimestamp = timestamp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//移位并通过或运算拼到一起组成64位的ID</span></span><br><span class="line">        <span class="keyword">return</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift) <span class="comment">//</span></span><br><span class="line">                | (datacenterId &lt;&lt; datacenterIdShift) <span class="comment">//</span></span><br><span class="line">                | (workerId &lt;&lt; workerIdShift) <span class="comment">//</span></span><br><span class="line">                | sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞到下一个毫秒，直到获得新的时间戳</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lastTimestamp 上次生成ID的时间截</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">tilNextMillis</span><span class="params">(<span class="keyword">long</span> lastTimestamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = timeGen();</span><br><span class="line">        <span class="keyword">while</span> (timestamp &lt;= lastTimestamp) &#123;</span><br><span class="line">            timestamp = timeGen();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> timestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回以毫秒为单位的当前时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前时间(毫秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">timeGen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码理解"><a href="#代码理解" class="headerlink" title="代码理解"></a>代码理解</h4><p>上面大部分代码都是比较易读的，但是有一些涉及到了位运算的代码，单独拿出来说说，这到底是为什么。</p><h5 id="负数的二进制"><a href="#负数的二进制" class="headerlink" title="负数的二进制"></a>负数的二进制</h5><p>在计算机中，负数的二进制是用<code>补码</code>来表示的。</p><p>假设我是用Java中的int类型来存储数字的，int类型的大小是32个二进制位（bit），即4个字节（byte）。（1 byte = 8 bit），那么十进制数字<code>3</code>在二进制中的表示应该是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span></span><br><span class="line"><span class="comment">// 3的二进制表示，就是原码</span></span><br></pre></td></tr></table></figure><p>那数字-3在二进制中应该如何表示？</p><p>我们可以反过来想想，因为-3+3=0，在二进制运算中把-3的二进制看成未知数x来求解，<br>求解算式的二进制表示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">   <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span> <span class="comment">//3，原码</span></span><br><span class="line">+  xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx <span class="comment">//-3，补码</span></span><br><span class="line">-----------------------------------------------</span><br><span class="line">   <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br></pre></td></tr></table></figure><p>反推x的值，3的二进制加上什么值才使结果变成：00000000 00000000 00000000 00000000？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span> <span class="comment">//3，原码                         </span></span><br><span class="line">+  <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111101</span> <span class="comment">//-3，补码</span></span><br><span class="line">-----------------------------------------------</span><br><span class="line"> <span class="number">1</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br></pre></td></tr></table></figure><p>反推的思路是3的二进制数从最低位开始逐位加1，使溢出的1不断向高位溢出，直到溢出到第33位。然后由于int类型最多只能保存32个二进制位，所以最高位的1溢出了，剩下的32位就成了（十进制的）0。</p><p>补码的意义就是可以拿补码和原码（3的二进制）相加，最终加出一个“溢出的0”</p><p>以上是理解的过程，实际中记住公式就很容易算出来：</p><ul><li>补码 = 反码 + 1</li><li>补码 = （原码 - 1）再取反码</li></ul><p>因此-1的二进制应该这样算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000001</span> <span class="comment">//原码：1的二进制</span></span><br><span class="line"><span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111110</span> <span class="comment">//取反码：1的二进制的反码</span></span><br><span class="line"><span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="comment">//加1：-1的二进制表示（补码）</span></span><br></pre></td></tr></table></figure><h5 id="用位运算计算n个bit能表示的最大数值"><a href="#用位运算计算n个bit能表示的最大数值" class="headerlink" title="用位运算计算n个bit能表示的最大数值"></a>用位运算计算n个bit能表示的最大数值</h5><p>比如这样一行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> workerIdBits = <span class="number">5L</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> maxWorkerId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; workerIdBits);</span><br></pre></td></tr></table></figure><p>上面代码换成这样看方便一点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> maxWorkerId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; <span class="number">5L</span>)</span><br></pre></td></tr></table></figure><p>上面那行代码中，运行顺序是：</p><ul><li>-1 左移 5，得结果a</li><li>-1 异或 a</li></ul><p>long maxWorkerId = -1L ^ (-1L &lt;&lt; 5L)的二进制运算过程如下：</p><p><strong>-1 左移 5，得结果a ：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="comment">//-1的二进制表示（补码）</span></span><br><span class="line"><span class="number">11111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11100000</span> <span class="comment">//高位溢出的不要，低位补0</span></span><br><span class="line">      <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11100000</span> <span class="comment">//结果a</span></span><br></pre></td></tr></table></figure><p><strong>-1 异或 a ：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">        <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="comment">//-1的二进制表示（补码）</span></span><br><span class="line">    ^   <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11100000</span> <span class="comment">//两个操作数的位中，相同则为0，不同则为1</span></span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">        <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00011111</span> <span class="comment">//最终结果31</span></span><br></pre></td></tr></table></figure><p>最终结果是31。</p><p>那既然现在知道算出来long maxWorkerId = -1L ^ (-1L &lt;&lt; 5L)中的maxWorkerId = 31，有什么含义？为什么要用左移5来算？如果你看过概述部分，请找到这段内容看看：</p><p>5位（bit）可以表示的最大正整数是，即可以用0、1、2、3、….31这32个数字，来表示不同的datecenterId或workerId。</p><p><strong>-1L ^ (-1L &lt;&lt; 5L)结果是31，的结果也是31，所以在代码中，-1L ^ (-1L &lt;&lt; 5L)的写法是利用位运算计算出5位能表示的最大正整数是多少</strong></p><h5 id="用mask防止溢出"><a href="#用mask防止溢出" class="headerlink" title="用mask防止溢出"></a>用mask防止溢出</h5><p>还有一段这样的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask;</span><br></pre></td></tr></table></figure><p>分别用不同的值测试一下，你就知道它怎么有趣了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> seqMask = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; <span class="number">12L</span>); <span class="comment">//计算12位能耐存储的最大正整数，相当于：2^12-1 = 4095</span></span><br><span class="line">        System.out.println(<span class="string">"seqMask: "</span>+seqMask);</span><br><span class="line">        System.out.println(<span class="number">1L</span> &amp; seqMask);</span><br><span class="line">        System.out.println(<span class="number">2L</span> &amp; seqMask);</span><br><span class="line">        System.out.println(<span class="number">3L</span> &amp; seqMask);</span><br><span class="line">        System.out.println(<span class="number">4L</span> &amp; seqMask);</span><br><span class="line">        System.out.println(<span class="number">4095L</span> &amp; seqMask);</span><br><span class="line">        System.out.println(<span class="number">4096L</span> &amp; seqMask);</span><br><span class="line">        System.out.println(<span class="number">4097L</span> &amp; seqMask);</span><br><span class="line">        System.out.println(<span class="number">4098L</span> &amp; seqMask);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        seqMask: 4095</span></span><br><span class="line"><span class="comment">        1</span></span><br><span class="line"><span class="comment">        2</span></span><br><span class="line"><span class="comment">        3</span></span><br><span class="line"><span class="comment">        4</span></span><br><span class="line"><span class="comment">        4095</span></span><br><span class="line"><span class="comment">        0</span></span><br><span class="line"><span class="comment">        1</span></span><br><span class="line"><span class="comment">        2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>这段代码通过位与运算保证计算的结果范围始终是 0-4095 ！</strong></p><p>这代表着它在一毫秒内生成ID的上限值就是4096个，如果超过这个值，则会阻塞至下一个毫秒。</p><h5 id="用位运算汇总结果"><a href="#用位运算汇总结果" class="headerlink" title="用位运算汇总结果"></a>用位运算汇总结果</h5><p>还有另外一段诡异的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift) |</span><br><span class="line">        (datacenterId &lt;&lt; datacenterIdShift) |</span><br><span class="line">        (workerId &lt;&lt; workerIdShift) |</span><br><span class="line">        sequence;</span><br></pre></td></tr></table></figure><p>为了弄清楚这段代码，首先 需要计算一下相关的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> twepoch = <span class="number">1288834974657L</span>; <span class="comment">//起始时间戳，用于用当前时间戳减去这个时间戳，算出偏移量</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> workerIdBits = <span class="number">5L</span>; <span class="comment">//workerId占用的位数：5</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> datacenterIdBits = <span class="number">5L</span>; <span class="comment">//datacenterId占用的位数：5</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> maxWorkerId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; workerIdBits);  <span class="comment">// workerId可以使用的最大数值：31</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> maxDatacenterId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; datacenterIdBits); <span class="comment">// datacenterId可以使用的最大数值：31</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> sequenceBits = <span class="number">12L</span>;<span class="comment">//序列号占用的位数：12</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> workerIdShift = sequenceBits; <span class="comment">// 12</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> datacenterIdShift = sequenceBits + workerIdBits; <span class="comment">// 12+5 = 17</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits; <span class="comment">// 12+5+5 = 22</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> sequenceMask = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; sequenceBits);<span class="comment">//4095</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> lastTimestamp = -<span class="number">1L</span>;</span><br></pre></td></tr></table></figure><p>其次 写个测试，把参数都写死，并运行打印信息，方便后面来核对计算结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">//---------------测试---------------</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> timestamp = <span class="number">1505914988849L</span>;</span><br><span class="line">    <span class="keyword">long</span> twepoch = <span class="number">1288834974657L</span>;</span><br><span class="line">    <span class="keyword">long</span> datacenterId = <span class="number">17L</span>;</span><br><span class="line">    <span class="keyword">long</span> workerId = <span class="number">25L</span>;</span><br><span class="line">    <span class="keyword">long</span> sequence = <span class="number">0L</span>;</span><br><span class="line"> </span><br><span class="line">    System.out.printf(<span class="string">"\ntimestamp: %d \n"</span>,timestamp);</span><br><span class="line">    System.out.printf(<span class="string">"twepoch: %d \n"</span>,twepoch);</span><br><span class="line">    System.out.printf(<span class="string">"datacenterId: %d \n"</span>,datacenterId);</span><br><span class="line">    System.out.printf(<span class="string">"workerId: %d \n"</span>,workerId);</span><br><span class="line">    System.out.printf(<span class="string">"sequence: %d \n"</span>,sequence);</span><br><span class="line">    System.out.println();</span><br><span class="line">    System.out.printf(<span class="string">"(timestamp - twepoch): %d \n"</span>,(timestamp - twepoch));</span><br><span class="line">    System.out.printf(<span class="string">"((timestamp - twepoch) &lt;&lt; 22L): %d \n"</span>,((timestamp - twepoch) &lt;&lt; <span class="number">22L</span>));</span><br><span class="line">    System.out.printf(<span class="string">"(datacenterId &lt;&lt; 17L): %d \n"</span> ,(datacenterId &lt;&lt; <span class="number">17L</span>));</span><br><span class="line">    System.out.printf(<span class="string">"(workerId &lt;&lt; 12L): %d \n"</span>,(workerId &lt;&lt; <span class="number">12L</span>));</span><br><span class="line">    System.out.printf(<span class="string">"sequence: %d \n"</span>,sequence);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">long</span> result = ((timestamp - twepoch) &lt;&lt; <span class="number">22L</span>) |</span><br><span class="line">            (datacenterId &lt;&lt; <span class="number">17L</span>) |</span><br><span class="line">            (workerId &lt;&lt; <span class="number">12L</span>) |</span><br><span class="line">            sequence;</span><br><span class="line">    System.out.println(result);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** 打印信息：</span></span><br><span class="line"><span class="comment">    timestamp: 1505914988849 </span></span><br><span class="line"><span class="comment">    twepoch: 1288834974657 </span></span><br><span class="line"><span class="comment">    datacenterId: 17 </span></span><br><span class="line"><span class="comment">    workerId: 25 </span></span><br><span class="line"><span class="comment">    sequence: 0 </span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    (timestamp - twepoch): 217080014192 </span></span><br><span class="line"><span class="comment">    ((timestamp - twepoch) &lt;&lt; 22L): 910499571845562368 </span></span><br><span class="line"><span class="comment">    (datacenterId &lt;&lt; 17L): 2228224 </span></span><br><span class="line"><span class="comment">    (workerId &lt;&lt; 12L): 102400 </span></span><br><span class="line"><span class="comment">    sequence: 0 </span></span><br><span class="line"><span class="comment">    910499571847892992</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>代入位移的值得之后，就是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> ((timestamp - <span class="number">1288834974657</span>) &lt;&lt; <span class="number">22</span>) |</span><br><span class="line">        (datacenterId &lt;&lt; <span class="number">17</span>) |</span><br><span class="line">        (workerId &lt;&lt; <span class="number">12</span>) |</span><br><span class="line">        sequence;</span><br></pre></td></tr></table></figure><p>对于尚未知道的值，我们可以先看看概述 中对SnowFlake结构的解释，再代入在合法范围的值，来了解计算的过程。</p><p>当然，由于我的测试代码已经把这些值写死了，那直接用这些值来手工验证计算结果即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> timestamp = <span class="number">1505914988849L</span>;</span><br><span class="line"><span class="keyword">long</span> twepoch = <span class="number">1288834974657L</span>;</span><br><span class="line"><span class="keyword">long</span> datacenterId = <span class="number">17L</span>;</span><br><span class="line"><span class="keyword">long</span> workerId = <span class="number">25L</span>;</span><br><span class="line"><span class="keyword">long</span> sequence = <span class="number">0L</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">设：timestamp  = <span class="number">1505914988849</span>，twepoch = <span class="number">1288834974657</span></span><br><span class="line"><span class="number">1505914988849</span> - <span class="number">1288834974657</span> = <span class="number">217080014192</span> (timestamp相对于起始时间的毫秒偏移量)，其(a)二进制左移<span class="number">22</span>位计算过程如下：                                </span><br><span class="line"> </span><br><span class="line">                        |&lt;--这里开始左右<span class="number">22</span>位                            ‭</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">000000</span>|<span class="number">00</span> <span class="number">00110010</span> <span class="number">10001010</span> <span class="number">11111010</span> <span class="number">00100101</span> <span class="number">01110000</span> <span class="comment">// a = 217080014192</span></span><br><span class="line"><span class="number">00001100</span> <span class="number">10100010</span> <span class="number">10111110</span> <span class="number">10001001</span> <span class="number">01011100</span> <span class="number">00</span>|<span class="number">000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="comment">// a左移22位后的值(la)</span></span><br><span class="line">                                               |&lt;--这里后面的位补<span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">设：datacenterId  = <span class="number">17</span>，其（b）二进制左移<span class="number">17</span>位计算过程如下：</span><br><span class="line"> </span><br><span class="line">                   |&lt;--这里开始左移<span class="number">17</span>位    </span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">0</span>|<span class="number">0000000</span> ‭<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00010001</span> <span class="comment">// b = 17</span></span><br><span class="line"><span class="number">0000000</span>‭<span class="number">0</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">0010001</span>|<span class="number">0</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="comment">// b左移17位后的值(lb)</span></span><br><span class="line">                                                    |&lt;--这里后面的位补<span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">设：workerId  = <span class="number">25</span>，其（c）二进制左移<span class="number">12</span>位计算过程如下：</span><br><span class="line"> </span><br><span class="line">             |&lt;--这里开始左移<span class="number">12</span>位    </span><br><span class="line">‭<span class="number">00000000</span> <span class="number">0000</span>|<span class="number">0000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00011001</span>‬ <span class="comment">// c = 25</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000001</span> <span class="number">1001</span>|<span class="number">0000</span> <span class="number">00000000</span>‬ <span class="comment">// c左移12位后的值(lc)                                                                 </span></span><br><span class="line">                                                          |&lt;--这里后面的位补<span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">设：sequence = <span class="number">0</span>，其二进制如下：</span><br><span class="line"> </span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">0000</span>‭<span class="number">0000</span> <span class="number">00000000</span>‬ <span class="comment">// sequence = 0</span></span><br></pre></td></tr></table></figure><p>现在知道了每个部分左移后的值(la,lb,lc)，代码可以简化成下面这样去理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> ((timestamp - <span class="number">1288834974657</span>) &lt;&lt; <span class="number">22</span>) |</span><br><span class="line">        (datacenterId &lt;&lt; <span class="number">17</span>) |</span><br><span class="line">        (workerId &lt;&lt; <span class="number">12</span>) |</span><br><span class="line">        sequence;</span><br><span class="line">-----------------------------</span><br><span class="line">           |</span><br><span class="line">           |简化</span><br><span class="line">          \|/</span><br><span class="line">-----------------------------</span><br><span class="line"><span class="keyword">return</span> (la) |</span><br><span class="line">        (lb) |</span><br><span class="line">        (lc) |</span><br><span class="line">        sequence;</span><br></pre></td></tr></table></figure><p>上面的管道符号 <strong>|</strong> 在Java中也是一个位运算符。其含义是：</p><p><strong>x的第n位和y的第n位 只要有一个是1，则结果的第n位也为1，否则为0，因此，我们对四个数的位或运算如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>  |                    <span class="number">41</span>                        |  <span class="number">5</span>  |   <span class="number">5</span>  |     <span class="number">12</span>      </span><br><span class="line">    </span><br><span class="line">   <span class="number">0</span>|<span class="number">0001100</span> <span class="number">10100010</span> <span class="number">10111110</span> <span class="number">10001001</span> <span class="number">01011100</span> <span class="number">00</span>|<span class="number">00000</span>|<span class="number">0</span> <span class="number">0000</span>|<span class="number">0000</span> <span class="number">00000000</span> <span class="comment">//la</span></span><br><span class="line">   <span class="number">0</span>|<span class="number">000000</span>‭<span class="number">0</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00</span>|<span class="number">10001</span>|<span class="number">0</span> <span class="number">0000</span>|<span class="number">0000</span> <span class="number">00000000</span> <span class="comment">//lb</span></span><br><span class="line">   <span class="number">0</span>|<span class="number">0000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00</span>|<span class="number">00000</span>|<span class="number">1</span> <span class="number">1001</span>|<span class="number">0000</span> <span class="number">00000000</span> <span class="comment">//lc</span></span><br><span class="line">or <span class="number">0</span>|<span class="number">0000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00</span>|<span class="number">00000</span>|<span class="number">0</span> <span class="number">0000</span>|‭<span class="number">0000</span> <span class="number">00000000</span>‬ <span class="comment">//sequence</span></span><br><span class="line">------------------------------------------------------------------------------------------</span><br><span class="line">   <span class="number">0</span>|<span class="number">0001100</span> <span class="number">10100010</span> <span class="number">10111110</span> <span class="number">10001001</span> <span class="number">01011100</span> <span class="number">00</span>|<span class="number">10001</span>|<span class="number">1</span> <span class="number">1001</span>|‭<span class="number">0000</span> <span class="number">00000000</span>‬ <span class="comment">//结果：910499571847892992</span></span><br></pre></td></tr></table></figure><p>结果计算过程：</p><p>1) 从至左列出1出现的下标（从0开始算）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>  <span class="number">1</span>   <span class="number">1</span>   <span class="number">00</span>  <span class="number">1</span>   <span class="number">0</span>  <span class="number">1</span>  <span class="number">000</span>  <span class="number">1</span>   <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">0</span> <span class="number">1</span>   <span class="number">000</span> <span class="number">1</span> <span class="number">00</span> <span class="number">1</span>  <span class="number">0</span> <span class="number">1</span>  <span class="number">0</span>   <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">0000</span> <span class="number">1</span>   <span class="number">000</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">00</span>  <span class="number">1</span>‭   <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line">      <span class="number">59</span>  <span class="number">58</span>      <span class="number">55</span>     <span class="number">53</span>      <span class="number">49</span>     <span class="number">47</span>    <span class="number">45</span> <span class="number">44</span> <span class="number">43</span> <span class="number">42</span> <span class="number">41</span>   <span class="number">39</span>      <span class="number">35</span>   <span class="number">32</span>   <span class="number">30</span>     <span class="number">28</span> <span class="number">27</span> <span class="number">26</span>      <span class="number">21</span>       <span class="number">17</span> <span class="number">16</span> <span class="number">15</span>     <span class="number">12</span></span><br></pre></td></tr></table></figure><p>2) 各个下标作为2的幂数来计算，并相加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">2</span>^<span class="number">59</span>&#125;  : <span class="number">576460752303423488</span></span><br><span class="line">    <span class="number">2</span>^<span class="number">58</span>&#125;  : <span class="number">288230376151711744</span>   </span><br><span class="line">    <span class="number">2</span>^<span class="number">55</span>&#125;  :  <span class="number">36028797018963968</span>    </span><br><span class="line">    <span class="number">2</span>^<span class="number">53</span>&#125;  :   <span class="number">9007199254740992</span>     </span><br><span class="line">    <span class="number">2</span>^<span class="number">49</span>&#125;  :    <span class="number">562949953421312</span>      </span><br><span class="line">    <span class="number">2</span>^<span class="number">47</span>&#125;  :    <span class="number">140737488355328</span></span><br><span class="line">    <span class="number">2</span>^<span class="number">45</span>&#125;  :     <span class="number">35184372088832</span></span><br><span class="line">    <span class="number">2</span>^<span class="number">44</span>&#125;  :     <span class="number">17592186044416</span></span><br><span class="line">    <span class="number">2</span>^<span class="number">43</span>&#125;  :      <span class="number">8796093022208</span></span><br><span class="line">    <span class="number">2</span>^<span class="number">42</span>&#125;  :      <span class="number">4398046511104</span></span><br><span class="line">    <span class="number">2</span>^<span class="number">41</span>&#125;  :      <span class="number">2199023255552</span></span><br><span class="line">    <span class="number">2</span>^<span class="number">39</span>&#125;  :       <span class="number">549755813888</span></span><br><span class="line">    <span class="number">2</span>^<span class="number">35</span>&#125;  :        <span class="number">34359738368</span></span><br><span class="line">    <span class="number">2</span>^<span class="number">32</span>&#125;  :         <span class="number">4294967296</span></span><br><span class="line">    <span class="number">2</span>^<span class="number">30</span>&#125;  :         <span class="number">1073741824</span></span><br><span class="line">    <span class="number">2</span>^<span class="number">28</span>&#125;  :          <span class="number">268435456</span></span><br><span class="line">    <span class="number">2</span>^<span class="number">27</span>&#125;  :          <span class="number">134217728</span></span><br><span class="line">    <span class="number">2</span>^<span class="number">26</span>&#125;  :           <span class="number">67108864</span></span><br><span class="line">    <span class="number">2</span>^<span class="number">21</span>&#125;  :            <span class="number">2097152</span></span><br><span class="line">    <span class="number">2</span>^<span class="number">17</span>&#125;  :             <span class="number">131072</span></span><br><span class="line">    <span class="number">2</span>^<span class="number">16</span>&#125;  :              <span class="number">65536</span></span><br><span class="line">    <span class="number">2</span>^<span class="number">15</span>&#125;  :              <span class="number">32768</span></span><br><span class="line">+   <span class="number">2</span>^<span class="number">12</span>&#125;  :               <span class="number">4096</span></span><br><span class="line">---------------------------------------- </span><br><span class="line">             <span class="number">910499571847892992</span></span><br></pre></td></tr></table></figure><p><strong>观察</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>  |                    <span class="number">41</span>                        |  <span class="number">5</span>  |   <span class="number">5</span>  |     <span class="number">12</span>      </span><br><span class="line">    </span><br><span class="line">   <span class="number">0</span>|<span class="number">0001100</span> <span class="number">10100010</span> <span class="number">10111110</span> <span class="number">10001001</span> <span class="number">01011100</span> <span class="number">00</span>|     |      |              <span class="comment">//la</span></span><br><span class="line">   <span class="number">0</span>|                                              |<span class="number">10001</span>|      |              <span class="comment">//lb</span></span><br><span class="line">   <span class="number">0</span>|                                              |     |<span class="number">1</span> <span class="number">1001</span>|              <span class="comment">//lc</span></span><br><span class="line">or <span class="number">0</span>|                                              |     |      |‭<span class="number">0000</span> <span class="number">00000000</span>‬ <span class="comment">//sequence</span></span><br><span class="line">------------------------------------------------------------------------------------------</span><br><span class="line">   <span class="number">0</span>|<span class="number">0001100</span> <span class="number">10100010</span> <span class="number">10111110</span> <span class="number">10001001</span> <span class="number">01011100</span> <span class="number">00</span>|<span class="number">10001</span>|<span class="number">1</span> <span class="number">1001</span>|‭<span class="number">0000</span> <span class="number">00000000</span>‬ <span class="comment">//结果：910499571847892992</span></span><br></pre></td></tr></table></figure><p>上面的64位我按1、41、5、5、12的位数截开了，方便观察。</p><ul><li>纵向观察发现:<ul><li>在41位那一段，除了la一行有值，其它行（lb、lc、sequence）都是0，（我爸其它）</li><li>在左起第一个5位那一段，除了lb一行有值，其它行都是0</li><li>在左起第二个5位那一段，除了lc一行有值，其它行都是0</li><li>按照这规律，如果sequence是0以外的其它值，12位那段也会有值的，其它行都是0</li></ul></li><li>横向观察发现:<ul><li>在la行，由于左移了5+5+12位，5、5、12这三段都补0了，所以la行除了41那段外，其它肯定都是0</li><li>同理，lb、lc、sequnece行也以此类推</li><li>正因为左移的操作，使四个不同的值移到了SnowFlake理论上相应的位置，然后四行做 位或 运算（只要有1结果就是1），就把4段的二进制数合并成一个二进制数。</li></ul></li></ul><p>左移运算是为了将数值移动到对应的段(41、5、5，12那段因为本来就在最右，因此不用左移)。</p><p>然后对每个左移后的值(la、lb、lc、sequence)做位或运算，是为了把各个短的数据合并起来，合并成一个二进制数。</p><p>最后转换成10进制，就是最终生成的id</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现SpringBoot上传图片到七牛云</title>
      <link href="/2020/02/22/spring14/"/>
      <url>/2020/02/22/spring14/</url>
      
        <content type="html"><![CDATA[<h2 id="实现SpringBoot上传图片到七牛云"><a href="#实现SpringBoot上传图片到七牛云" class="headerlink" title="实现SpringBoot上传图片到七牛云"></a>实现SpringBoot上传图片到七牛云</h2><p>这是最近在制作项目的时候遇到的一个问题，这个项目是一个商城，我在对图片进行处理的时候，一般是把图片转化为Byte，再存入数据库的。步骤和方法都没错，但是考虑到我在阿里云租借的ECS云服务器硬盘大小只有40G，对之后的图片，可能出现容量不足的情况。</p><p>而且对一个只有2G内存的服务器，大量的对图片进行IO处理，恐怕会使得服务器效率低下，所以，便想到了，在存储图片的时候，直接上传到七牛云，并生成一个随机ID来代表图片的名称，之后读取的之后，只需要在数据库读到到这个ID值，并在页面实现拼串，就能够将图片显示出来了。</p><p>所以我们来实验一下：</p><h3 id="基础准备"><a href="#基础准备" class="headerlink" title="基础准备"></a>基础准备</h3><p>这里我直接选取了官网提供的依赖：</p><h4 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--七牛配置依赖--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 七牛云 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qiniu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>qiniu-java-sdk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>[7.2.0, 7.2.99]<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.squareup.okhttp3<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.14.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qiniu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>happy-dns-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后需要进行设置，获取到七牛云的外链和密钥：</p><h4 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">qiniu:</span><br><span class="line">  accessKey: xxxxxxxxxxxxxxx</span><br><span class="line">  secretKey: xxxxxxxxxxxxxx</span><br><span class="line">  bucket: imgof</span><br><span class="line">  prefix: www-xxxxxxxxx.com</span><br></pre></td></tr></table></figure><p>虽然我们在写入的时候 它会提示了 cannot configuration。。。，但是不用理他，那是因为这个依赖并不归属于Spring管理。</p><p>但是我们仍然需要将其加入容器中：</p><h4 id="QiniuProperties"><a href="#QiniuProperties" class="headerlink" title="QiniuProperties"></a>QiniuProperties</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"qiniu"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QiniuProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String accessKey;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String secretKey;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String bucket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String prefix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个加入了以后，上方可能会提示你不能找到classpath，但是也不用管它。</p><p>因为我们使用的是yml，而不是properties，所以这个并不是报错。</p><p>但是配置还没有完，我们仅仅是定义了七牛云的连接属性，还需要对其连接的各个方式进行配置：</p><h4 id="QiniuFileConfig"><a href="#QiniuFileConfig" class="headerlink" title="QiniuFileConfig"></a>QiniuFileConfig</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(QiniuProperties<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">QiniuFileConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> QiniuProperties qiniuProperties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 华南机房,配置自己空间所在的区域</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> com.qiniu.storage.<span class="function">Configuration <span class="title">qiniuConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> com.qiniu.storage.Configuration(Zone.zone2());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建一个七牛上传工具实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UploadManager <span class="title">uploadManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UploadManager(qiniuConfig());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证信息实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Auth <span class="title">auth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Auth.create(qiniuProperties.getAccessKey(), qiniuProperties.getSecretKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建七牛空间管理实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BucketManager <span class="title">bucketManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BucketManager(auth(), qiniuConfig());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Gson <span class="title">gson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Gson();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这段代码并没有特别需要深究的地方，注意定义好自己的机房位置就行了，比如：华东是Z0，华北是Z1。</p><p>以上的基础配置可以通过复制粘贴的方式引入，并没有过多的定制化操作。</p><h3 id="服务实现"><a href="#服务实现" class="headerlink" title="服务实现"></a>服务实现</h3><p>之后，就是我们把这些服务实现的时候了，首先需要一个接口：</p><h4 id="QiniuService"><a href="#QiniuService" class="headerlink" title="QiniuService"></a>QiniuService</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">QiniuService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">uploadFile</span><span class="params">(File file)</span> <span class="keyword">throws</span> QiniuException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">uploadFile</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> QiniuException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Response <span class="title">delete</span><span class="params">(String key)</span> <span class="keyword">throws</span> QiniuException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了上传和删除。</p><p>之后便是服务的实现，也是最重要的内容：</p><h4 id="QiniuServiceImpl"><a href="#QiniuServiceImpl" class="headerlink" title="QiniuServiceImpl"></a>QiniuServiceImpl</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(QiniuProperties<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">QiniuServiceImpl</span> <span class="keyword">implements</span> <span class="title">QiniuService</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> QiniuProperties qiniuProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UploadManager uploadManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BucketManager bucketManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Auth auth;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义七牛云上传的相关策略</span></span><br><span class="line">    <span class="keyword">private</span> StringMap putPolicy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以文件的形式上传</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> QiniuException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">uploadFile</span><span class="params">(File file)</span> <span class="keyword">throws</span> QiniuException </span>&#123;</span><br><span class="line">        Response response = <span class="keyword">this</span>.uploadManager.put(file, <span class="keyword">null</span>, getUploadToken());</span><br><span class="line">        <span class="keyword">int</span> retry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (response.needRetry() &amp;&amp; retry &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            response = <span class="keyword">this</span>.uploadManager.put(file, <span class="keyword">null</span>, getUploadToken());</span><br><span class="line">            retry++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解析结果</span></span><br><span class="line">        DefaultPutRet putRet = JSON.parseObject(response.bodyString(), DefaultPutRet<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        String return_path = qiniuProperties.getPrefix() + <span class="string">"/"</span> + putRet.key;</span><br><span class="line">        log.info(<span class="string">"文件名称=&#123;&#125;"</span>, return_path);</span><br><span class="line">        <span class="keyword">return</span> return_path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以流的形式上传</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> QiniuException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">uploadFile</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> QiniuException </span>&#123;</span><br><span class="line">        Response response = <span class="keyword">this</span>.uploadManager.put(inputStream, <span class="keyword">null</span>, getUploadToken(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">int</span> retry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (response.needRetry() &amp;&amp; retry &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            response = <span class="keyword">this</span>.uploadManager.put(inputStream, <span class="keyword">null</span>, getUploadToken(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            retry++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解析结果</span></span><br><span class="line">        DefaultPutRet putRet = JSON.parseObject(response.bodyString(), DefaultPutRet<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        String return_path = qiniuProperties.getPrefix() + <span class="string">"/"</span> + putRet.key;</span><br><span class="line">        log.info(<span class="string">"文件名称=&#123;&#125;"</span>, return_path);</span><br><span class="line">        System.out.println(return_path);</span><br><span class="line">        <span class="keyword">return</span> return_path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除七牛云上的相关文件</span></span><br><span class="line"><span class="comment">     * incompatible</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> QiniuException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">delete</span><span class="params">(String key)</span> <span class="keyword">throws</span> QiniuException </span>&#123;</span><br><span class="line">        Response response = bucketManager.delete(qiniuProperties.getBucket(), key);</span><br><span class="line">        <span class="keyword">int</span> retry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (response.needRetry() &amp;&amp; retry++ &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            response = bucketManager.delete(qiniuProperties.getBucket(), key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.putPolicy = <span class="keyword">new</span> StringMap();</span><br><span class="line">        putPolicy.put(<span class="string">"returnBody"</span>, <span class="string">"&#123;\"key\":\"$(key)\",\"hash\":\"$(etag)\",\"bucket\":\"$(bucket)\",\"width\":$(imageInfo.width), \"height\":$&#123;imageInfo.height&#125;&#125;"</span>);</span><br><span class="line">        <span class="comment">// 自定义文件名字</span></span><br><span class="line"><span class="comment">//        putPolicy.put("saveKey", "qqqqq");</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取上传凭证</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getUploadToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.auth.uploadToken(qiniuProperties.getBucket(), <span class="keyword">null</span>, <span class="number">3600</span>, putPolicy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码比较长，我们就挑选出最为重要的一部分来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">uploadFile</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> QiniuException </span>&#123;</span><br><span class="line">    Response response = <span class="keyword">this</span>.uploadManager.put(inputStream, <span class="keyword">null</span>, getUploadToken(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">int</span> retry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (response.needRetry() &amp;&amp; retry &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        response = <span class="keyword">this</span>.uploadManager.put(inputStream, <span class="keyword">null</span>, getUploadToken(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        retry++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//解析结果</span></span><br><span class="line">    DefaultPutRet putRet = JSON.parseObject(response.bodyString(), DefaultPutRet<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    String return_path = qiniuProperties.getPrefix() + <span class="string">"/"</span> + putRet.key;</span><br><span class="line">    log.info(<span class="string">"文件名称=&#123;&#125;"</span>, return_path);</span><br><span class="line">    System.out.println(return_path);</span><br><span class="line">    <span class="keyword">return</span> return_path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如这个方法，以流的形式上传。我们会获取到一个文件的流，然后在调用七牛云的API，即uploadManager.put，将其上传到七牛云服务器。</p><p>至于那个retry和while，仅仅是为了防止上传失败的进行的重试而已，如果上传失败超过三次，则取消上传，删除也是如此。</p><p>之后的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DefaultPutRet putRet = JSON.parseObject(response.bodyString(), DefaultPutRet<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><p>便是返回对图片上传的解析结果，解析结果里面包含了图片的名字，图片的上传的路径等等。</p><p>可能你会问，我将文件以流的形式上传了，但是在这个过程中，我并没有定义文件的名字啊？</p><p>对了，这里有一个误区就是上传的文件名字，就一定等于自己的文件名字，这个其实是错误的，如果你有两个口味相同，版本不同的奥利奥，该怎么办呢？那就拼串一个版本号，但是版本相同，口味不同的呢？难道你要不停的拼串吗？</p><p>那么说起来，上传的文件名字到底是什么呢？</p><p>这里还有一行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.putPolicy = <span class="keyword">new</span> StringMap();</span><br><span class="line">        putPolicy.put(<span class="string">"returnBody"</span>, <span class="string">"&#123;\"key\":\"$(key)\",\"hash\":\"$(etag)\",\"bucket\":\"$(bucket)\",\"width\":$(imageInfo.width), \"height\":$&#123;imageInfo.height&#125;&#125;"</span>);</span><br><span class="line">        <span class="comment">// 自定义文件名字</span></span><br><span class="line"><span class="comment">//        putPolicy.put("saveKey", "？？？");</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们发现这个afterPropertiesSet是一个重写的方法，而这个方法来自于接口InitializingBean。</p><p><strong>这个方法将在所有的属性被初始化后调用，但是会在init前调用。</strong></p><p>也就是说，在这个类中，通过这个方法来构造Bean容器，而我们的上传的文件，会自动执行初始化，对上传的图片进行定制，可以在定义图片的时候，使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">putPolicy.put(<span class="string">"saveKey"</span>, <span class="string">"？？？"</span>);</span><br></pre></td></tr></table></figure><p>去定义图片的名字，而这个？？？可以是一个生成全局唯一ID的生成器。这样保证了图片的连接唯一性，保证不同图片的共存而不会覆盖。</p><p>而之后返回的图片地址，在存入数据就行了。</p><p>那么返回的图片地址怎么处理呢？那就归控制器管理了。</p><h4 id="QiniuController"><a href="#QiniuController" class="headerlink" title="QiniuController"></a>QiniuController</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/qiniu"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QiniuController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> QiniuService qiniuService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以流的形式上传图片</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回访问路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"upload"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">uploadFile</span><span class="params">(@RequestParam(value = <span class="string">"file"</span>)</span> MultipartFile file) <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> qiniuService.uploadFile(file.getInputStream());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"delete/&#123;key&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">deleteFile</span><span class="params">(@PathVariable String key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> qiniuService.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就完成了，可以自制一个页面进行测试哦。这里就不演示了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 七牛云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC详解（四）</title>
      <link href="/2020/02/18/spring13/"/>
      <url>/2020/02/18/spring13/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringMVC详解（四）"><a href="#SpringMVC详解（四）" class="headerlink" title="SpringMVC详解（四）"></a>SpringMVC详解（四）</h2><h3 id="视图和视图解析器"><a href="#视图和视图解析器" class="headerlink" title="视图和视图解析器"></a>视图和视图解析器</h3><p>视图是渲染数据模型展示给用户的组件，在SpringMVC中又分为逻辑视图和非逻辑视图。逻辑图是需要视图解析器（ViewResolver）进行进一步定位的。</p><p>现在我们来看看视图是如何设计和使用的。</p><h4 id="视图设计"><a href="#视图设计" class="headerlink" title="视图设计"></a>视图设计</h4><p>视图的类型有很多，比如前面的HTML页面就是最为经典的视图，但是也有很多其他的视图，比如JSON视图，JSP视图，当然不止仅有网络视图，连Excel、PDF也算作为一种视图。</p><p>视图都会现实SpringMVC中的View接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">View</span></span>&#123;</span><br><span class="line">    <span class="comment">//响应状态属性</span></span><br><span class="line">    String RESPONSE_STATUS_ATTRIBUTE =View<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()+”.<span class="title">responseStatus</span>”</span>; </span><br><span class="line">    <span class="comment">//路径变盘</span></span><br><span class="line">    String PATH_VARIABLES=View<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()+”.<span class="title">pathVariables</span>”</span>;</span><br><span class="line">    <span class="comment">//选择内容类型</span></span><br><span class="line">    String SELECTED_CONTENT_TYPE=View<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()+”.<span class="title">selectedContentType</span>”</span>;</span><br><span class="line">    <span class="comment">//响应类型</span></span><br><span class="line">    <span class="function">String <span class="title">getContentType</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//渲染方法</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">render</span><span class="params">(Map&lt;String,?&gt;model,HttpServletRequest request,HttpServletResponse response)</span><span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure><p>这段代码中有两个方法，其中getContentType方法是获取HTTP响应类型的，它可以返回的类型是文本、JSON数据集或者文件等，而rend巳r方法则是将数据模型渲染到视图的，这是视图的核心方法，所以有必要进一步地讨论它。</p><p>在它的参数中，model是数据模型，实际就是从控制器（或者由处理器自动绑定）返回的数据模型，这样render方法就可以把它渲染出来。</p><p>渲染视图是比较复杂的过程，为了简化视图渲染的开发，在SpringMVC中已经给开发者提供了许多开发好的视图类，所以在大部分的情况下并不需要自己开发自己的视图。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/images/4.png" alt=""></p><p>如图所示，SpringMVC中己经开发好了各种各样的视图，所以在大部分情况下，只需要定义如何将数据模型渲染到视图中展示给用户即可。</p><p>例如，之前看到的MappingJackson2JsonView视图，因为它不是逻辑视图，所以并不需要使用视图解析器（ViewResolver）去定位视图，它会将数据模型渲染为JSON数据集展示给用户查看；而常用的视图JstlView，则是一个逻辑视图，于是可以在控制器返回一个字符串，使用视图解析器去定位对应的JSP文件，就能够找到对应的JSP文件，将数据模型传递进入，Jst!View就会将数据模型渲染，展示数据给用户。对于PDF和Excel视图等类型的视图，它们只需要接收数据模型，然后通过自定义的渲染即可。为了说明视图的使用方法，下面将介绍如何使用PDF视图——AbstractPdtView。</p><h4 id="视图实例——导出PDF文件"><a href="#视图实例——导出PDF文件" class="headerlink" title="视图实例——导出PDF文件"></a>视图实例——导出PDF文件</h4><p>可以从字面意思上看出，AbstractPdtView是一个抽象类，而且，AbstractPdtView属于非逻辑视图，因此它不需要任何的视图解析器去定位。我们先来看看这个</p><h5 id="AbstractPdtView的源码的抽象方法："><a href="#AbstractPdtView的源码的抽象方法：" class="headerlink" title="AbstractPdtView的源码的抽象方法："></a>AbstractPdtView的源码的抽象方法：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*通过数据模型自定义创建PDF文档女</span></span><br><span class="line"><span class="comment">＠param model数据模型</span></span><br><span class="line"><span class="comment">@param document iText Document代表一个PDF文档</span></span><br><span class="line"><span class="comment">@param writer PdfWriter PDF写入器</span></span><br><span class="line"><span class="comment">＠param request HttpServletRequest请求对象</span></span><br><span class="line"><span class="comment">@param response HttpServletResponse响应对象</span></span><br><span class="line"><span class="comment">@throws Exception异常*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPdfDocument</span><span class="params">(Map&lt;String,Object&gt; model,Document document,PdfWriter writer,HttpServletRequest request,HttpServletResponse response)</span><span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure><p>通过PDF视图的定义，就只需要实现这个抽象方法便可以将数据模型渲染为PDF。而这个方法中的参数，包含数据模型（model）对象、HTTP的请求（request）和响应（response）对象，通过这就可以得到数据模型和上下文环境的参数，此外方法中还有与PDF文档有关的参数（document和writer），通过它们就可以制PDF的格和数据的渲染。</p><h5 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h5><p>当然也需要加入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--        PDF--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.xhtmlrenderer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>core-renderer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>R8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itextpdf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>itextpdf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后便可以开始程序设计了</p><h5 id="定义PDF导出接口"><a href="#定义PDF导出接口" class="headerlink" title="定义PDF导出接口"></a>定义PDF导出接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PdfExportService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">make</span><span class="params">(Map&lt;String, Object&gt; model, Document document,</span></span></span><br><span class="line"><span class="function"><span class="params">                     PdfWriter writer, HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                     HttpServletResponse response)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要继承这个接口，就能够自定义导出逻辑了。</p><p>接着是写一个类，让其继承AbstractPdfView的非抽象类。</p><h5 id="PDF导出视图类"><a href="#PDF导出视图类" class="headerlink" title="PDF导出视图类"></a>PDF导出视图类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PdfView</span> <span class="keyword">extends</span> <span class="title">AbstractPdfView</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 导出服务接口</span></span><br><span class="line">    <span class="keyword">private</span> PdfExportService pdfExportService = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建对象的时候载入导出服务接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PdfView</span><span class="params">(PdfExportService pdfExportService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pdfExportService = pdfExportService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用接口实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">buildPdfDocument</span><span class="params">(Map&lt;String, Object&gt; model, Document document,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    PdfWriter writer, HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 调用导出服务接口类</span></span><br><span class="line">        pdfExportService.make(model, document, writer, request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，创建PDF对象的时候，便调用这个构造函数，而这个构造函数将调用AbstractPdfView接口的抽象方法，完成内部实现。</p><h5 id="由控制器导出PDF数据"><a href="#由控制器导出PDF数据" class="headerlink" title="由控制器导出PDF数据"></a>由控制器导出PDF数据</h5><p>接下来就是由控制器去导出PDF文件了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出接口</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/export/pdf"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">exportPdf</span><span class="params">(String userName, String note)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 查询用户信息列表</span></span><br><span class="line">List&lt;User&gt; userList = userService.findUsers(userName, note);</span><br><span class="line"><span class="comment">// 定义PDF视图</span></span><br><span class="line">View view = <span class="keyword">new</span> PdfView(exportService());</span><br><span class="line">ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line"><span class="comment">// 设置视图</span></span><br><span class="line">mv.setView(view);</span><br><span class="line"><span class="comment">// 加入数据模型</span></span><br><span class="line">mv.addObject(<span class="string">"userList"</span>, userList);</span><br><span class="line"><span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出PDF自定义</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> PdfExportService <span class="title">exportService</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 使用Lambda表达式定义自定义导出</span></span><br><span class="line"><span class="keyword">return</span> (model, document, writer, request, response) -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// A4纸张</span></span><br><span class="line">document.setPageSize(PageSize.A4);</span><br><span class="line"><span class="comment">// 标题</span></span><br><span class="line">document.addTitle(<span class="string">"用户信息"</span>);</span><br><span class="line"><span class="comment">// 换行</span></span><br><span class="line">document.add(<span class="keyword">new</span> Chunk(<span class="string">"\n"</span>));</span><br><span class="line"><span class="comment">// 表格，3列</span></span><br><span class="line">PdfPTable table = <span class="keyword">new</span> PdfPTable(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 单元格</span></span><br><span class="line">PdfPCell cell = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 字体，定义为蓝色加粗</span></span><br><span class="line">Font f8 = <span class="keyword">new</span> Font();</span><br><span class="line">f8.setColor(Color.BLUE);</span><br><span class="line">f8.setStyle(Font.BOLD);</span><br><span class="line"><span class="comment">// 标题</span></span><br><span class="line">cell = <span class="keyword">new</span> PdfPCell(<span class="keyword">new</span> Paragraph(<span class="string">"id"</span>, f8));</span><br><span class="line"><span class="comment">// 居中对齐</span></span><br><span class="line">cell.setHorizontalAlignment(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 将单元格加入表格</span></span><br><span class="line">table.addCell(cell);</span><br><span class="line">cell = <span class="keyword">new</span> PdfPCell(<span class="keyword">new</span> Paragraph(<span class="string">"user_name"</span>, f8));</span><br><span class="line"><span class="comment">// 居中对齐</span></span><br><span class="line">cell.setHorizontalAlignment(<span class="number">1</span>);</span><br><span class="line">table.addCell(cell);</span><br><span class="line">cell = <span class="keyword">new</span> PdfPCell(<span class="keyword">new</span> Paragraph(<span class="string">"note"</span>, f8));</span><br><span class="line">cell.setHorizontalAlignment(<span class="number">1</span>);</span><br><span class="line">table.addCell(cell);</span><br><span class="line"><span class="comment">// 获取数据模型中的用户列表</span></span><br><span class="line">List&lt;User&gt; userList = (List&lt;User&gt;) model.get(<span class="string">"userList"</span>);</span><br><span class="line"><span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">document.add(<span class="keyword">new</span> Chunk(<span class="string">"\n"</span>));</span><br><span class="line">cell = <span class="keyword">new</span> PdfPCell(<span class="keyword">new</span> Paragraph(user.getId() + <span class="string">""</span>));</span><br><span class="line">table.addCell(cell);</span><br><span class="line">cell = <span class="keyword">new</span> PdfPCell(<span class="keyword">new</span> Paragraph(user.getUserName()));</span><br><span class="line">table.addCell(cell);</span><br><span class="line">String note = user.getNote() == <span class="keyword">null</span> ? <span class="string">""</span> : user.getNote();</span><br><span class="line">cell = <span class="keyword">new</span> PdfPCell(<span class="keyword">new</span> Paragraph(note));</span><br><span class="line">table.addCell(cell);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在文档中加入表格</span></span><br><span class="line">document.add(table);</span><br><span class="line">&#125; <span class="keyword">catch</span> (DocumentException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法先通过查询后台数据得到用户列表，再放入模型和视图（ModelAndView）中，然后设置一个视图（PdfView）。而定义dfView时，使用Lambda表达式实现了导出服务接口，这样就可以很方便地让每一个控制器自定义样式和数据。</p><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>打开浏览器，输入：<a href="http://localhost:8888/user/export/pdf?userName=张三&amp;note=人" target="_blank" rel="noopener">http://localhost:8888/user/export/pdf?userName=张三&amp;note=人</a></p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie2to4/8.png" alt=""></p><h5 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h5><p>这其中有个最为常见的坑，那就是PDF不显示中文的现象，上述代码通过加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseFont Chinese = BaseFont.createFont(<span class="string">"C:\\Windows\\Fonts\\simsun.ttc,1"</span>,BaseFont.IDENTITY_H,BaseFont.NOT_EMBEDDED);</span><br><span class="line"><span class="comment">//使得：</span></span><br><span class="line">Font f8 = <span class="keyword">new</span> Font(Chinese);</span><br><span class="line"><span class="comment">//最后在cell和Paragraph构造中加入f8就行了</span></span><br></pre></td></tr></table></figure><p>截取部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Font f8 = <span class="keyword">new</span> Font(Chinese);</span><br><span class="line"><span class="comment">//.............</span></span><br><span class="line">cell = <span class="keyword">new</span> PdfPCell(<span class="keyword">new</span> Paragraph(<span class="string">"id"</span>, f8));</span><br><span class="line"><span class="comment">//.................</span></span><br><span class="line">List&lt;User&gt; userList = (List&lt;User&gt;) model.get(<span class="string">"userList"</span>);</span><br><span class="line"><span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">document.add(<span class="keyword">new</span> Chunk(<span class="string">"\n"</span>));</span><br><span class="line">cell = <span class="keyword">new</span> PdfPCell(<span class="keyword">new</span> Paragraph(user.getId() + <span class="string">""</span>,f8));</span><br><span class="line"><span class="comment">//...................</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>文件上传在web中可以说是必须有的操作了，SpringMVC也对其有着很好的支持。</p><h4 id="SpringMVC对文件上传的支持"><a href="#SpringMVC对文件上传的支持" class="headerlink" title="SpringMVC对文件上传的支持"></a>SpringMVC对文件上传的支持</h4><p>首先，DispatcherServlet会使用适配器模式，将HttpServletRequest接口对象转换为MultipartHttpServletRequest象。MultipartHttpServletRequest接口扩展了HttpServletRequest接口的所有方法，而且定义了一些操作文件的方法，这样通过这些方法就可以实现对上传文件的操作。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/images/5.png" alt=""></p><p>这里对于文件上传的场景，SpringMVC会将HttpServletRequest对象转化为MultipartHttpServlet­Request对象。</p><p>从MultipartHttpServletRequest接口的定义看，它存在许多的方法用来处理文件，这样SpringMVC中操作文件就十分便捷。只是在使用SpringMVC上传文件时，还需要配置MultipartHttpServletRequest，这个任务是通过MultipartResolver接口实现的。</p><p>对于MultipartResover接口，它又存在两个实现类，这两个实现类分是StandardServletMultipartResolver和CommonsMultipartResolver，可以使用它们中的任意一个来现文件上传。在默认的情况下Spring推荐使用的是StandardServletMultipartResolver，因为它只需要依赖于ServletAPI提供的包，而对于CommonsMultipartResolver，则需要依赖于Apache提供的第三方包来实，这然没有StandardServletMultipartResolver来实在。</p><p>从实用的角度来说，因为Spring3.1之后己经能够支持StandardServletMultipartR巳solver，所以CommonsMultipartResolver已经渐渐被废弃了，因此这里不再对其进行介绍。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/images/6.png" alt=""></p><h4 id="文件上传的配置"><a href="#文件上传的配置" class="headerlink" title="文件上传的配置"></a>文件上传的配置</h4><p>打开application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">servlet:</span></span><br><span class="line">  <span class="attr">multipart:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#是否开启SpringMVC多分布上传功能</span></span><br><span class="line">    <span class="attr">file-size-threshold:</span> <span class="number">0</span> <span class="comment">#将文件写入磁盘阈值，值可以使用后缀“MB”或者是“KB”来表示兆字节大小</span></span><br><span class="line">    <span class="attr">location:</span> <span class="comment">#指定默认上传文件夹，一般不设置</span></span><br><span class="line">    <span class="attr">max-file-size:</span> <span class="string">5MB</span> <span class="comment">#设置单个文件最大值</span></span><br><span class="line">    <span class="attr">max-request-size:</span> <span class="string">100MB</span> <span class="comment">#设置所有文件最大值</span></span><br><span class="line">    <span class="attr">resolve-lazily:</span> <span class="literal">false</span> <span class="comment">#是否延迟多部件文件请求的参数和文件解析</span></span><br></pre></td></tr></table></figure><p>根据这些配置，SpringBoot会自动生成StandardServletMultipartResolv巳r对象这样就能够对上传的文件进行配置。对于文件的上传可以使用ServletAPI提供的Part接口或者SpringMVC提供的MultipartFile接作为参数。</p><h4 id="开发文件上传功能"><a href="#开发文件上传功能" class="headerlink" title="开发文件上传功能"></a>开发文件上传功能</h4><h5 id="upload"><a href="#upload" class="headerlink" title="upload"></a>upload</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form method&#x3D;&quot;post&quot;</span><br><span class="line">      action&#x3D;&quot;.&#x2F;part&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file&quot; value&#x3D;&quot;请选择上传的文件&quot; &#x2F;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><p>注意，这里的的form表单的类型必须声明为： enctype=”multipart/form-data”。如果没有这个声明，SpringMVC就不能自动对其解析。</p><h5 id="FileController"><a href="#FileController" class="headerlink" title="FileController"></a>FileController</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/file"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打开文件上传请求页面</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 指向HTML的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/page"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">uploadPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"upload"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用HttpServletRequest作为参数</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/request"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">uploadRequest</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        MultipartHttpServletRequest mreq = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 强制转换为MultipartHttpServletRequest接口对象</span></span><br><span class="line">        <span class="keyword">if</span> (request <span class="keyword">instanceof</span> MultipartHttpServletRequest) &#123;</span><br><span class="line">            mreq = (MultipartHttpServletRequest) request;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dealResultMap(<span class="keyword">false</span>, <span class="string">"上传失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取MultipartFile文件信息</span></span><br><span class="line">        MultipartFile mf = mreq.getFile(<span class="string">"file"</span>);</span><br><span class="line">        <span class="comment">// 获取源文件名称</span></span><br><span class="line">        String fileName = mf.getOriginalFilename();</span><br><span class="line">        File file = <span class="keyword">new</span> File(fileName);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 保存文件</span></span><br><span class="line">            mf.transferTo(file);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> dealResultMap(<span class="keyword">false</span>, <span class="string">"上传失败"</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> dealResultMap(<span class="keyword">true</span>, <span class="string">"上传成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用Spring MVC的MultipartFile类作为参数</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/multipart"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">uploadMultipartFile</span><span class="params">(MultipartFile file)</span> </span>&#123;</span><br><span class="line">        String fileName = file.getOriginalFilename();</span><br><span class="line">        File dest = <span class="keyword">new</span> File(fileName);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            file.transferTo(dest);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> dealResultMap(<span class="keyword">false</span>, <span class="string">"上传失败"</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> dealResultMap(<span class="keyword">true</span>, <span class="string">"上传成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/part"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">uploadPart</span><span class="params">(Part file)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取提交文件名称</span></span><br><span class="line">        String fileName = file.getSubmittedFileName();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 写入文件</span></span><br><span class="line">            file.write(fileName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> dealResultMap(<span class="keyword">false</span>, <span class="string">"上传失败"</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> dealResultMap(<span class="keyword">true</span>, <span class="string">"上传成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理上传文件结果</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title">dealResultMap</span><span class="params">(<span class="keyword">boolean</span> success, String msg)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; result = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        result.put(<span class="string">"success"</span>, success);</span><br><span class="line">        result.put(<span class="string">"msg"</span>, msg);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中uploadPage方法用来映射上传文件的HTML页面，所以只需要请求它便能够打开上传文件的页面。</p><p>uploadRequest方法则将HttpServletRequest对象传递，从之前的分析可知，在调用控制器之前，DispatcherServlet会将其转换为MultipartHttpServletRequest对象，所以方法中使用了强制转换，从而得到MultipartHttpServletRequest对象，然后获取MultipartFile对象，接着使用MultipartFile对象的getOrigina!Filename方法就可以得到上传的文件名，而通过它的transferTo方法，就可以将文件保存到对应的路径中。</p><p>uploadMultipartFile则是直接使用MultipartFile对象获取上传的文件，从而进行操作。uploadPart方法是使用Servlet的API，可以使用其write方法直接写入文件，这种方式更为巧妙。</p><h5 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h5><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie2to4/9.png" alt=""></p><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>虽然我们已经拥有Security来做我们的拦截器了，但是还是很有必要了解一下SpringMVC自带的拦截器。</p><p>在刚提起SpringMVC的时候，就说过DispatcherServlet，请求来到DispatcherServlet，它会根据HandlerMapping的机制找到处理器，这样就会返回一个HandlerExecutionChain对象，这个对象包含处理器和拦截器。这里的拦截器会对处理器进行拦截，这样通过截器就可以增强处理器的功能。</p><h4 id="拦截器的设计"><a href="#拦截器的设计" class="headerlink" title="拦截器的设计"></a>拦截器的设计</h4><p>所有的拦截器都继承了一个接口：HandlerInterceptor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//处理执行前</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//处理器处理方法后</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//处理器完成方法后</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程比较直观，如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/images/7.png" alt=""></p><ol><li>执行preHandle方法，该方法会返回一个布尔值。如果为false，则结束所有流程：如果为true,则执行下一步。</li><li>执行处理器逻辑，它包含控制器的功能。</li><li>执行postHandle方法。</li><li>执行视图解析和视图渲染。</li><li>执行afterCompletion方法。</li></ol><p>因为这个接口是Java8的接口，所以3个方法都被声明为default，并且提供了空实现。当我们需要自己定义方法的时候，只需要实现HandlerInterceptor，覆盖其对应的方法即可。</p><h4 id="开发拦截器"><a href="#开发拦截器" class="headerlink" title="开发拦截器"></a>开发拦截器</h4><h5 id="拦截器实例"><a href="#拦截器实例" class="headerlink" title="拦截器实例"></a>拦截器实例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interceptor1</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"处理器前方法"</span>);</span><br><span class="line">        <span class="comment">// 返回true，不会拦截后续的处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletResponse response, Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">            ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"处理器后方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletResponse response, Object handler, Exception ex)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"处理器完成方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码实现了Handlerlnterceptor，然后按照自己的需要重写了3具体的拦截器方法。在这些方法中都打印了一些信息，这样就可以定位拦截器方法的执行顺序。</p><p>其中这里的preHandle法返回的是true，也可以将其修改为返回false，再观察其不同。有了这个拦截器，SpringMVC并不会发现它，它还需要进行注册才能够拦截处理器，为此需要在配文件中实现WebMvcConfigurer接口：</p><h5 id="配置拦截器"><a href="#配置拦截器" class="headerlink" title="配置拦截器"></a>配置拦截器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMVCConfiguration</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 注册拦截器到Spring MVC机制，然后它会返回一个拦截器注册</span></span><br><span class="line">      InterceptorRegistration ir = registry.addInterceptor(<span class="keyword">new</span> Interceptor1());</span><br><span class="line">      <span class="comment">// 指定拦截匹配模式，限制拦截器拦截请求</span></span><br><span class="line">      ir.addPathPatterns(<span class="string">"/interceptor/*"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里通过实现WebMvcConfigurer接口，重写其中的addlnterceptors方法，进而加入自定义拦截器一一Interceptor!，然后指定其拦截的模式，所以它只会拦截与正则式“／interceptor/*”匹配的请求。</p><h5 id="控制器和页面"><a href="#控制器和页面" class="headerlink" title="控制器和页面"></a>控制器和页面</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/interceptor"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorController</span> </span>&#123;</span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/start"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"执行处理器逻辑"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"/welcome"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>你好，现在进行测试<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里非常简单，不多赘述。</p><h5 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h5><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie2to4/10.png" alt=""></p><p>这里是后台信息，可以从这里看出，拦截器的运行流程。</p><h4 id="多个拦截器的顺序"><a href="#多个拦截器的顺序" class="headerlink" title="多个拦截器的顺序"></a>多个拦截器的顺序</h4><p>如果我们还有多个拦截器，那么它运行的顺序又是怎么样的呢？首先需要多个拦截器实例，当然和前面是一样的，这里仅仅列出来：</p><h5 id="多个拦截器实例"><a href="#多个拦截器实例" class="headerlink" title="多个拦截器实例"></a>多个拦截器实例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MulitiInterceptor1</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"【"</span> + <span class="keyword">this</span>.getClass().getSimpleName()</span><br><span class="line">            +<span class="string">"】处理器前方法"</span>);</span><br><span class="line">        <span class="comment">// 返回true，不会拦截后续的处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletResponse response, Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">            ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"【"</span> + <span class="keyword">this</span>.getClass().getSimpleName()</span><br><span class="line">            +<span class="string">"】处理器后方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletResponse response, Object handler, Exception ex)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"【"</span> + <span class="keyword">this</span>.getClass().getSimpleName()</span><br><span class="line">            +<span class="string">"】处理器完成方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//......省略同样的三个类</span></span><br></pre></td></tr></table></figure><p>然后，注册拦截器</p><h5 id="注册拦截器"><a href="#注册拦截器" class="headerlink" title="注册拦截器"></a>注册拦截器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册拦截器到Spring MVC机制中</span></span><br><span class="line"> InterceptorRegistration ir = registry.addInterceptor(<span class="keyword">new</span></span><br><span class="line">         MulitiInterceptor1());</span><br><span class="line"> <span class="comment">// 指定拦截匹配模式</span></span><br><span class="line"> ir.addPathPatterns(<span class="string">"/interceptor/*"</span>);</span><br><span class="line"> <span class="comment">// 注册拦截器到Spring MVC机制中</span></span><br><span class="line"> InterceptorRegistration ir2 = registry.addInterceptor(<span class="keyword">new</span></span><br><span class="line">         MulitiInterceptor2());</span><br><span class="line"> <span class="comment">// 指定拦截匹配模式</span></span><br><span class="line"> ir2.addPathPatterns(<span class="string">"/interceptor/*"</span>);</span><br><span class="line"> <span class="comment">// 注册拦截器到Spring MVC机制中</span></span><br><span class="line"> InterceptorRegistration ir3 = registry.addInterceptor(<span class="keyword">new</span></span><br><span class="line">         MulitiInterceptor3());</span><br><span class="line"> <span class="comment">// 指定拦截匹配模式</span></span><br><span class="line"> ir3.addPathPatterns(<span class="string">"/interceptor/*"</span>);</span><br></pre></td></tr></table></figure><p>这些代码放在WebMVCConfiguration 下面。</p><h5 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h5><p>同样的，我们直接去查看控制台：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie2to4/11.png" alt=""></p><p>我们发现，这个结果是责任链模式的规则，对于处理器前方法采用先注册先执行，而处理器后方法完成方法则是先注册后执行的规则。只是上述仅测试了处理器前（preHandle）方法返回为true的场景，在某些时候还可能返回为false，这个时候又如何呢？为此，可以将Mulitilnterceptor2的preHandle法修改返回为false，然后再进行测试，其日志如下：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie2to4/12.png" alt=""></p><p>上面的日志可以看出，处理器前（preHandle）方法会执行，但是一旦返回false，则续的拦截器、处理器和l所有拦截器的处理器后（postHandle）方法都不会被执行。完成方法afterCompletion则不一样，它只会执行返回true的拦截器的完成方法，而且顺序是先注册后执行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC详解（三）</title>
      <link href="/2020/02/15/spring12/"/>
      <url>/2020/02/15/spring12/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringMVC详解（三）"><a href="#SpringMVC详解（三）" class="headerlink" title="SpringMVC详解（三）"></a>SpringMVC详解（三）</h2><h3 id="数据验证"><a href="#数据验证" class="headerlink" title="数据验证"></a>数据验证</h3><p>前面在处理器逻辑中谈到了参数的转换，转换参数出来之后，紧跟着的往往需要验证参数的合法性，因此SpringMVC也提供了验证参数的机制。</p><p>一方面，它可以支持JSR-303注解验证，在默认的情况下SpringBoot会引入关于HibernateValidator机制来支持JSR-303验证规范；另外一方面，因为业务会比较复杂，所以需要自定义验证规则。</p><p>SpringMVC提供了相关的验证机制：</p><h4 id="JSR-303验证"><a href="#JSR-303验证" class="headerlink" title="JSR-303验证"></a>JSR-303验证</h4><p>JSR-303验证主要是通过注解的方式进行的。这里先定义一个需要验证的POJO，此时需要在其属性中加入相关的注解：</p><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidatorPojo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非空判断</span></span><br><span class="line"><span class="meta">@NotNull</span>(message = <span class="string">"id不能为空"</span>)</span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Future</span>(message = <span class="string">"需要一个将来日期"</span>) <span class="comment">// 只能是将来的日期</span></span><br><span class="line"><span class="comment">// @Past //只能去过去的日期</span></span><br><span class="line"><span class="meta">@DateTimeFormat</span>(pattern = <span class="string">"yyyy-MM-dd"</span>) <span class="comment">// 日期格式化转换</span></span><br><span class="line"><span class="meta">@NotNull</span> <span class="comment">// 不能为空</span></span><br><span class="line"><span class="keyword">private</span> Date date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NotNull</span> <span class="comment">// 不能为空</span></span><br><span class="line"><span class="meta">@DecimalMin</span>(value = <span class="string">"0.1"</span>) <span class="comment">// 最小值0.1元</span></span><br><span class="line"><span class="meta">@DecimalMax</span>(value = <span class="string">"10000.00"</span>) <span class="comment">// 最大值10000元</span></span><br><span class="line"><span class="keyword">private</span> Double doubleValue = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Min</span>(value = <span class="number">1</span>, message = <span class="string">"最小值为1"</span>) <span class="comment">// 最小值为1</span></span><br><span class="line"><span class="meta">@Max</span>(value = <span class="number">88</span>, message = <span class="string">"最大值为88"</span>) <span class="comment">// 最大值88</span></span><br><span class="line"><span class="meta">@NotNull</span> <span class="comment">// 不能为空</span></span><br><span class="line"><span class="keyword">private</span> Integer integer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Range</span>(min = <span class="number">1</span>, max = <span class="number">888</span>, message = <span class="string">"范围为1至888"</span>) <span class="comment">// 限定范围</span></span><br><span class="line"><span class="keyword">private</span> Long range;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邮箱验证</span></span><br><span class="line"><span class="meta">@Email</span>(message = <span class="string">"邮箱格式错误"</span>)</span><br><span class="line"><span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Size</span>(min = <span class="number">20</span>, max = <span class="number">30</span>, message = <span class="string">"字符串长度要求20到30之间。"</span>)</span><br><span class="line"><span class="keyword">private</span> String size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类中的属性带着各种各样验证注解，并且代码己经在注释中说明其作用，JSR-303验证就是通过这些注解来执行验证的。</p><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>为此需要一个页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>测试JSR-303<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 加载Query文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://code.jquery.com/jquery-3.2.0.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 请求验证的POJO</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> pojo = &#123;</span></span><br><span class="line"><span class="actionscript">                id : <span class="literal">null</span>,</span></span><br><span class="line"><span class="actionscript">                date : <span class="string">'2017-08-08'</span>,</span></span><br><span class="line">                doubleValue : 999999.09,</span><br><span class="line">                integer : 100,</span><br><span class="line">                range : 1000,</span><br><span class="line"><span class="actionscript">                email : <span class="string">'email'</span>,</span></span><br><span class="line"><span class="actionscript">                size : <span class="string">'adv1212'</span>,</span></span><br><span class="line"><span class="actionscript">                regexp : <span class="string">'a,b,c,d'</span></span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            $.post(&#123;</span></span><br><span class="line"><span class="actionscript">                url : <span class="string">"./validate"</span>,</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 此处需要告知传递参数类型为JSON，不能缺少</span></span></span><br><span class="line"><span class="actionscript">                contentType : <span class="string">"application/json"</span>,</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 将JSON转化为字符串传递</span></span></span><br><span class="line"><span class="javascript">                data : <span class="built_in">JSON</span>.stringify(pojo),</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 成功后的方法</span></span></span><br><span class="line"><span class="actionscript">                success : <span class="function"><span class="keyword">function</span><span class="params">(result)</span> </span>&#123;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再需要一控制器去响应这个Ajax请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/page"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">validPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"pojo"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 解析验证参数错误</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> vp —— 需要验证的POJO，使用注解<span class="doctag">@Valid</span> 表示验证</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> errors  错误信息，它由Spring MVC通过验证POJO后自动填充</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 错误信息Map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/validate"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">validate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @Valid @RequestBody ValidatorPojo vp, Errors errors)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; errMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 获取错误列表</span></span><br><span class="line">    List&lt;ObjectError&gt; oes = errors.getAllErrors();</span><br><span class="line">    <span class="keyword">for</span> (ObjectError oe : oes) &#123;</span><br><span class="line">        String key = <span class="keyword">null</span>;</span><br><span class="line">        String msg = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 字段错误</span></span><br><span class="line">        <span class="keyword">if</span> (oe <span class="keyword">instanceof</span> FieldError) &#123;</span><br><span class="line">            FieldError fe = (FieldError) oe;</span><br><span class="line">            key = fe.getField();<span class="comment">// 获取错误验证字段名</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 非字段错误</span></span><br><span class="line">            key = oe.getObjectName();<span class="comment">// 获取验证对象名称</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 错误信息</span></span><br><span class="line">        msg = oe.getDefaultMessage();</span><br><span class="line">        errMap.put(key, msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> errMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中使用＠RequestBody代表着接收一个JSON参数，这样Spring就会获页面通过Ajax提交的JSON请求体，然后＠Valid注解则表示启动验证机，这样Spring就会启用JSR-303验证机制进行验证。它会自动地将最后的验证结果放入Errors对象中，这样就可以从中得到相验证过后的信息。</p><p>在浏览器输入：<a href="http://localhost:8888/my/page" target="_blank" rel="noopener">http://localhost:8888/my/page</a></p><p>结果如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie2to4/5.png" alt=""></p><p>显然这里的验证成功了。但是有时验证规则并不是那么简单，比如一些业务逻辑的验证。例如，假设需要验证购买商品的总价格，那么就应该是：总价格＝单价×数量，这样的逻辑验证就不能通过JSR-303验证了。为此Spring还提供了自己的验证机制，下面来介绍它。</p><h4 id="参数验证机制"><a href="#参数验证机制" class="headerlink" title="参数验证机制"></a>参数验证机制</h4><p>为了能够更加灵活地提供验证机制，Spring还提供自己的验证机制。在参数转换时，可以看到在SpringMVC中，存在WebDataBinder机制进行管理，在默认的情况下Spring会自动地根据上下文通过注册了的转换器转换出控制器所需的参数。在WebDataBinder中除了可以注册转换器外，还允许注册验证器（Validator）。</p><p>在Spring控制器中，它还允许使用注解＠InitBinder，这个注解的作用是允许在进入控制器方法前修改WebDataBinder机制。</p><p>下面在验证机制和日期格式绑定的场景下演示，不过在此之前，需要稍微认识一下SpringMVC的验证机制。</p><h5 id="Validator源码"><a href="#Validator源码" class="headerlink" title="Validator源码"></a>Validator源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Validator</span></span>&#123;</span><br><span class="line">    <span class="comment">/*判定当前验证器是否支持该Class类型的验证</span></span><br><span class="line"><span class="comment">        @param clazzPOJO类型</span></span><br><span class="line"><span class="comment">        @return当前验证都是否支持该POJO验证</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    booleansupports(Class&lt;?&gt;clazz);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果supports返回true，则这个方法执行验证逻辑*@paramtarget被验证POJO对象*@paramerrors错误对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">Void <span class="title">validate</span><span class="params">(Object target,Errors errors)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是Spring所定义的验证器接口，它定义了两个方法，其中supports方法参数为需要验证的POJO类型，如果该方法返回true，则Spring会使用当前验证器的validation方法去验证POJO。</p><p>而validation方法包含需要的target对象和l错误对象errors，其中target是参数绑定后的POJO，这样便可以通过这个参数对象进行业务逻辑的自定义验证。如果发现错误，则可以保存到errors对象中，然后返回给控制器。</p><p>下面以实例进行说明：</p><h5 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h5><p>自定义用户验证器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserValidator</span> <span class="keyword">implements</span> <span class="title">Validator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该验证器只是支持User类验证</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> clazz.equals(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证逻辑</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(Object target, Errors errors)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 对象为空</span></span><br><span class="line"><span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 直接在参数处报错，这样就不能进入控制器的方法了</span></span><br><span class="line">errors.rejectValue(<span class="string">""</span>, <span class="keyword">null</span>, <span class="string">"用户不能为空"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 强制转换</span></span><br><span class="line">User user = (User) target;</span><br><span class="line"><span class="comment">// 用户名非空串</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(user.getUserName())) &#123;</span><br><span class="line"><span class="comment">// 增加错误，可以进入控制器方法</span></span><br><span class="line">errors.rejectValue(<span class="string">"userName"</span>, <span class="keyword">null</span>, <span class="string">"用户名不能为空"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个验证器，Spring还不会自动启用它，因为还没有绑定给WebDataBinder机制。在SpringMVC中提供了一个注解＠TnitBinder，它的作用是在执行控制器方法前，处理器会先执行表@lnitBinder标注的方法。</p><p>这时可以将WebDataBinder对象作为参数传递到方法中，通过这层关系得到WebDataBinder对象，这个对象有一个setValidator方法，它可以绑定自定义的验证器，这样就可以在获取参数之后，通过自定义的验证器去验证参数，只是WebDataBinder除了可以绑定验证器外，还可以进行参数的自定义，例如，不使用＠DateTirneFormat获取日期参数。假设还继续使用StringToUserConverter转换器，再来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用控制器前先执行这个方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> binder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@InitBinder</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initBinder</span><span class="params">(WebDataBinder binder)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 绑定验证器</span></span><br><span class="line">binder.setValidator(<span class="keyword">new</span> UserValidator());</span><br><span class="line"><span class="comment">// 定义日期参数格式，参数不再需注解@DateTimeFormat，boolean参数表示是否允许为空</span></span><br><span class="line">binder.registerCustomEditor(Date.class, new CustomDateEditor(new SimpleDateFormat("yyyy-MM-dd"), false));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment"> *            -- 用户对象用StringToUserConverter转换</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> Errors</span></span><br><span class="line"><span class="comment"> *            --验证器返回的错误</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> date</span></span><br><span class="line"><span class="comment"> *            -- 因为WebDataBinder已经绑定了格式，所以不再需要注解</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 各类数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/validator"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">validator</span><span class="params">(@Valid User user, Errors Errors, Date date)</span> </span>&#123;</span><br><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"user"</span>, user);</span><br><span class="line">map.put(<span class="string">"date"</span>, date);</span><br><span class="line"><span class="comment">// 判断是否存在错误</span></span><br><span class="line"><span class="keyword">if</span> (Errors.hasErrors()) &#123;</span><br><span class="line"><span class="comment">// 获取全部错误</span></span><br><span class="line">List&lt;ObjectError&gt; oes = Errors.getAllErrors();</span><br><span class="line"><span class="keyword">for</span> (ObjectError oe : oes) &#123;</span><br><span class="line"><span class="comment">// 判定是否字段错误</span></span><br><span class="line"><span class="keyword">if</span> (oe <span class="keyword">instanceof</span> FieldError) &#123;</span><br><span class="line"><span class="comment">// 字段错误</span></span><br><span class="line">FieldError fe = (FieldError) oe;</span><br><span class="line">map.put(fe.getField(), fe.getDefaultMessage());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 对象错误</span></span><br><span class="line">map.put(oe.getObjectName(), oe.getDefaultMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里的initBinder方法因为标注注解＠lnitBinder，因此会在控制器方法前被执行，并且将WebDataBinder对象传递进去，在这个方法里绑定了自定义的验证器UserValidator，而且设置了日期的格式，所以在控制器方法中己经不再需要使用＠DateTimeForrnat去定义日期格式化。</p><p>通过这样的自定义，在使用注解＠Valid标注User参数后，SpringMVC就会去遍历对应的验证器，当遍历到UserValidator时，会去执行它的supports方法。因为该方法会返回true，所以SpringMVC会用这个验证器去验证User类的数据。对于日期类型也指定了对应的格式，这样控制器的Date类型的参数也不需要再使用注解的协作。</p><p>这里还要关注一下控制器方法中的Errors参数。它是SpringMVC通过验证器验证后得到的错误信息，由SpringMVC执行完验证规则后进行传递。这里首先是判断是否存在错误，如果存在错误，则遍历错误，然后将错误信息放入Map中返回，因为方法标注了＠ResponseBody，所以最后会转化为ISON响应请求。</p><p>下面输<a href="http://localhost:8888/user/validator?user=1--note_1&amp;date=2018-01-01。" target="_blank" rel="noopener">http://localhost:8888/user/validator?user=1--note_1&amp;date=2018-01-01。</a></p><p>请注意，这里的userNam巳已经传递为空，所以在进行用户验证时会存在错误信息的显示这个请求的结果截图如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie2to4/6.png" alt=""></p><p>可以看到，用户名的验证己经成功，也就是说验证器己经起到作用，而且日期也是成功的，它返回了一个日期的Long型整数（时间参数与1970-01-0100:00:00之间的毫秒数）。</p><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>上面只是谈到了参数的获取和转换，通过这些处理器终于可以调用控制器了。在SpringMVC流程中，控制器是业务逻辑核心内容，而控制器的核心内容之一就是对数据的处理。</p><p>可以得知的是：允许控制器自定义模型和视图（ModelAndView），其中模型是存放数据的地方，视图则是展示给用户。</p><p>这里暂时把视图放下，先来讨论数据模型的问题。数据模型的作用是绑定数据，为后面的视图渲染做准备。首先对SpringMVC使用的模型接口和类设计进行探讨，如图所示：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/images/3.png" alt=""></p><p>从图可以看到，在类ModelAndView中存在一个Mode!Map类型的属性，ModelMap继承了LinkedHashmap类，所以它具备Map接口的一切特性，除此之外它还可以增加数据属性。</p><p>在SpringMVC的应用中，如果在控制器方法的参数中使用ModelAndView、Model或者Mode!Map作为参数类型，SpringMVC会自动创建数据模型对象：</p><h4 id="使用数据模型"><a href="#使用数据模型" class="headerlink" title="使用数据模型"></a>使用数据模型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/data"</span>)</span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataModelController</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注入用户服务类</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试Model接口</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/model"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">useModel</span><span class="params">(Long id, Model model)</span> </span>&#123;</span><br><span class="line">        User user = userService.getUser(id);</span><br><span class="line">        model.addAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">        <span class="comment">// 这里返回字符串，在Spring MVC中，会自动创建ModelAndView且绑定名称</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"user"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试modelMap类</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/modelMap"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">useModelMap</span><span class="params">(Long id, ModelMap modelMap)</span> </span>&#123;</span><br><span class="line">        User user = userService.getUser(id);</span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        <span class="comment">// 设置视图名称</span></span><br><span class="line">        mv.setViewName(<span class="string">"user"</span>);</span><br><span class="line">        <span class="comment">// 设置数据模型，此处modelMap并没有和mv绑定，这步系统会自动处理</span></span><br><span class="line">        modelMap.put(<span class="string">"user"</span>, user);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试ModelAndView</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/mav"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">useModelAndView</span><span class="params">(Long id, ModelAndView mv)</span> </span>&#123;</span><br><span class="line">        User user = userService.getUser(id);</span><br><span class="line">        <span class="comment">// 设置数据模型</span></span><br><span class="line">        mv.addObject(<span class="string">"user"</span>, user);</span><br><span class="line">        <span class="comment">// 设置视图名称</span></span><br><span class="line">        mv.setViewName(<span class="string">"user"</span>);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中可以看出SpringMVC还是比较智能的。例如，useModel方法里，只是返回一个字符串，SpringMVC会自动生成对应的视图，并且绑定数据模型。又如，useModelMap方法，返回了ModelAndView对象，但是它没有绑定ModelMap对象，SpringMVC又会自动地绑定它。</p><h5 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h5><p>首先需要一个视图：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>用户信息<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>编号<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.id&#125;"</span>&gt;</span>id<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.userName&#125;"</span>&gt;</span>userName<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>备注<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.note&#125;"</span>&gt;</span>note<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结果图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie2to4/7.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC详解（二）</title>
      <link href="/2020/02/14/spring11/"/>
      <url>/2020/02/14/spring11/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringMVC详解（二）"><a href="#SpringMVC详解（二）" class="headerlink" title="SpringMVC详解（二）"></a>SpringMVC详解（二）</h2><p>SpringMVC开发中，控制器的开发是最为重要的一步，而开发控制器的第一步就是让控制器的方法能够与请求的URL对应起来，这就是注＠RequestMappi吨的功能，所以我们从这个注解开始讨论。</p><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><h4 id="处理器映射"><a href="#处理器映射" class="headerlink" title="处理器映射"></a>处理器映射</h4><p>正如前面所提及的，如果Web工程使用SpringMVC，那么它在启动阶段就会将注解@RequestMapping所配置的内容保存到处理器映射（HandlerMapping）机制中去，后等待请求的到来，通过拦截请求信息与HandlerMapping进行匹配，找到对应的处理器（它包含控制器的逻辑），并将处理器及其拦截器保到HandlerExecutionChain对象中，返回给DispatcherServlet，这样DispatcherServlet就可以运行它们了。</p><p>从论述中可以看到，HandlerMapping的主要任务是将请求定位到具体的处理器上。关于＠RequestMapping的配置项并不多，这里通过源码来学习</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementTypeMETHOD,ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Mapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestMapping&#123;</span><br><span class="line">    /／配置请求映射名称</span><br><span class="line">       <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span></span><br><span class="line"><span class="function">    ／／通过路径映射@<span class="title">AliasFor</span><span class="params">(”path<span class="string">")</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">       String[] value()default&#123;&#125;;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">     ／／通过路径映射回path配置项目</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">     @AliasFor（”value”）</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">       String[] path() default&#123;&#125;;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">     ／／限定只响应HTTP请求类型，如GET,POST、HEAD、OPTIONS、PUT、TRACE等</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">      ／／默认的情况下，可以响应所有的请求类型</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">      RequestMethod[] method() default&#123;&#125;;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">      ／／当存在对应的HTTP参数时才响应请求</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">       String[] params() default&#123;&#125;;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">       ／／限定请求头存在对应的参数时才响应</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">       String[] headers() default&#123;&#125;;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        ／／限定HTTP请求体提交类型，如”applicat工on／〕son”、Htext/html”</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">       String[] consumes() default&#123;&#125;;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        ／／限定返回的内容类型，仅当HTTPi苛求头中的（Accept）类型中包含该指定类型时才返回</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">         String[] produces() default&#123;&#125;;</span></span></span></span><br></pre></td></tr></table></figure><p>这里可以通过配置项value或者path来设置请求URL。从而让对应的请求映射到控制器或其方法上，在此基础上还可以通过其他配置项来缩小请求映射的范围。</p><p>当然，配置项value和path也可以通过正则式来让方法匹配多个请求。</p><p>但是从现实的角度来说，如果不是有必要，尽量不要这么做。因为这样请求的匹配规则就复杂了，会对后续开发造成一定的困扰。</p><p>因此在能够明确场景下，都建议一个路径对应一个方法或者让正则式的匹配规则简单明了，这样就能够提高程序的可读性，以利于后续的维护和改造。</p><p>路径是必需的配置项，这里的method配置项可以限定HTTP的请求类型，这是最常用的配置项，可以区分HTTP的GET或者POST等不同的请求。</p><p>只是在Spring4.3的版本之后，为了简化method配置项的配置新增了几个注解，如＠GetMapping、＠PostMapping、＠PatchMapping、＠PutMapping和@DeleteMapping。</p><h4 id="获取控制器参数"><a href="#获取控制器参数" class="headerlink" title="获取控制器参数"></a>获取控制器参数</h4><p>处理器是对控制器的包装，在处理器运行的过程中会调度控制器的方法，只是它在进入控制器方法之前会对HTTP的参数和上下文进行解析，将它们转换为控制器所需的参数。这一步是处理器首先需要做的事情，只是在大部分的情况下不需要自己去开发这一步，因为SpringMVC已经提供了大量的转换规则，通过这些规则就能非常简易地获取大部分的参数。正如之前章节一样，在大部分情况下，我们并没有太在意如何获取参数，那是因为之前的场景都比较简单，在实际的开发中可能遇到一些复杂的场景，这样参数的获取就会变得复杂起来。例如，可能前端传递一个格式化的日期参数，又如需要传递复杂的对象给控制器，这个时候就需要对SpringMVC参数的获取做进一步的学习了。</p><h5 id="在无注解下获取参数"><a href="#在无注解下获取参数" class="headerlink" title="在无注解下获取参数"></a>在无注解下获取参数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/my"</span>)</span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在无注解下获取参数，要求参数名称和HTTP请求参数名称一致.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> intVal</span></span><br><span class="line"><span class="comment">     *            -- 整数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> longVal</span></span><br><span class="line"><span class="comment">     *            -- 长整形</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">     *            --字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 响应JSON参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// HTTP GET请求</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/no/annotation"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">noAnnotation</span><span class="params">(Integer intVal, Long longVal, String str)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; paramsMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        paramsMap.put(<span class="string">"intVal"</span>, intVal);</span><br><span class="line">        paramsMap.put(<span class="string">"longVal"</span>, longVal);</span><br><span class="line">        paramsMap.put(<span class="string">"str"</span>, str);</span><br><span class="line">        <span class="keyword">return</span> paramsMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后打开浏览器，输入：<a href="http://localhost:8888/my/no/annotation?intVal=10&amp;longVal=200进行测试。" target="_blank" rel="noopener">http://localhost:8888/my/no/annotation?intVal=10&amp;longVal=200进行测试。</a></p><p>这里的表达很明确，就接收参数是什么，那填写的信息就必须是什么，这样的做法，在如今前后端分离的情况下非常不具有优势，很可能前后和后端需要的参数不同，所以，我们一般会使用注解的方式，来表达我们的值。</p><h5 id="在注解的情况下获取参数"><a href="#在注解的情况下获取参数" class="headerlink" title="在注解的情况下获取参数"></a>在注解的情况下获取参数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/my"</span>)</span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过注解<span class="doctag">@RequestParam</span>获取参数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> intVal</span></span><br><span class="line"><span class="comment">     *            -- 整数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> longVal</span></span><br><span class="line"><span class="comment">     *            -- 长整形</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">     *            --字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 响应JSON数据集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/annotation"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">requestParam</span><span class="params">(@RequestParam(<span class="string">"int_val"</span>)</span> Integer intVal,</span></span><br><span class="line"><span class="function">                                            @<span class="title">RequestParam</span><span class="params">(<span class="string">"long_val"</span>)</span> Long longVal, @<span class="title">RequestParam</span><span class="params">(<span class="string">"str_val"</span>)</span> String strVal) </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; paramsMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        paramsMap.put(<span class="string">"intVal"</span>, intVal);</span><br><span class="line">        paramsMap.put(<span class="string">"longVal"</span>, longVal);</span><br><span class="line">        paramsMap.put(<span class="string">"strVal"</span>, strVal);</span><br><span class="line">        <span class="keyword">return</span> paramsMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中可以看到，在方法参数处使用了注解＠RequestParam，目的是指定HTTP参数和方法参数的映射关系，这样处理器就会按照其配的映射关系来得到参数，然后调用控制器的方法。</p><p>启动SpringBoot应用后，在浏览器地址栏输入<a href="http://localhost:8888/my/annotation?intval=l&amp;longva1=2&amp;strval=str，就能够看到请求的结果了。" target="_blank" rel="noopener">http://localhost:8888/my/annotation?intval=l&amp;longva1=2&amp;strval=str，就能够看到请求的结果了。</a></p><p>但如果把个HTTP参数中的任意一个删去，就会得到异常信息，因为在默认的情况下＠RequestPara标注的参数是不能为空的，为了让它能够为空，可以配置其属性required为false。</p><h4 id="传递数组"><a href="#传递数组" class="headerlink" title="传递数组"></a>传递数组</h4><p>除了传递一些简单的值之外，还能够传递数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/requestArray"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">requestArray</span><span class="params">(<span class="keyword">int</span>[] intArr, Long[] longArr, String[] strArr)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; paramsMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    paramsMap.put(<span class="string">"intArr"</span>, intArr);</span><br><span class="line">    paramsMap.put(<span class="string">"longArr"</span>, longArr);</span><br><span class="line">    paramsMap.put(<span class="string">"strArr"</span>, strArr);</span><br><span class="line">    <span class="keyword">return</span> paramsMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在页面上得到的数值的值，是通过逗号隔开的。</p><h4 id="传递JSON"><a href="#传递JSON" class="headerlink" title="传递JSON"></a>传递JSON</h4><p>JSON已经成为当今我的数据规范了，所以，我们来展示一下如何表达：前后端互相传递JSON的情况。</p><h5 id="HTML页面"><a href="#HTML页面" class="headerlink" title="HTML页面"></a>HTML页面</h5><p>首先需要建立一个表单：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 加载Query文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://code.jquery.com/jquery-3.2.0.js"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#submit"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> userName = $(<span class="string">"#userName"</span>).val();</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> note = $(<span class="string">"#note"</span>).val();</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> ($.trim(userName)==<span class="string">''</span>) &#123;</span></span><br><span class="line"><span class="actionscript">                    alert(<span class="string">"用户名不能为空！"</span>);</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">return</span>;</span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> params = &#123;</span></span><br><span class="line">                    userName : userName,</span><br><span class="line">                    note : note</span><br><span class="line">                &#125;;</span><br><span class="line"><span class="javascript">                $.post(&#123;</span></span><br><span class="line"><span class="actionscript">                    url : <span class="string">"./insert"</span>,</span></span><br><span class="line"><span class="actionscript">                    <span class="comment">// 此处需要告知传递参数类型为JSON，不能缺少</span></span></span><br><span class="line"><span class="actionscript">                    contentType : <span class="string">"application/json"</span>,</span></span><br><span class="line"><span class="actionscript">                    <span class="comment">// 将JSON转化为字符串传递</span></span></span><br><span class="line"><span class="javascript">                    data : <span class="built_in">JSON</span>.stringify(params),</span></span><br><span class="line"><span class="actionscript">                    <span class="comment">// 成功后的方法</span></span></span><br><span class="line"><span class="actionscript">                    success : <span class="function"><span class="keyword">function</span><span class="params">(result)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                        <span class="keyword">if</span> (result == <span class="literal">null</span> || result.id == <span class="literal">null</span>) &#123;</span></span><br><span class="line"><span class="actionscript">                            alert(<span class="string">"插入失败"</span>);</span></span><br><span class="line"><span class="actionscript">                            <span class="keyword">return</span>;</span></span><br><span class="line">                        &#125;</span><br><span class="line"><span class="actionscript">                        alert(<span class="string">"插入成功"</span>);</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin: 20px 0;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"insertForm"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>用户名称：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"userName"</span> <span class="attr">name</span>=<span class="string">"userName"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>备注<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"note"</span> <span class="attr">name</span>=<span class="string">"note"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"submit"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"提交"</span> /&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里定义了一个简易的表单，它使用了jQuery进行Ajax提交。</p><p>注意它的JS代码，它指定了提交的请求地址Curl）、数据（data）、提交类型（contentType）和事后事件（success）。</p><p>从代码来看，这里先组织了一个JSON数据集，而且把提交类型也设置为了JSON类，然后才提交到控制器。</p><p>这样控制器就可以得到一个JSON数据集的请求体了为了打开这个表单，需要在UserController中编写一个add方法，它将返回一个字符串，映射到这个表单上，这样就能通过视图解析器（ViewResolver）找到它了。</p><p>然后再写一个相应新增用户的请求insert方法，它将从HTTP请求体中读出这个JSON。</p><h5 id="add和insert方法"><a href="#add和insert方法" class="headerlink" title="add和insert方法"></a>add和insert方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"><span class="comment">// 注入用户服务类</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打开请求页面</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 字符串，指向页面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/add"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"add"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增用户</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment"> *            通过<span class="doctag">@RequestBody</span>注解得到JSON参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 回填id后的用户信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/insert"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">insert</span><span class="params">(@RequestBody User user)</span> </span>&#123;</span><br><span class="line">userService.insertUser(user);</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样通过请求add方法，就能请求到对应的HTML表单。接着录入表单，点击提交按钮，这样通过JavaScript脚本提交JSON消息，就可以请求到控制器的insert方法。</p><p>这个方法的参数标注为@RequestBody，意味着它将接收前提交的JSON请求体，而在JSON请求体与User类之间的属性名称是保持一致的，这样SpringMVC就会通过这层映射关系将JSON请求体转换为User对象。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie2to4/1.png" alt=""></p><h4 id="通过URL传递参数"><a href="#通过URL传递参数" class="headerlink" title="通过URL传递参数"></a>通过URL传递参数</h4><p>当然讲到传递参数，之前也提到了以REST风格的方式去传递参数，那么我们在这里就列出来先吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// &#123;...&#125;代表占位符，还可以配置参数名称</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line"><span class="comment">// 响应为JSON数据集</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="comment">// @PathVariable通过名称获取参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">get</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> userService.getUser(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在浏览器中直接输入 user/1 浏览器就会自动将这个 “1” 识别为id的值。</p><h4 id="获取格式化参数"><a href="#获取格式化参数" class="headerlink" title="获取格式化参数"></a>获取格式化参数</h4><p>一些应用中，往往需要格式化数据，其中最为典型的当属日期和货币。例如，在一些系统中日期格式约定为yyyy-MM-dd，金额约定为货币符号和用逗号分隔，如100万美元写作$1,000,000.00等。</p><p>同样地，SpringMVC也对此提供了良好的支持。对日期和数字类型的转换注解进行处理，分别是＠DateTimeFormat和＠NumberFormato其中@DateTimeFormat是针对日期进行格式化的，＠NumberFormat则是针对数字进行格式化的。</p><h5 id="测试日期表单"><a href="#测试日期表单" class="headerlink" title="测试日期表单"></a>测试日期表单</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>格式化<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"./commit"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>日期（yyyy-MM-dd）<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"date"</span> <span class="attr">value</span>=<span class="string">"2017-08-08"</span> /&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>金额（#,###.##）<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"number"</span> <span class="attr">value</span>=<span class="string">"1,234,567.89"</span> /&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span> <span class="attr">align</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>表单中有两个文本框，一个日期，一个金额。</p><h5 id="控制器打开页面和提交"><a href="#控制器打开页面和提交" class="headerlink" title="控制器打开页面和提交"></a>控制器打开页面和提交</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 映射HTML页面</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/form"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">showFormat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"formatter"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取提交参数</span></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/commit"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">format</span><span class="params">(Date date,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  @NumberFormat(pattern = <span class="string">"#,###.##"</span>)</span> Double number) </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; dataMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    dataMap.put(<span class="string">"date"</span>, date);</span><br><span class="line">    dataMap.put(<span class="string">"number"</span>, number);</span><br><span class="line">    <span class="keyword">return</span> dataMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的showFormat方法，是将请求映射到HTML表单上。format方法的代码使用了注解@DateTimeFormat和＠NumberFormat，它们配置了格式化所约定的格式，所以Spring会根据约定的格式把数据转换出来，这样就可以完成参数的转换。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie2to4/2.png" alt=""></p><p>启动SpringBoot后，请求<a href="http://localhost:8080/my/form，就可以看到图所示的表单。" target="_blank" rel="noopener">http://localhost:8080/my/form，就可以看到图所示的表单。</a></p><p>提交表单后，就可以看到对应的JSON数据集输出，这样就可以获取那些格式化的参数了。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie2to4/3.png" alt=""></p><p>在SpringBoot中，日期参数的格式化也可以不使用＠DateTimeFormat，而只在配置文件application.properties中加入如下配置项即可：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.mvc.date-format</span>=<span class="string">yyyy-MM-dd</span></span><br></pre></td></tr></table></figure><h3 id="自定义参数转换规则"><a href="#自定义参数转换规则" class="headerlink" title="自定义参数转换规则"></a>自定义参数转换规则</h3><p>根据上面所表述的内容，我们很容易就能够得出一个规律，传递参数的方法，很多时候仅仅只需要更换不同的注解，就能够实现相应的需求。</p><p>那么这些注解是怎么运作的呢？或者说，SpringMVC所实现的参数转换规则，是怎么样的呢？</p><p>HTTP的请求包含请求头（Header）、请求体CBody）、URL和参数等内容，服务器还包含其上下文环境和客户端交互会话（Session）机制，而这里的消息转换是指请求体的转换。下面我们讨论SpringMVC是如何从这些HTTP请求中获取参数的。</p><h4 id="处理器获取参数逻辑"><a href="#处理器获取参数逻辑" class="headerlink" title="处理器获取参数逻辑"></a>处理器获取参数逻辑</h4><p>一个请求来到时，在处理器执行的过程中，它首先会从HTTP请求和上下文环境来得到参数。如果是简易的参数它会以简单的转换器进行转换，而这些简单的转换器是SpringMVC自身己经提供了的。</p><p>但是如果是转换HTTP请求体（Body），它就会调用HttpMessageConverter接口的方法对请求体的信息进行转换，首先它会先判断能否对请求体进行转换，如果可以就会将其转换为Java类型。以下是对HttpMessageConverter接口的探讨。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpMessageConverter</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    ／／是否可读，其中clazz为Java型，ediaType为HTTP请求类型</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">canRead</span><span class="params">(Class＜?＞ clazz,MediaType mediaType)</span></span>;</span><br><span class="line">    ／／判断clazz类型是否能够转换为mediaT_rpe媒体类型</span><br><span class="line">        ／／其中clazzjava类型，mediaType为HTTP响应类型</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">canWrite</span><span class="params">(Class&lt;?&gt; clazz,MediaType mediaType)</span></span>;</span><br><span class="line">    ／／可支持的媒体类型列表</span><br><span class="line">        <span class="function">List&lt;MediaType&gt; <span class="title">getSupportedMediaTypes</span><span class="params">()</span></span>;</span><br><span class="line">    ／／当canRead验证通过后，读入HTTP求信息</span><br><span class="line">        <span class="function">T <span class="title">read</span><span class="params">(Class&lt;?extendsT&gt; clazz,HttpinputMessage inputMessage)</span> <span class="keyword">throws</span> IOException,HttpMessage NotReadableException</span>;</span><br><span class="line">    ／／当canWrite方法验证通过后，写入响应</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(Tt,MediaType contentType,HttpOutputMessage outputMessage)</span> <span class="keyword">throws</span> IOException,HttpMessage NotWritableException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中控制器方法的参数标注了＠RequestBody，所以处理器会采用请求体（Body）的内容进行参数转换。</p><p>而前端的请求体为JSON类型，所以首先它会调用canRead方法来确定请求体是否可读。</p><p>如果判定可读后，接着就是使用read方法，将前端提交的用户JSON类型的请求体转换为控制器的用户（User）类参数，这样控制器就能够得到参数了。</p><p>上面的HttpMessageConverter接口只是将HTTP的请求体转换为对应的Java对象，而对于HTTP参数和其他内容，还没有进行讨论。</p><p>例如，以性别参数来说前端可能传递给控制器的是一个整数，而控制器参数却是一个枚举，这样就需要提供自定义的参数转换规则。</p><p>为了讨论自定义的参数规则，很有必要先了解处理器转换参数的过程。在SpringMVC中，是通过WebDataBinder机制来获取参数的，它的主要作用是解析HTTP请求的上下文，然后在控制器的调用之前转换参数并且提供验证的功能，为调用控制器方法做准备。</p><p>处理器会从HTTP请求中读取数据，然后通过三种接口来进行各类参数转换，这种接口是Converter、Formatter和GenericConverter。</p><p>在SpringMVC的机制中这三种接口的实现类都采用了注册机的机制，默认的情况下SpringMVC己经在注册机内注册了许多的转换器，这样就可以实现大部分的数据类型的转换，所以在大部分的情况下无须开发者再提供转换器，</p><p>同样地，需要自定义转换规则时，需要在注册机上注册自己的转换器就可以了。</p><p>实际上，WebDataBinder机制还有一个重要的功能，那就是验证转换结果。关于验证机制，后面会再讨论。有了参数的转换和验证，最终控制器就可以得到合法的参数。得到这些参数后，就可以调用控制器的方法了。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/images/1.png" alt=""></p><p>这个图严格来说是请求体转换的全流程，但是有些时候SpringMVC并不会走完全程，而是根据现实情况来处理消息的转换。</p><p>根据上面的讨论，可以看到控制器的参数是处理器通过Convert町、Formatter和GenericConverter这三个接口转换出来的。</p><p>这里先谈谈这三个接口的不同之处。</p><ol><li>首先，Converter是一个普通的转换器，例如，有一个Integer类型的控制器参数，而从HTTP对应的为字符串，对应的Converter就会将字符串转换为Integer类型：</li><li>其次，Formatter则是一个格式化转换器，类似那些日期字符串就是通过它按照约定的格式转换为日期的；</li><li>最后，GenericConverter转换器则将HTTP参数转换为数组。</li></ol><p>这就是上述例子可以通过比较简单的注解就能够得到各类参数的原因。</p><p>对于数据类型转换，SpringMVC提供了→个服务机制去管理，它就是ConversionService接口。在默认的情况下，会使用这个接口的子类DefaultFormattingConversionService对象来管理这些转换类。</p><p>其关系如图所示：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/images/2.png" alt=""></p><p>从图可以看出，Converter、Formatter和GenericConverter可以通过注册机接口进行注册，这样处理器就可以获取对应的转换器来实现参数的转换。上面讨论的是普通SpringMVC的参数转换规则，而在SpringBoot中还提供了特殊的机制来管理这些转换器。SpringBoot的自动配置类WebMvcAutoConfiguration还定义了一个内部类WebMvcAuto­ConfigurationAdapter。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册各类转换器，registry实际为DefaultFormattingConversionService对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFormatters</span><span class="params">(FormatterRegistryregistry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">//遍历IoC容器，找到Converter类型的Bean注册到服务类中</span></span><br><span class="line">        <span class="keyword">for</span>(Converter&lt;?,?&gt; converter:getBeansOfType(Converter<span class="class">.<span class="keyword">class</span>)) </span>&#123; </span><br><span class="line">            registry.addConverter(converter);</span><br><span class="line">     <span class="comment">//遍历IoC容器，找到GenericConverter类型的Bean注册到服务类中</span></span><br><span class="line">         <span class="keyword">for</span>(GenericConverter converter:getBeansOfType(GenericConverter<span class="class">.<span class="keyword">class</span>))</span>&#123;</span><br><span class="line">                    registry.addConverter(converter);</span><br><span class="line">      <span class="comment">//遍历IoC容器，找到Formatter类型的Bean注册到服务类中</span></span><br><span class="line">         <span class="keyword">for</span>(Formatter&lt;?&gt; formatter:getBeansOfType(Formatter<span class="class">.<span class="keyword">class</span>))</span>&#123;</span><br><span class="line">                            registry.addFormatter(formatter);</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中加入了中文注释以利于理解，通过这个方法，可以看到在SpringBoot的初始化中，会将对应用户自定义的Converter、Formatter和GenericConverter的实现类所创建的SpringBean自动地注册到DefaultFormattingConversionService对象中。</p><p>这样对于开发者只需要自定义Converter、Formatter和GenericConverter的接口的Bean,SpringBoot就会通过这个方法将它们注册到ConversionService对象中。只是格式化Formatter接口，在实际开发中使用率比较低，所以不再论述。</p><h4 id="一对一转换器"><a href="#一对一转换器" class="headerlink" title="一对一转换器"></a>一对一转换器</h4><p>Converter是一对一的转化器，也就是从一种类型转换为另外一种类型，其接口定义十分简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">interface</span>  <span class="title">Converter</span>&lt;<span class="title">S</span> ,  <span class="title">T</span>&gt;  </span>&#123;</span><br><span class="line">    <span class="function">T  <span class="title">convert</span><span class="params">(S  source )</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口的类型有源类型CS）和目标类型(T）两种，它们通过conv创方法进行转换。</p><p>例如，HTTP的类型为字符串（String）型，而控制器参数为Long型，那么就可以通过Spring内部提供的StringToNumber&lt;TextendsNumber＞进行转换。</p><p>假设前端要传递一个用户的信息，这个用户信息的格式是｛id}-{userName｝”｛note｝，而控制器的参数是User类对象。</p><p>因为这个格式比较特殊，Spring当前并没有对应的Converter进行转换，因此需要自定义转换器。这里需要的是一个从String转换为User的转换器：</p><h5 id="字符串用户转换器"><a href="#字符串用户转换器" class="headerlink" title="字符串用户转换器"></a>字符串用户转换器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义字符串用户转换器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToUserConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转换方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">convert</span><span class="params">(String userStr)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        String []strArr = userStr.split(<span class="string">"-"</span>);</span><br><span class="line">        Long id = Long.parseLong(strArr[<span class="number">0</span>]);</span><br><span class="line">        String userName = strArr[<span class="number">1</span>];</span><br><span class="line">        String note = strArr[<span class="number">2</span>];</span><br><span class="line">        user.setId(id);</span><br><span class="line">        user.setUserName(userName);</span><br><span class="line">        user.setNote(note);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的类标注为＠Component，并且实现了Converter接口，这样Spring就会将这个类扫描并装配到IoC容器中。对于SpringBoot，之前分析过它会在初始化时把这类自动地注册到转换机制中，所以注册这步并不需要人再处理。这里泛型指定为String和User，这样SpringMVC就会通过HTTP的参数类型（String）和控制器的数类型（User）进行匹配，就可以从注册机制中发现这个转换类，这样就能够将参数转换出来。下面写一个控制器方法对其进行验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/converter"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUserByConverter</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后打开浏览器，输入：<a href="http://localhost:8888/user/converter?user=9-谢广坤-路人" target="_blank" rel="noopener">http://localhost:8888/user/converter?user=9-谢广坤-路人   </a></p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie2to4/4.png" alt=""></p><p>可以发现，我们自动把这个字符串长段，转化为了User对象。</p><h4 id="GenericConverter集合和数组转换"><a href="#GenericConverter集合和数组转换" class="headerlink" title="GenericConverter集合和数组转换"></a>GenericConverter集合和数组转换</h4><p>GenericConverter是数组转换器。因为SpringMVC自身提供了一些数组转换器，需要自定义的不多，所以这里只介绍SpringMVC自定义的数组转换器。</p><p>假设需要同时新增多个用户，这样便需传递一个用户列表（List&lt;User＞）给控制器。此时SpringMVC会使用StringToCollectionConverter转它，这个类实现了GenericConverter接口，并且是SpringVC内部己经注册的数组转换器。</p><p>它首会把字符串用逗号分隔为个个的子宇符串，然后根据原类型泛型为String、目标类型泛型为User。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/list"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">list</span><span class="params">(List&lt;User&gt; userList)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> userList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验方法和上面的一样，多个用户只需要使用逗号隔开就行了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC详解（一）</title>
      <link href="/2020/02/11/spring10/"/>
      <url>/2020/02/11/spring10/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringMVC详解（一）"><a href="#SpringMVC详解（一）" class="headerlink" title="SpringMVC详解（一）"></a>SpringMVC详解（一）</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>SpringMVC就是我们常说的SSM中的“S”。</p><p>SSM（Spring+SpringMVC+MyBatis）框架集由Spring、MyBatis两个开源框架整合而成（SpringMVC是Spring中的部分内容）。常作为数据源较简单的web项目的框架。</p><p>但是现在的SSM也可以看作为是SpringBoot+SpringMVC+MyBatis。毕竟Spring和SpringBoot并不具有本质上的区别，它们的核心IOC和AOP，还是一样的。</p><p>虽然之前在讲使用MyBatis和REST风格的时候，有提到的MVC的使用，但是总体而言并不具体，于是，这次我们就分两篇来说一说SpringMVC的使用和深入。</p><h4 id="SpringMVC框架设计"><a href="#SpringMVC框架设计" class="headerlink" title="SpringMVC框架设计"></a>SpringMVC框架设计</h4><p>先看一下框架流程图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie1/3.png" alt=""></p><p>每当有请求从页面发出来之后，就会从控制层进去，这里的控制层和前端还存在着一定程度的耦合，它们必须要知道各自的请求地址是什么。然后由控制层进入到后端，完成对业务的处理。</p><h3 id="SpringMVC流程"><a href="#SpringMVC流程" class="headerlink" title="SpringMVC流程"></a>SpringMVC流程</h3><h4 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h4><p>SpringMVC的框架设计并不复杂，其实只要多看看程序，稍微思考一下，也很容易的出它们的规律。</p><p>所有SpringMVC最关键的则是它们的内部流程，内部流程被SpringMVC的隐藏，很多时候你知道如何使用了，但是还是不知道内部的细节流程。我们就来学习一下吧。</p><p>流程和组件是SpringMVC的核心，SpringMVC的流程是围绕DispatcherServlet而工作的，所以在SpringMVC中，patcherServlet就其最重要的内容。在DispatcherServlet的基础上，还存在其他的组件，掌握流程和组件就是SpringMVC开发的基础。</p><p>如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie1/4.png" alt=""></p><p>它是SpringMVC运行的全流程，其中图中的阿拉伯数字是其执行的流程，这是SpringMVC开发的基础。但是严格地说，SpringMVC处理请求并非一定需要经过全程，有时候一些流程并不存在。例如，在我们加入＠ResponseBody时，是没有经过视图解析器和视图渲染的。</p><p>这里我们先看一个简单的实例，对这个流程做更进一步论述。首先，在Web服务器启动的过程中，如果在SpringBoot机制下启用SpringMVC，它就开始初始化一些重要的组件，如DispatcherServlet、HandlerAdapter的实现RequestMappingHandlerAdapter等组件对象。关于这些组件的初始化，我们可以看到spring-webmvc-xxx.jar包的属性文件DispatcherServlet.properti，它定义的对象都是在SpringMVC开始时就初始化，并且存放在SpringIoC容器中。</p><h4 id="DispatcherServlet-properties"><a href="#DispatcherServlet-properties" class="headerlink" title="DispatcherServlet.properties"></a>DispatcherServlet.properties</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#国际化解析器</span></span><br><span class="line"><span class="meta">org.springframework.web.servlet.LocaleResolver</span> = <span class="string">org . springframework.web.servlet.ilBn.AcceptHeade rLocaleResolver</span></span><br><span class="line"><span class="comment">#主题解析器</span></span><br><span class="line"><span class="meta">org.springframework.web.servlet.ThemeResolver</span>=<span class="string">org.springframework.web.servlet.theme.FixedThemeResolver</span></span><br><span class="line"><span class="comment">#handlerMapping实例</span></span><br><span class="line"><span class="meta">org.springframework.web.servlet.HandlerMapping</span>=<span class="string">org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping</span></span><br><span class="line"><span class="comment">#处理器实例</span></span><br><span class="line"><span class="meta">org.springframework.web.servlet.HandlerAdapter</span>=<span class="string">org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter</span></span><br><span class="line"><span class="comment">#处理器异常解析器</span></span><br><span class="line"><span class="meta">org.springframework.web.servlet.HandlerExceptionResolver</span>=<span class="string">org. springframework.web.servlet.mvc.method.annotation.ExceptionH andlerExceptionResolver</span></span><br><span class="line"><span class="meta">＃策略视图名称转换器，当你没有返回视图逻辑名称的时候，通过它可以生成默认的视图名称org.springframework.web.servlet.RequestToViewNameTranslator</span>=<span class="string">org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator</span></span><br><span class="line"><span class="meta">＃视图解析器org.springframework.web.servlet.ViewResolver</span>=<span class="string">org.springframework.web.servlet.view.InternalResource飞liewResolver</span></span><br></pre></td></tr></table></figure><h4 id="基础依赖"><a href="#基础依赖" class="headerlink" title="基础依赖"></a>基础依赖</h4><p>我们在这里把所有基础依赖列出来，方便实验：</p><h5 id="yml"><a href="#yml" class="headerlink" title="yml"></a>yml</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:/mapper/*.xml</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.example.springmvc.pojo</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8888</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/springtest?useSSL=false&amp;serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">tomcat:</span></span><br><span class="line">      <span class="attr">max-idle:</span> <span class="number">10</span></span><br><span class="line">      <span class="attr">max-wait:</span> <span class="number">10000</span></span><br><span class="line">      <span class="attr">max-active:</span> <span class="number">50</span></span><br><span class="line">      <span class="attr">initial-size:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/static/**</span></span><br></pre></td></tr></table></figure><h5 id="dao"><a href="#dao" class="headerlink" title="dao"></a>dao</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">User <span class="title">getUser</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findUsers</span><span class="params">(@Param(<span class="string">"userName"</span>)</span> String userName, @<span class="title">Param</span><span class="params">(<span class="string">"note"</span>)</span> String note)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> userDao.getUser(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUsers</span><span class="params">(String userName, String note)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> userDao.findUsers(userName, note);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">User <span class="title">getUser</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findUsers</span><span class="params">(String userName, String note)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.example.springmvc.dao.UserDao"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUser"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">select id, user_name as userName, note from t_user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUsers"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">   select id, user_name as userName, note from t_user</span><br><span class="line">   <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userName != null"</span>&gt;</span> and user_name like concat('%', #&#123;userName&#125;, '%')<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"note != null"</span>&gt;</span> and note like concat('%', #&#123;note&#125;, '%')<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span></span></span><br></pre></td></tr></table></figure><h4 id="步骤详解"><a href="#步骤详解" class="headerlink" title="步骤详解"></a>步骤详解</h4><p>现在开始一步步的去解释这它们的运行流程。</p><p>首先需要一个控制层的控制器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/details"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">detailsForJson</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 访问模型层得到数据</span></span><br><span class="line">        User user = userService.getUser(id);</span><br><span class="line">        System.out.println(user.getId());</span><br><span class="line">        <span class="comment">// 模型和视图</span></span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        mv.setViewName(<span class="string">"details"</span>);</span><br><span class="line">        <span class="comment">// 加入模型</span></span><br><span class="line">        mv.addObject(<span class="string">"user"</span>, user);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里的注解＠Controller表明这是一个控制器，然后＠RequestMapping代表请求路径和控制器（或其方法）的映射关系，它会在Web服务器启动SpringMVC时，就被扫描到HandlerMapping的机制中存储。</p><p>之后在用户发起请求被DispatcherServlet拦截后，通过URL和其他的条件，通过HandlerMapper机制就能找到对应的控制器（或其方法）进行响应。</p><p>只是通过HandlerMapping返回的是一个HandlerExecutionChain对象，这个对象的源码如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerExecutionChain</span> </span>&#123;</span><br><span class="line">    <span class="comment">//日志</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(HandlerExecutionChain<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">//处理器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object handler;</span><br><span class="line">    <span class="comment">//拦截器数组</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> HandlerInterceptor[] interceptors;</span><br><span class="line">    <span class="comment">//拦截器列表</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;HandlerInterceptor&gt; interceptorList;</span><br><span class="line">    <span class="comment">//拦截器下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> interceptorIndex;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码中可以看出，HandlerExecutionChain对象包含个处理器（handler）。这里的处理器是对控制器（controller）的包装，因为我们的控制器方法可能存在参数，那么处理器就可以读入HTTP和上下文的相关参数，然后再传递给控制器方法。</p><p>而在控制器执行完成返回后，处理器又可以通过配置信息对控制器的返回结果进行处理。从这段描述中可以看出，处理器包含了控制器方法的逻辑，此外还有处理器的拦截器（interceptor），这样就能够通过拦截处理器进一步地增强处理器的功能得到了处理器（handler），还需要去运行，但是我们有普通HTTP请求，也有按BeanName的请求，甚至是WebSocket的请求，所以它还需要一个适配器去运行HandlerExecutionChain对象包含的处理器，这就是HandlerAdapter接口定义的实现类。</p><p>在DispatcherServlet.properties中，我们可以看到在SpringMVC中最常用的HandlerAdapter的实现类，这便是HttpRequestHandlerAdaptero通过请求的类型，DispatcherServlet就会找到它来执行Web请求的HandlerExecutionChain对象包含的内，这样就能够执行我们的处理器（handler）了。</p><p>只是HandlerAdapter运行HandlerExecutionChain对象这还比较复杂，我们这里暂时不进行深入讨论，放到后面再谈。</p><p>在处理器调用控制器时，它首先通过模型层得到数据，再放入数据模型中，最后将返回模型和视图（ModelAndView）对象，这里控制器设置的视图名称设置为“user/details”，这样就走到了视图解析器（ViewResolver），去解析视图逻辑名称了。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>需要一个页面，使用thymeleaf语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>  <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>标签<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>值<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>用户编号<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.id&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>用户名称<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.userName&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>用户备注<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.note&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>好了，开始测试吧：</p><p>效果图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie1/1.png" alt=""></p><p>测试结果貌似不能直接说明出什么，我们再根据一张图，将它们结合到一起去理解它们是怎么运行的：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie1/5.png" alt=""></p><p>这便是它们的运行步骤。这里有添加jsp视图映射，但是我们使用的是thymeleaf，所以不会过度理会第五步，由于找不到合适的图，拿这个代替一下。</p><h4 id="JSON视图"><a href="#JSON视图" class="headerlink" title="JSON视图"></a>JSON视图</h4><p>我们知道，一般前端的需求都是JSON 数据，这里是通过了SpringMVC的内置机制，自动将它转化为的JSON视图，我们可以自己定义转换为JSON数据，来保证不会出错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/detailsForJson"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">detailsForJson</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 访问模型层得到数据</span></span><br><span class="line">    User user = userService.getUser(id);</span><br><span class="line">    <span class="comment">// 模型和视图</span></span><br><span class="line">    ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    <span class="comment">// 生成JSON视图</span></span><br><span class="line">    MappingJackson2JsonView jsonView = <span class="keyword">new</span> MappingJackson2JsonView();</span><br><span class="line">    mv.setView(jsonView);</span><br><span class="line">    <span class="comment">// 加入模型</span></span><br><span class="line">    mv.addObject(<span class="string">"user"</span>, user);</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果也如图所示：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie1/6.png" alt=""></p><h4 id="定制SpringMVC初始化"><a href="#定制SpringMVC初始化" class="headerlink" title="定制SpringMVC初始化"></a>定制SpringMVC初始化</h4><p>如SpringBoot所承诺的那样，它会尽可能地配置Spring，对于SpringMVC也是如此，但是无论如何这些配置都可能满足不了我们的需要，需要进一步地对SpringMVC定制。</p><p>在S巳rvlet3.0范中，web刀nl再也不是一个必需的配置文件。为了适应这个规范，SpringMVC从3.1版本开始也进行了支持，也就是我们已经不再需要通过任何XML去配置SpringMVC的运行环境，正如SpringBoot的宗旨，消除XML的繁杂配置。</p><p>为了支持对于SpringMVC的配置，Spring提供了接口WebMvcConfigurer这是一个基于Java8的接口，所以其大部分方法都是default类型的，但是它们都是空实现，这样开发者只需要实现这个接口，重写需要自定义的方法即可，这样就很方便进行开发了。</p><p>在SpringBoot中，自定义是通过配置类WebMvcAutoConfiguration定义的，它有一个静态的内部类WebMvcAutoConfigurationAdapter通过它SpringBoot就自动配置了SpringMVC的初始化，如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie1/7.png" alt=""></p><h4 id="SpringMVC可配置项"><a href="#SpringMVC可配置项" class="headerlink" title="SpringMVC可配置项"></a>SpringMVC可配置项</h4><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie1/2.png" alt=""></p><p>这些配置项将会被SpringBoot的机制读入，然后使用ebMvcAutoConfigurationAdapter去定制初始化。</p><p>一般而言，我们只需要配置少数的选项就能够使得SpringMVC工作了。</p><h3 id="SpringMVC实例"><a href="#SpringMVC实例" class="headerlink" title="SpringMVC实例"></a>SpringMVC实例</h3><p>在SpringBoot中开发SpringMVC还是比较简易的，正如之前我们的例子，SpringVC的开发核心是控制器的开发，控制器的开发又分为这么几个步骤，首先是定义请求分发，SpringMVC能够产生HandlerMapping,其次是接收请求获取参数，再次是处理业务逻辑获取数据模型，最后是绑定视图和数据模型。</p><p>视图将数据模型渲染则是视图定义的问题，不属于控制器开发的步骤。</p><p>下面我们演示一个用户列表查询的界面。假设可以通过用户名称CuserName）和备注（note)进行查询，但是一开始进入页面需要载入所有的数据展示给用户查看。</p><p>这里分为两种常见的场景，一种是刚进入页面时，一般来说是不允许存在异步请求的，因为异步请求会造成数据的刷新，对用户不友好：另一种是进入页面后的查询，这时可以考虑使用Ajax异步请求，只刷新数据而不刷新页面，这才是良好的UI体验设计。</p><h4 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h4><p>贴出控制层代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.springmvc.pojo.User;</span><br><span class="line"><span class="keyword">import</span> com.example.springmvc.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.view.json.MappingJackson2JsonView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/details"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">details</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 访问模型层得到数据</span></span><br><span class="line">        User user = userService.getUser(id);</span><br><span class="line">        <span class="comment">// 模型和视图</span></span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        mv.setViewName(<span class="string">"details"</span>);</span><br><span class="line">        <span class="comment">// 加入模型</span></span><br><span class="line">        mv.addObject(<span class="string">"user"</span>, user);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/detailsForJson"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">detailsForJson</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 访问模型层得到数据</span></span><br><span class="line">        User user = userService.getUser(id);</span><br><span class="line">        <span class="comment">// 模型和视图</span></span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        <span class="comment">// 生成JSON视图</span></span><br><span class="line">        MappingJackson2JsonView jsonView = <span class="keyword">new</span> MappingJackson2JsonView();</span><br><span class="line">        mv.setView(jsonView);</span><br><span class="line">        <span class="comment">// 加入模型</span></span><br><span class="line">        mv.addObject(<span class="string">"user"</span>, user);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/table"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">table</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 访问模型层得到数据</span></span><br><span class="line">        List&lt;User&gt; userList = userService.findUsers(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 模型和视图</span></span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        <span class="comment">// 定义模型视图</span></span><br><span class="line">        mv.setViewName(<span class="string">"table"</span>);</span><br><span class="line">        <span class="comment">// 加入数据模型</span></span><br><span class="line">        mv.addObject(<span class="string">"userList"</span>, userList);</span><br><span class="line">        <span class="comment">// 返回模型和视图</span></span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/list"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">list</span><span class="params">(@RequestParam(value = <span class="string">"userName"</span>, required = <span class="keyword">false</span>)</span> String userName,</span></span><br><span class="line"><span class="function">                           @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"note"</span>, required = <span class="keyword">false</span>)</span> String note) </span>&#123;</span><br><span class="line">        <span class="comment">// 访问模型层得到数据</span></span><br><span class="line">        List&lt;User&gt; userList = userService.findUsers(userName, note);</span><br><span class="line">        <span class="keyword">return</span> userList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是控制层，其实并没有什新的东西，按照已有的知识重复写就能够写出来。</p><h4 id="Html页面"><a href="#Html页面" class="headerlink" title="Html页面"></a>Html页面</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>用户列表<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">href</span>=<span class="string">"../static/easyui/themes/default/easyui.css"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">href</span>=<span class="string">"../static/easyui/themes/icon.css"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"../static/easyui/demo/demo.css"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"../static/easyui/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"../static/easyui/jquery.easyui.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 定义事件方法</span></span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">onSearch</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 指定请求路径</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> opts = $(<span class="string">'#dg'</span>).datagrid(<span class="string">"options"</span>);</span></span><br><span class="line"><span class="actionscript">            opts.url = <span class="string">"./list"</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 获取查询参数</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> userName = $(<span class="string">"#userName"</span>).val();</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> note = $(<span class="string">"#note"</span>).val();</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 组织参数</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> params = &#123;&#125;;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (userName != <span class="literal">null</span> &amp;&amp; userName.trim() != <span class="string">''</span>) &#123;</span></span><br><span class="line">                params.userName = userName;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (note != <span class="literal">null</span> &amp;&amp; note.trim() != <span class="string">''</span>) &#123;</span></span><br><span class="line">                params.note = note;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="comment">// 重新载入表格数据</span></span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#dg"</span>).datagrid(<span class="string">'load'</span>, params);</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin: 20px 0;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"easyui-layout"</span> <span class="attr">style</span>=<span class="string">"width: 100%; height: 350px;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">data-options</span>=<span class="string">"region:'north'"</span> <span class="attr">style</span>=<span class="string">"height: 50px"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"searchForm"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>用户名称：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"userName"</span> <span class="attr">name</span>=<span class="string">"userName"</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">class</span>=<span class="string">"easyui-textbox"</span> <span class="attr">data-options</span>=<span class="string">"prompt:'输入用户名称...'"</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">style</span>=<span class="string">"width: 100%; height: 32px"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>备注<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"note"</span> <span class="attr">name</span>=<span class="string">"note"</span> <span class="attr">class</span>=<span class="string">"easyui-textbox"</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">data-options</span>=<span class="string">"prompt:'输入备注...'"</span> <span class="attr">style</span>=<span class="string">"width: 100%; height: 32px"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">class</span>=<span class="string">"easyui-linkbutton"</span></span></span><br><span class="line"><span class="tag">                           <span class="attr">data-options</span>=<span class="string">"iconCls:'icon-search'"</span> <span class="attr">style</span>=<span class="string">"width: 80px"</span></span></span><br><span class="line"><span class="tag">                           <span class="attr">onclick</span>=<span class="string">"onSearch()"</span>&gt;</span>查询<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">data-options</span>=<span class="string">"region:'center',title:'用户列表',iconCls:'icon-ok'"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">"dg"</span> <span class="attr">class</span>=<span class="string">"easyui-datagrid"</span></span></span><br><span class="line"><span class="tag">               ,</span></span><br><span class="line"><span class="tag">               <span class="attr">data-options</span>=<span class="string">"border:false,singleSelect:true,</span></span></span><br><span class="line"><span class="tag"><span class="string">fit:true,fitColumns:true"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span> <span class="attr">data-options</span>=<span class="string">"field:'id'"</span> <span class="attr">width</span>=<span class="string">"80"</span>&gt;</span>编号<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span> <span class="attr">data-options</span>=<span class="string">"field:'userName'"</span> <span class="attr">width</span>=<span class="string">"100"</span>&gt;</span>用户名称<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span> <span class="attr">data-options</span>=<span class="string">"field:'note'"</span> <span class="attr">width</span>=<span class="string">"80"</span>&gt;</span>备注<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--使用forEache渲染数据模型--&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">"u:$&#123;userList&#125;"</span> &gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;u.id&#125;"</span>&gt;</span>id<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;u.userName&#125;"</span>&gt;</span>userName<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;u.note&#125;"</span>&gt;</span>note<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>页面中还定义了两个文本框，用来输入用户名和各注，然后通过查询按钮进行询。这里查询按钮的点击事件定义为onSearch，这样就能够找到onSearch函数来执行查询。</p><p>在这个函数中，首先定义DataGrid请求的URL，它指向了list方法，然后通过jQuery去获取两个文本框的参数值，再通过DataGrid的load方法，传递参数去后端查询，得到数据后重新载入DataGrid的数据，这样DataGrid就能够得到查询的数据了。</p><p>再看回list方法。首先它标注为了＠ResponseBody，这样SpringMVC就道最终需要把返回的结果转换为JSON。然后是获取参数，这里使用了注解＠RequestParam，通过指定参数名称使得HTTP请求的参数和方法的参数进行绑定，只是这个注解的默认规则是参数不能为空。为了克服这个问题，代码将其属性required设置为false即可，其意义就是允许参数为空。这样就可以测试这个请求了</p><p>最后再测试一下吧：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/SpringMVC/xiangjie1/8.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot整合WebSocket</title>
      <link href="/2020/02/10/spring9/"/>
      <url>/2020/02/10/spring9/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot整合WebSocket"><a href="#SpringBoot整合WebSocket" class="headerlink" title="SpringBoot整合WebSocket"></a>SpringBoot整合WebSocket</h2><p>”人不是一座孤岛，所有人的不幸皆是我的不幸“——出处未知</p><p>人不是一个喜欢独立个体，在上个世纪有短信，这个世纪有微信，可见，沟通在人们中占据了多么重要的地位，而我们今天，就来使用WebSocket，来打造一个聊天室。</p><p>在此之前，我想先说说WebJars，你如果明白，也可以直接跳到WebSocket。</p><h3 id="WebJars"><a href="#WebJars" class="headerlink" title="WebJars"></a>WebJars</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>什么是WebJars？WebJars是将客户端（浏览器）资源（JavaScript，Css等）打成jar包文件，以对资源进行统一依赖管理。WebJars的jar包部署在Maven中央仓库上。</p><h4 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h4><p>我们在开发Java web项目的时候会使用像Maven，Gradle等构建工具以实现对jar包版本依赖管理，以及项目的自动化管理，但是对于JavaScript，Css等前端资源包，我们只能采用拷贝到webapp目录下的手工方式，这样做就无法对这些资源进行依赖管理。而且容易导致文件混乱、版本不一致等问题。那么WebJars就提供给我们这些前端资源的jar包形式，我们就可以进行依赖管理。</p><p>WebJars是将这些通用的Web前端资源打包成Java的Jar包，然后借助Maven工具对其管理，保证这些Web资源版本唯一性，升级也比较容易。关于webjars资源，有一个专门的网站<a href="http://www.webjars.org/，我们可以到这个网站上找到自己需要的资源，在自己的工程中添加入maven依赖，即可直接使用这些资源了。" target="_blank" rel="noopener">http://www.webjars.org/，我们可以到这个网站上找到自己需要的资源，在自己的工程中添加入maven依赖，即可直接使用这些资源了。</a></p><h4 id="怎么样"><a href="#怎么样" class="headerlink" title="怎么样"></a>怎么样</h4><p>可以在pom文件中引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">&lt;!--Webjars版本定位工具--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>webjars-locator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        Webjars的一个包，有各种资源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars.npm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mdui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        wenjars的JQ库--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jquery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有了它们，就能够在Html页面上引入它们，就能够直接使用它们的样式和语法，节省了很多开发所需的依赖，使得我们前端引入更为方便。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/webjars/mdui/dist/css/mdui.css&#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">th:src</span>=<span class="string">"@&#123;/webjars/jquery/jquery.min.js&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">th:src</span>=<span class="string">"@&#123;/webjars/mdui/dist/js/mdui.js&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用Thymeleaf语法进行引用，这里是世界引用 /webjars的目录。</p><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>现在，就来正式的讲一下，WebSocket的使用吧。</p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>WebSocket是一种与<a href="https://zh.wikipedia.org/wiki/超文本传输协议" target="_blank" rel="noopener">HTTP</a>不同的协议。两者都位于<a href="https://zh.wikipedia.org/wiki/OSI模型" target="_blank" rel="noopener">OSI模型</a>的<a href="https://zh.wikipedia.org/wiki/应用层" target="_blank" rel="noopener">应用层</a>，并且都依赖于<a href="https://zh.wikipedia.org/wiki/传输层" target="_blank" rel="noopener">传输层</a>的TCP协议。 虽然它们不同，但RFC 6455规定：“WebSocket设计为通过80和443端口工作，以及支持HTTP代理和中介”，从而使其与HTTP协议兼容。 为了实现兼容性，WebSocket握手使用HTTP Upgrade头从HTTP协议更改为WebSocket协议。</p><p>WebSocket协议支持Web<a href="https://zh.wikipedia.org/wiki/浏览器" target="_blank" rel="noopener">浏览器</a>（或其他客户端应用程序）与Web<a href="https://zh.wikipedia.org/wiki/服务器" target="_blank" rel="noopener">服务器</a>之间的交互，具有较低的开销，便于实现客户端与服务器的实时数据传输。 服务器可以通过标准化的方式来实现，而无需客户端首先请求内容，并允许消息在保持连接打开的同时来回传递。通过这种方式，可以在客户端和服务器之间进行双向持续对话。 通信通过TCP端口80或443完成，这在防火墙阻止非Web网络连接的环境下是有益的。另外，<a href="https://zh.wikipedia.org/wiki/Comet_(web技术)" target="_blank" rel="noopener">Comet</a>之类的技术以非标准化的方式实现了类似的双向通信。</p><p>大多数浏览器都支持该协议，包括<a href="https://zh.wikipedia.org/wiki/Google_Chrome" target="_blank" rel="noopener">Google Chrome</a>、<a href="https://zh.wikipedia.org/wiki/Firefox" target="_blank" rel="noopener">Firefox</a>、<a href="https://zh.wikipedia.org/wiki/Safari" target="_blank" rel="noopener">Safari</a>、<a href="https://zh.wikipedia.org/wiki/Microsoft_Edge" target="_blank" rel="noopener">Microsoft Edge</a>、<a href="https://zh.wikipedia.org/wiki/Internet_Explorer" target="_blank" rel="noopener">Internet Explorer</a>和<a href="https://zh.wikipedia.org/wiki/Opera瀏覽器" target="_blank" rel="noopener">Opera</a>。</p><p>与HTTP不同，WebSocket提供全双工通信。此外，WebSocket还可以在TCP之上启用消息流。TCP单独处理字节流，没有固有的消息概念。 在WebSocket之前，使用Comet可以实现全双工通信。但是Comet存在TCP握手和HTTP头的开销，因此对于小消息来说效率很低。WebSocket协议旨在解决这些问题。</p><p>WebSocket协议规范将<code>ws</code>（WebSocket）和<code>wss</code>（WebSocket Secure）定义为两个新的<a href="https://zh.wikipedia.org/wiki/統一資源標識符" target="_blank" rel="noopener">统一资源标识符</a>（URI）方案，分别对应明文和加密连接。除了方案名称和片段ID（不支持<code>#</code>）之外，其余的URI组件都被定义为此URI的通用语法。</p><p>使用浏览器开发人员工具，开发人员可以检查WebSocket握手以及WebSocket框架</p><h5 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h5><p>WebSocket最初在<a href="https://zh.wikipedia.org/wiki/HTML5" target="_blank" rel="noopener">HTML5</a>规范中被引用为TCPConnection，作为基于TCP的套接字API的占位符。2008年6月，<a href="https://zh.wikipedia.org/w/index.php?title=Michael_Carter&action=edit&redlink=1" target="_blank" rel="noopener">Michael Carter</a>进行了一系列讨论，最终形成了称为WebSocket的协议。</p><p>“WebSocket”这个名字是Ian Hickson和Michael Carter之后在 #whatwg IRC聊天室创造的，随后由Ian Hickson撰写并列入HTML5规范，并在Michael Carter的Cometdaily博客上宣布。 2009年12月，Google Chrome 4是第一个提供标准支持的浏览器，默认情况下启用了WebSocket。协议的开发随后于2010年2月从W3C和WHATWG小组转移到IETF，并在Ian Hickson的指导下进行了两次修订。</p><p>该协议被多个浏览器默认支持并启用后，<a href="https://zh.wikipedia.org/wiki/RFC" target="_blank" rel="noopener">RFC</a>于2011年12月在Ian Fette下完成。</p><h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><p>早期，很多网站为了实现<a href="https://zh.wikipedia.org/wiki/推送技术" target="_blank" rel="noopener">推送技术</a>，所用的技术都是<a href="https://zh.wikipedia.org/wiki/輪詢" target="_blank" rel="noopener">轮询</a>。轮询是在特定的的时间间隔（如每秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的<a href="https://zh.wikipedia.org/wiki/HTTP头字段列表" target="_blank" rel="noopener">头部</a>，其中真正有效的数据可能只是很小的一部分，显然这样会消耗很多的带宽资源。</p><p>比较新的轮询技术是<a href="https://zh.wikipedia.org/wiki/Comet_(web技术)" target="_blank" rel="noopener">Comet</a>。这种技术虽然可以实现双向通信，但仍然需要反复发出请求。而且在Comet中普遍采用的<a href="https://zh.wikipedia.org/wiki/HTTP持久链接" target="_blank" rel="noopener">HTTP长连接</a>也会消耗服务器资源。</p><p>在这种情况下，<a href="https://zh.wikipedia.org/wiki/HTML5" target="_blank" rel="noopener">HTML5</a>定义了WebSocket协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。</p><p>Websocket使用<code>ws</code>或<code>wss</code>的<a href="https://zh.wikipedia.org/wiki/统一资源标志符" target="_blank" rel="noopener">统一资源标志符</a>，类似于<a href="https://zh.wikipedia.org/wiki/HTTPS" target="_blank" rel="noopener">HTTPS</a>。其中<code>wss</code>表示使用了<a href="https://zh.wikipedia.org/wiki/TLS" target="_blank" rel="noopener">TLS</a>的Websocket。如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ws://example.com/wsapi</span><br><span class="line">wss://secure.example.com/wsapi</span><br></pre></td></tr></table></figure><p>Websocket与HTTP和HTTPS使用相同的TCP<a href="https://zh.wikipedia.org/wiki/TCP/UDP端口列表" target="_blank" rel="noopener">端口</a>，可以绕过大多数<a href="https://zh.wikipedia.org/wiki/防火墙" target="_blank" rel="noopener">防火墙</a>的限制。默认情况下，Websocket协议使用80端口；运行在TLS之上时，默认使用443端口。</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li><p>较少的控制开销。在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2至10<a href="https://zh.wikipedia.org/wiki/字节" target="_blank" rel="noopener">字节</a>（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的4字节的<a href="https://zh.wikipedia.org/wiki/掩码" target="_blank" rel="noopener">掩码</a>。相对于HTTP请求每次都要携带完整的头部，此项开销显著减少了。</p></li><li><p>更强的实时性。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和Comet等类似的<a href="https://zh.wikipedia.org/w/index.php?title=长轮询&action=edit&redlink=1" target="_blank" rel="noopener">长轮询</a>比较，其也能在短时间内更多次地传递数据。</p></li><li><p>保持连接状态。与HTTP不同的是，Websocket需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。</p></li><li><p>更好的二进制支持。Websocket定义了<a href="https://zh.wikipedia.org/wiki/二进制" target="_blank" rel="noopener">二进制</a>帧，相对HTTP，可以更轻松地处理二进制内容。</p></li><li><p>可以支持扩展。Websocket定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持<a href="https://zh.wikipedia.org/wiki/数据压缩" target="_blank" rel="noopener">压缩</a>等。</p></li><li><p>更好的压缩效果。相对于<a href="https://zh.wikipedia.org/wiki/HTTP压缩" target="_blank" rel="noopener">HTTP压缩</a>，Websocket在适当的扩展支持下，可以沿用之前内容的<a href="https://zh.wikipedia.org/wiki/上下文" target="_blank" rel="noopener">上下文</a>，在传递类似的数据时，可以显著地提高压缩率。</p></li></ul><h5 id="握手协议"><a href="#握手协议" class="headerlink" title="握手协议"></a>握手协议</h5><p>WebSocket 是独立的、创建在 TCP 上的协议。</p><p>Websocket 通过 <a href="https://zh.wikipedia.org/wiki/HTTP" target="_blank" rel="noopener">HTTP</a>/1.1 协议的101<a href="https://zh.wikipedia.org/wiki/HTTP状态码" target="_blank" rel="noopener">状态码</a>进行握手。</p><p>为了创建Websocket连接，需要通过浏览器发出请求，之后服务器进行回应，这个过程通常称为“<a href="https://zh.wikipedia.org/wiki/握手_(技术)" target="_blank" rel="noopener">握手</a>”（handshaking）。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/webSocket/1.png" alt=""></p><h4 id="Spring-WebSocket-解析"><a href="#Spring-WebSocket-解析" class="headerlink" title="Spring WebSocket 解析"></a>Spring WebSocket 解析</h4><h5 id="依赖引入"><a href="#依赖引入" class="headerlink" title="依赖引入"></a>依赖引入</h5><p>SpringBoot有自带的WebSocket API，我们在使用WebSocket的时候，可以直接引入这个依赖，也可以手动引入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="创建服务器端点"><a href="#创建服务器端点" class="headerlink" title="创建服务器端点"></a>创建服务器端点</h5><p>开启WebSocket服务端的自动注册。</p><p>在对WebSocket的使用中，可以先通过Spring创建Java配置文件。在这个文件中，先新建ServerEndpointExporter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerEndpointExporter <span class="title">serverEndpointExporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServerEndpointExporter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个Bean，就可以使用@ServerEndpoint定义一个端点服务类。在这个站点服务类中，还可以定义WebSocket的打开，关闭，错误和发送消息方法。</p><p>ServerEndpointExporter 是由Spring官方提供的标准实现，用于扫描ServerEndpointConfig配置类和@ServerEndpoint注解实例。使用规则也很简单：1.如果使用默认的嵌入式容器 比如Tomcat 则必须手工在上下文提供ServerEndpointExporter。2. 如果使用外部容器部署war包，则不要提供提供ServerEndpointExporter，因为此时SpringBoot默认将扫描服务端的行为交给外部容器处理。</p><h5 id="ServerEndpoint"><a href="#ServerEndpoint" class="headerlink" title="ServerEndpoint"></a>ServerEndpoint</h5><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="meta">@ServerEndpoint</span>(<span class="string">"/ws"</span>)</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketServiceImpl</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> onlineCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// concurrent包的线程安全Set，用来存放每个客户端对应的WebSocketServiceImpl对象。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CopyOnWriteArraySet&lt;WebSocketServiceImpl&gt; </span><br><span class="line">            webSocketSet = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line">    <span class="comment">// 与某个客户端的连接会话，需要通过它来给客户端发送数据</span></span><br><span class="line">    <span class="keyword">private</span> Session session;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接建立成功调用的方法*/</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.session = session;</span><br><span class="line">        webSocketSet.add(<span class="keyword">this</span>);     <span class="comment">// 加入set中</span></span><br><span class="line">        addOnlineCount();           <span class="comment">// 在线数加1</span></span><br><span class="line">        System.out.println(<span class="string">"有新连接加入！当前在线人数为"</span> + getOnlineCount());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sendMessage(<span class="string">"有新的连接加入了！！"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"IO异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接关闭调用的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        webSocketSet.remove(<span class="keyword">this</span>);  <span class="comment">// 从set中删除</span></span><br><span class="line">        subOnlineCount();           <span class="comment">// 在线数减1</span></span><br><span class="line">        System.out.println(<span class="string">"有一连接关闭！当前在线人数为"</span> + getOnlineCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收到客户端消息后调用的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 客户端发送过来的消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String message, Session session)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"来自客户端的消息:"</span> + message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 群发消息</span></span><br><span class="line">        <span class="keyword">for</span> (WebSocketServiceImpl item : webSocketSet) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                // 获取当前用户名称</span></span><br><span class="line"><span class="comment">                String userName = item.getSession()</span></span><br><span class="line"><span class="comment">                        .getUserPrincipal().getName();</span></span><br><span class="line"><span class="comment">                System.out.println(userName);</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                item.sendMessage(message); </span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发生错误时调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Session session, Throwable error)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"发生错误"</span>);</span><br><span class="line">        error.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 客户端消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.session.getBasicRemote().sendText(message);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 返回在线数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getOnlineCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> onlineCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当连接人数增加时</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addOnlineCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WebSocketServiceImpl.onlineCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当连接人数减少时</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">subOnlineCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WebSocketServiceImpl.onlineCount--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是通过注解@OnOpen、@OnMessage、@OnClose、@OnError 来声明回调函数。</p><h5 id="回调函数将由JavaScript处理"><a href="#回调函数将由JavaScript处理" class="headerlink" title="回调函数将由JavaScript处理"></a>回调函数将由JavaScript处理</h5><p>回调函数将会被前端的JavaScript所使用，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> websocket = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 判断当前浏览器是否支持WebSocket</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">'WebSocket'</span> <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line"><span class="comment">// 创建WebSocket对象,连接服务器端点</span></span><br><span class="line">websocket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://localhost:8888/ws"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">alert(<span class="string">'Not support websocket'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接发生错误的回调方法</span></span><br><span class="line">websocket.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">appendMessage(<span class="string">"error"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接成功建立的回调方法</span></span><br><span class="line">websocket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">appendMessage(<span class="string">"open"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收到消息的回调方法</span></span><br><span class="line">websocket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">appendMessage(event.data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接关闭的回调方法</span></span><br><span class="line">websocket.onclose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">appendMessage(<span class="string">"close"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，</span></span><br><span class="line"><span class="comment">// 防止连接还没断开就关闭窗口，server端会抛异常。</span></span><br><span class="line"><span class="built_in">window</span>.onbeforeunload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">websocket.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将消息显示在网页上</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">appendMessage</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> context = $(<span class="string">"#context"</span>).html() +<span class="string">"&lt;br/&gt;"</span> + message;</span><br><span class="line">$(<span class="string">"#context"</span>).html(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭连接</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">closeWebSocket</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">websocket.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendMessage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> message = $(<span class="string">"#message"</span>).val();</span><br><span class="line">websocket.send(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意看清楚大小写，这里的 webSocket是利用了在后端所声明的WebSocket对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> webSocket = <span class="keyword">new</span> WebSocket(url);</span><br></pre></td></tr></table></figure><p>而 webSocket这个JS实例将能够调用回调函数，就如onmessage而言：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">websocket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">appendMessage(event.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能通过 （event），来获取到后端传进来的值。</p><p>那么值是从哪里被传进去的呢？</p><p>请看HTML页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    测试一下WebSocket站点吧</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"message"</span> <span class="attr">type</span>=<span class="string">"text"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"sendMessage()"</span>&gt;</span>发送消息<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"closeWebSocket()"</span>&gt;</span>关闭WebSocket连接<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"context"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里所只使用的 onclick=”sendMessage()” 正是在调用JS函数，而这个JS函数就是上面所提及的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendMessage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> message = $(<span class="string">"#message"</span>).val();</span><br><span class="line">websocket.send(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它会将文本框中的message的值，通过 send(message)，发送到后端处理，由后端标注的@OnMessage函数处理完后，再被JS函数 websocket.onmessage = function(event) 所接收。</p><p>至于如何展示在页面上，则是由：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将消息显示在网页上</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">appendMessage</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> context = $(<span class="string">"#context"</span>).html() +<span class="string">"&lt;br/&gt;"</span> + message;</span><br><span class="line">$(<span class="string">"#context"</span>).html(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所决定的了。</p><p>当然，根据不同的情况，JS的代码可以被自行设计，所以这些代码仅供参考。我们必须记牢的，就是注解的含义：</p><table><thead><tr><th align="center">事件类型</th><th align="left">WebSocket回调函数</th><th align="left">事件描述</th></tr></thead><tbody><tr><td align="center">open</td><td align="left">webSocket.onopen</td><td align="left">当打开连接后触发</td></tr><tr><td align="center">message</td><td align="left">webSocket.onmessage</td><td align="left">当客户端接收服务端数据时触发</td></tr><tr><td align="center">error</td><td align="left">webSocket.onerror</td><td align="left">当通信异常时触发</td></tr><tr><td align="center">close</td><td align="left">webSocket.onclose</td><td align="left">当连接关闭时触发</td></tr></tbody></table><h3 id="打造一个在线聊天室"><a href="#打造一个在线聊天室" class="headerlink" title="打造一个在线聊天室"></a>打造一个在线聊天室</h3><p>明白了上述的用法之后，我们来做一个实战练习吧，那就是做一个聊天室。这么说可能有点复古，好像聊天室这个称呼，是上个世纪的产物，不过也无所谓，开始一段练习吧。</p><p>前面的实验中，最为关键的，想必就是回调函数的构成了，于是，我么就开始先写回调函数吧。不过在这之前，还要介绍一下一个JSON转换工具。</p><h4 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h4><p>先导入一些基本配置吧：</p><h5 id="pom"><a href="#pom" class="headerlink" title="pom"></a>pom</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Webjars版本定位工具--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>webjars-locator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        Webjars的一个包，有各种资源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars.npm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mdui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        wenjars的JQ库--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jquery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.49<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>pom依赖前面都讲过，在此不多赘述</p><h5 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h5><p>yml文件不需要太多配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8888</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">thymeleaf:</span></span><br><span class="line">    <span class="attr">cache:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h5 id="configuration"><a href="#configuration" class="headerlink" title="configuration"></a>configuration</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerEndpointExporter <span class="title">serverEndpointExporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServerEndpointExporter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是必要的配置，前面也讲过。</p><h4 id="回调函数的编写"><a href="#回调函数的编写" class="headerlink" title="回调函数的编写"></a>回调函数的编写</h4><p>前面有引入JSON依赖，我们就使用JSON，来完善我们的信息传输，所以，先编写一个信息类吧。</p><h5 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * WebSocket 聊天消息类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ENTER = <span class="string">"ENTER"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPEAK = <span class="string">"SPEAK"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUIT = <span class="string">"QUIT"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String type;<span class="comment">//消息类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username; <span class="comment">//发送人</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String msg; <span class="comment">//发送消息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> onlineCount; <span class="comment">//在线用户数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">jsonStr</span><span class="params">(String type, String username, String msg, <span class="keyword">int</span> onlineTotal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.toJSONString(<span class="keyword">new</span> Message(type, username, msg, onlineTotal));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Message</span><span class="params">(String type, String username, String msg, <span class="keyword">int</span> onlineCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">        <span class="keyword">this</span>.onlineCount = onlineCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里的jsonStr方法是一个静态方法，而且，这个静态方法返回的是一个自身类的一个构造方法。也就是说，将使用这个静态方法去代替构造方法。</p><p>这里的JSON是一个alibaba提供的类。在pom文件中导入过。</p><h5 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h5><p>在服务端完成回调函数的编写，这里用到了Message类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ServerEndpoint</span>(<span class="string">"/chat"</span>)<span class="comment">//标记此类为服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketChatServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全部在线会话   基于场景考虑 这里使用线程安全的Map存储会话对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Session&gt; onlineSessions = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当客户端打开连接：1.添加会话对象 2.更新在线人数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        onlineSessions.put(session.getId(), session);</span><br><span class="line">        sendMessageToAll(Message.jsonStr(Message.ENTER, <span class="string">""</span>, <span class="string">""</span>, onlineSessions.size()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当客户端发送消息：1.获取它的用户名和消息 2.发送消息给所有人</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     *  这里约定传递的消息为JSON字符串 方便传递更多参数！</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Session session, String jsonStr)</span> </span>&#123;</span><br><span class="line">        Message message = JSON.parseObject(jsonStr, Message<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        sendMessageToAll(Message.jsonStr(Message.SPEAK, message.getUsername(), message.getMsg(), onlineSessions.size()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当关闭连接：1.移除会话对象 2.更新在线人数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        onlineSessions.remove(session.getId());</span><br><span class="line">        sendMessageToAll(Message.jsonStr(Message.QUIT, <span class="string">""</span>, <span class="string">"下线了！"</span>, onlineSessions.size()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当通信发生异常：打印错误日志</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Session session, Throwable error)</span> </span>&#123;</span><br><span class="line">        error.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公共方法：发送信息给所有人</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendMessageToAll</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        onlineSessions.forEach((id, session) -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                session.getBasicRemote().sendText(msg);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们逐个逐个去分析各个函数的使用：</p><ol><li>public void onOpen(Session session)：每当有客户端连接到这个地址时，就会自动往这个函数传入Session，而我们使用HashMap去存储这个Session实例，当然，使用HashSet也可以，在存储了对象的同时，也需要更新实时在线的信息。</li><li>public void onMessage(Session session, String jsonStr)：在前端的JS使用了Send（），发送了信息后，onMessage函数就会自动接收到了一个文本框的String字符串和一个当前Session对象。这里直接把String字符串转化了Message类，再将这个Message转化为JSON的形式，再发送至前端。可能大家不太明白的，就是为什么要加ENTER和SPEAK，这是为了让前端能够判断这个消息到底是什么类型的，以便用于不同的地方。</li><li>public void onClose(Session session)：自然是在退出的时候，更新在线人数</li><li>public void onError(Session session, Throwable error)：错误处理</li><li>private static void sendMessageToAll(String msg)：可以看到这是一个静态方法，也是信息传输的主体，这里使用了只有JDK8才有的Lambda表达式和foreach，去将这个Map里面的Session对象，由这个Session对象去发送信息到前端。</li></ol><p>sendMessageToAll函数也有三点是需要注意的：</p><ul><li>Lambda表达式的用法</li><li>Session是WebSocket自己的Session类</li><li>session.getBasicRemote().sendText(msg);可以是一个固定表达，不用深究。</li></ul><h4 id="登录的编写"><a href="#登录的编写" class="headerlink" title="登录的编写"></a>登录的编写</h4><p>既然是聊天，当然得知道你是谁才能正常会话，于是也需要登录界面，但是这里就不引入Security了，太麻烦，这里直接使用HTML和JS完成登录页面</p><h5 id="login页面"><a href="#login页面" class="headerlink" title="login页面"></a>login页面</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>登陆聊天<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">th:src</span>=<span class="string">"@&#123;/webjars/jquery/jquery.min.js&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span>省略。。。<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"logo_box"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>登录聊天<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"input_outer"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"u_user"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"username"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">class</span>=<span class="string">"text"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"任意中文名"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"input_outer"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"us_uer"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">class</span>=<span class="string">"text"</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">placeholder</span>=<span class="string">"任意密码"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mb2"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"act-but submit"</span> <span class="attr">onclick</span>=<span class="string">"login()"</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>这里引入webjar的JQ库，可以使用一些非常简便的函数和类。</p><h5 id="login-JavaScript"><a href="#login-JavaScript" class="headerlink" title="login-JavaScript"></a>login-JavaScript</h5><p>这一段的JS较为容易</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登陆聊天</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        location.href = <span class="string">'/index?username='</span>+$(<span class="string">'#username'</span>).val();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用ENTER登陆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">document</span>.onkeydown = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> e = event || <span class="built_in">window</span>.event || <span class="built_in">arguments</span>.callee.caller.arguments[<span class="number">0</span>];</span><br><span class="line">        e.keyCode === <span class="number">13</span> &amp;&amp; login();</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>和HT页面相结合，完成用户名的输入。</p><h5 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登陆界面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"/login"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 聊天界面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">index</span><span class="params">(String username, String password, HttpServletRequest request)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(username)) &#123;</span><br><span class="line">            username = <span class="string">"匿名用户"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ModelAndView mav = <span class="keyword">new</span> ModelAndView(<span class="string">"/chat"</span>);</span><br><span class="line">        mav.addObject(<span class="string">"username"</span>, username);</span><br><span class="line">        mav.addObject(<span class="string">"webSocketUrl"</span>, <span class="string">"ws://"</span>+ InetAddress.getLocalHost().getHostAddress()+<span class="string">":"</span>+request.getServerPort()+request.getContextPath()+<span class="string">"/chat"</span>);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JS的登录函数，将会被传入到这里，完成页面的跳转，较为简单。</p><h4 id="聊天室的编写"><a href="#聊天室的编写" class="headerlink" title="聊天室的编写"></a>聊天室的编写</h4><h5 id="chat页面"><a href="#chat页面" class="headerlink" title="chat页面"></a>chat页面</h5><p>我们也来编写聊天室的页面吧，这个页面开始引用webjar的资源。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>WebSocket简单聊天室<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/webjars/mdui/dist/css/mdui.css&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">th:src</span>=<span class="string">"@&#123;/webjars/jquery/jquery.min.js&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">th:src</span>=<span class="string">"@&#123;/webjars/mdui/dist/js/mdui.js&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">class</span>=<span class="string">"mdui-theme-primary-indigo mdui-theme-accent-pink"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mdui-container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mdui-toolbar mdui-color-theme"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"mdui-btn mdui-btn-icon"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"mdui-icon material-icons"</span>&gt;</span>menu<span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"mdui-typo-title"</span>&gt;</span>简单聊天室<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mdui-toolbar-spacer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"mdui-btn mdui-btn-icon"</span> <span class="attr">href</span>=<span class="string">"https://www.baidu.com/"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span></span></span><br><span class="line"><span class="tag">                <span class="attr">class</span>=<span class="string">"mdui-icon material-icons"</span>&gt;</span>search<span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"mdui-btn mdui-btn-icon"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/&#125;"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span></span></span><br><span class="line"><span class="tag">                <span class="attr">class</span>=<span class="string">"mdui-icon material-icons"</span>&gt;</span>exit_to_app<span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"mdui-btn mdui-btn-icon"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"mdui-icon material-icons"</span>&gt;</span>more_vert<span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mdui-container container_text"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mdui-row"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mdui-col-xs-12 mdui-col-sm-6"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mdui-col-xs-12 mdui-col-sm-10"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mdui-textfield-floating-label"</span> <span class="attr">style</span>=<span class="string">"margin-top:15px"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"mdui-icon material-icons"</span>&gt;</span>欢迎：<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"mdui-icon"</span> <span class="attr">id</span>=<span class="string">"username"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;username&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mdui-col-xs-12 mdui-col-sm-10"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mdui-textfield mdui-textfield-floating-label"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"mdui-icon material-icons"</span>&gt;</span>textsms<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"mdui-textfield-label"</span>&gt;</span>发送内容<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"mdui-textfield-input"</span> <span class="attr">id</span>=<span class="string">"msg"</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mdui-container"</span> <span class="attr">style</span>=<span class="string">"padding:20px 35px"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"mdui-btn mdui-color-theme-accent mdui-ripple"</span></span></span><br><span class="line"><span class="tag">                                <span class="attr">onclick</span>=<span class="string">"sendMsgToServer()"</span>&gt;</span>发送 (enter)</span><br><span class="line">                        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"mdui-btn mdui-color-theme mdui-ripple"</span></span></span><br><span class="line"><span class="tag">                                <span class="attr">onclick</span>=<span class="string">"clearMsg()"</span>&gt;</span>清屏</span><br><span class="line">                        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mdui-col-xs-6 mdui-col-sm-5"</span> <span class="attr">style</span>=<span class="string">"padding:10px 0"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mdui-chip"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"mdui-chip-icon mdui-color-blue"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"mdui-icon material-icons"</span>&gt;</span><span class="symbol">&amp;#xe420;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"mdui-chip-title"</span>&gt;</span>聊天内容<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mdui-chip"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"mdui-chip-icon mdui-color-blue"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"mdui-icon material-icons"</span>&gt;</span>face<span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"mdui-chip-title"</span>&gt;</span>在线人数<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"mdui-chip-title chat-num"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"message-container"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Html页面的编写，比较繁琐，但是没有什么特别复杂的问题，这里在开头引入了 webjar，同时也引入了各种各样的CSS，此时的我们只需要去编写文字和放置class就可以了，省去了CSS文件的编写过程。</p><h5 id="chat-JavaScript"><a href="#chat-JavaScript" class="headerlink" title="chat-JavaScript"></a>chat-JavaScript</h5><p>接下来到了最为重要的JS的编写了，我们来一步步完成吧。</p><p>首先是要完成发送按钮：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> webSocket = <span class="keyword">new</span> WebSocket(<span class="comment">/*[[$&#123;webSocketUrl&#125;]]*/</span> <span class="string">'ws://localhost:8888/chat'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过WebSocket对象发送消息给服务端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sendMsgToServer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> $message = $(<span class="string">'#msg'</span>);</span><br><span class="line">        <span class="keyword">if</span> ($message.val()) &#123;</span><br><span class="line">            webSocket.send(<span class="built_in">JSON</span>.stringify(&#123;<span class="attr">username</span>: $(<span class="string">'#username'</span>).text(), <span class="attr">msg</span>: $message.val()&#125;));</span><br><span class="line">            $message.val(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先从获得了id为msg的文本框，将其变成一个值，如果这个值不为空，则将其发送到后端，进行处理。</p><p>为了有更好的可视性，我们将WebSocket由函数获取，改为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> webSocket = getWebSocket();</span><br></pre></td></tr></table></figure><p>然后在这个getWebSocket函数中完成编写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getWebSocket</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> webSocket = <span class="keyword">new</span> WebSocket(<span class="comment">/*[[$&#123;webSocketUrl&#125;]]*/</span> <span class="string">'ws://localhost:8888/chat'</span>);</span><br><span class="line">    </span><br><span class="line">     webSocket.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">'WebSocket收到消息：%c'</span> + event.data, <span class="string">'color:green'</span>);</span><br><span class="line">         <span class="comment">//获取服务端消息</span></span><br><span class="line">         <span class="keyword">var</span> message = <span class="built_in">JSON</span>.parse(event.data) || &#123;&#125;;</span><br><span class="line">         <span class="keyword">var</span> $messageContainer = $(<span class="string">'.message-container'</span>);</span><br><span class="line">         <span class="comment">//</span></span><br><span class="line">         <span class="keyword">if</span> (message.type === <span class="string">'SPEAK'</span>) &#123;</span><br><span class="line">             $messageContainer.append(</span><br><span class="line">                 <span class="string">'&lt;div class="mdui-card" style="margin: 10px 0;"&gt;'</span> +</span><br><span class="line">                 <span class="string">'&lt;div class="mdui-card-primary"&gt;'</span> +</span><br><span class="line">                 <span class="string">'&lt;div class="mdui-card-content message-content"&gt;'</span> + message.username + <span class="string">"："</span> + message.msg + <span class="string">'&lt;/div&gt;'</span> +</span><br><span class="line">                 <span class="string">'&lt;/div&gt;&lt;/div&gt;'</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         $(<span class="string">'.chat-num'</span>).text(message.onlineCount);</span><br><span class="line">             &#125;);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;       </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    省略onopen等等。。。。。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">            <span class="keyword">return</span> webSocket;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>它看起来复杂，其实也就三步走：</p><ol><li>首先，先通过var message = JSON.parse(event.data)，将传入的数据变为JSON类型。</li><li>然后，再获取到：$(‘.message-container’)这个class标签。</li><li>最后，若这个标签不为空，则使用append()，将消息类型和样式加入到其中。</li></ol><p>这样就完成了，简单明了。最后测试一下吧：</p><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>打开浏览器，输入localhost:8888</p><p>并输入任意用户名，点击登录：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/webSocket/2.png" alt=""></p><p>再另外打开一个网页，登录：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/webSocket/3.png" alt=""></p><p>互相发送消息试试:happy:</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/webSocket/4.png" alt=""></p><p>源码地址：<a href="https://github.com/Antarctica000/SpringBoot/tree/master/websocket">https://github.com/Antarctica000/SpringBoot/tree/master/websocket</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> WebSocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式六大原则</title>
      <link href="/2020/02/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1/"/>
      <url>/2020/02/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1/</url>
      
        <content type="html"><![CDATA[<h2 id="设计模式六大原则"><a href="#设计模式六大原则" class="headerlink" title="设计模式六大原则"></a><strong>设计模式六大原则</strong></h2><p>每个人都有自己的想法，所以面对同一种需求，设计出来的程序都不尽相同，但是不同还是其次，当我们开始对程序进行采纳的时候，总会有一些关于智商上的争吵，何为优劣？也是一个问题，所以，在设计程序的时候，有一个主要的原则，就显得极其重要。</p><p><strong>1.单一原则（Single Responsibility Principle）</strong>：一个类只负责一项职责，尽量做到类的只有一个行为原因引起变化；</p><p>　　a、业务对象（BO business object）、业务逻辑（BL business logic）拆分；</p><p><strong>2.里氏替换原则（LSP liskov substitution principle）</strong>：子类可以扩展父类的功能，但不能改变原有父类的功能；</p><p>　　（目的：增强程序的健壮性）实际项目中，每个子类对应不同的业务含义，使父类作为参数，传递不同的子类完成不同的业务逻辑。</p><p><strong>3.依赖倒置原则（dependence inversion principle）</strong>：面向接口编程；（通过接口作为参数实现应用场景）</p><p>　　抽象就是接口或者抽象类，细节就是实现类</p><p>　　含义：</p><p>　　　　上层模块不应该依赖下层模块，两者应依赖其抽象；</p><p>　　　　抽象不应该依赖细节，细节应该依赖抽象；</p><p>【接口负责定义public属性和方法，并且申明与其他对象依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑】</p><p><strong>4.接口隔离（interface segregation principle）</strong>：建立单一接口；（扩展为类也是一种接口，一切皆接口）</p><p>　　　定义：</p><p>　　　　a.客户端不应该依赖它不需要的接口；</p><p>　　　　b.类之间依赖关系应该建立在最小的接口上；</p><p>　【接口的设计粒度越小，系统越灵活，但是灵活的同时结构复杂性提高，开发难度也会变大，维护性降低】　　　</p><p><strong>5.迪米特原则（law of demeter LOD）</strong>：最少知道原则，尽量降低类与类之间的耦合；</p><p>一个对象应该对其他对象有最少的了解</p><p><strong>6.开闭原则（open closed principle）</strong>：用抽象构建架构，用实现扩展原则；（总纲）</p><h3 id="设计模式六大原则（1）：单一职责原则"><a href="#设计模式六大原则（1）：单一职责原则" class="headerlink" title="设计模式六大原则（1）：单一职责原则"></a><strong>设计模式六大原则（1）：单一职责原则</strong></h3><p>定义：不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。<br>问题由来：类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。</p><p>解决方案：遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。</p><p>说到单一职责原则，很多人都会不屑一顾。因为它太简单了。稍有经验的程序员即使从来没有读过设计模式、从来没有听说过单一职责原则，在设计软件时也会自觉的遵守这一重要原则，因为这是常识。在软件编程中，谁也不希望因为修改了一个功能导致其他的功能发生故障。而避免出现这一问题的方法便是遵循单一职责原则。虽然单一职责原则如此简单，并且被认为是常识，但是即便是经验丰富的程序员写出的程序，也会有违背这一原则的代码存在。为什么会出现这种现象呢？因为有职责扩散。所谓职责扩散，就是因为某种原因，职责P被分化为粒度更细的职责P1和P2。</p><p>比如：类T只负责一个职责P，这样设计是符合单一职责原则的。后来由于某种原因，也许是需求变更了，也许是程序的设计者境界提高了，需要将职责P细分为粒度更细的职责P1，P2，这时如果要使程序遵循单一职责原则，需要将类T也分解为两个类T1和T2，分别负责P1、P2两个职责。但是在程序已经写好的情况下，这样做简直太费时间了。所以，简单的修改类T，用它来负责两个职责是一个比较不错的选择，虽然这样做有悖于单一职责原则。（这样做的风险在于职责扩散的不确定性，因为我们不会想到这个职责P，在未来可能会扩散为P1，P2，P3，P4……Pn。所以记住，在职责扩散到我们无法控制的程度之前，立刻对代码进行重构。）</p><p>举例说明，用一个类描述动物呼吸这个场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breathe</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line">System.out.println(animal+<span class="string">"呼吸空气"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Animal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">animal.breathe(<span class="string">"牛"</span>);</span><br><span class="line">animal.breathe(<span class="string">"羊"</span>);</span><br><span class="line">animal.breathe(<span class="string">"猪"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>牛呼吸空气</p><p>羊呼吸空气</p><p>猪呼吸空气</p><p>程序上线后，发现问题了，并不是所有的动物都呼吸空气的，比如鱼就是呼吸水的。修改时如果遵循单一职责原则，需要将Animal类细分为陆生动物类Terrestrial，水生动物Aquatic，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Terrestrial</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breathe</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line">System.out.println(animal+<span class="string">"呼吸空气"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Aquatic</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breathe</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line">System.out.println(animal+<span class="string">"呼吸水"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Terrestrial terrestrial = <span class="keyword">new</span> Terrestrial();</span><br><span class="line">terrestrial.breathe(<span class="string">"牛"</span>);</span><br><span class="line">terrestrial.breathe(<span class="string">"羊"</span>);</span><br><span class="line">terrestrial.breathe(<span class="string">"猪"</span>);</span><br><span class="line"></span><br><span class="line">Aquatic aquatic = <span class="keyword">new</span> Aquatic();</span><br><span class="line">aquatic.breathe(<span class="string">"鱼"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>牛呼吸空气</p><p>羊呼吸空气</p><p>猪呼吸空气</p><p>鱼呼吸水</p><p>我们会发现如果这样修改花销是很大的，除了将原来的类分解之外，还需要修改客户端。而直接修改类Animal来达成目的虽然违背了单一职责原则，但花销却小的多，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breathe</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">"鱼"</span>.equals(animal))&#123;</span><br><span class="line">System.out.println(animal+<span class="string">"呼吸水"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(animal+<span class="string">"呼吸空气"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Animal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">animal.breathe(<span class="string">"牛"</span>);</span><br><span class="line">animal.breathe(<span class="string">"羊"</span>);</span><br><span class="line">animal.breathe(<span class="string">"猪"</span>);</span><br><span class="line">animal.breathe(<span class="string">"鱼"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这种修改方式要简单的多。但是却存在着隐患：有一天需要将鱼分为呼吸淡水的鱼和呼吸海水的鱼，则又需要修改Animal类的breathe方法，而对原有代码的修改会对调用“猪”“牛”“羊”等相关功能带来风险，也许某一天你会发现程序运行的结果变为“牛呼吸水”了。这种修改方式直接在代码级别上违背了单一职责原则，虽然修改起来最简单，但隐患却是最大的。还有一种修改方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breathe</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line">System.out.println(animal+<span class="string">"呼吸空气"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breathe2</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line">System.out.println(animal+<span class="string">"呼吸水"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Animal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">animal.breathe(<span class="string">"牛"</span>);</span><br><span class="line">animal.breathe(<span class="string">"羊"</span>);</span><br><span class="line">animal.breathe(<span class="string">"猪"</span>);</span><br><span class="line">animal.breathe2(<span class="string">"鱼"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这种修改方式没有改动原来的方法，而是在类中新加了一个方法，这样虽然也违背了单一职责原则，但在方法级别上却是符合单一职责原则的，因为它并没有动原来方法的代码。这三种方式各有优缺点，那么在实际编程中，采用哪一中呢？其实这真的比较难说，需要根据实际情况来确定。我的原则是：只有逻辑足够简单，才可以在代码级别上违反单一职责原则；只有类中方法数量足够少，才可以在方法级别上违反单一职责原则；</p><p>例如本文所举的这个例子，它太简单了，它只有一个方法，所以，无论是在代码级别上违反单一职责原则，还是在方法级别上违反，都不会造成太大的影响。实际应用中的类都要复杂的多，一旦发生职责扩散而需要修改类时，除非这个类本身非常简单，否则还是遵循单一职责原则的好。</p><p>遵循单一职责原的优点有：</p><ul><li>可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；</li><li>提高类的可读性，提高系统的可维护性；</li><li>变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。</li></ul><p>需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则。</p><h3 id="设计模式六大原则（2）：里氏替换原则"><a href="#设计模式六大原则（2）：里氏替换原则" class="headerlink" title="设计模式六大原则（2）：里氏替换原则"></a><strong>设计模式六大原则（2）：里氏替换原则</strong></h3><p>肯定有不少人跟我刚看到这项原则的时候一样，对这个原则的名字充满疑惑。其实原因就是这项原则最早是在1988年，由麻省理工学院的一位姓里的女士（Barbara Liskov）提出来的。</p><p>定义1：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。</p><p>定义2：所有引用基类的地方必须能透明地使用其子类的对象。</p><p>问题由来：有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。</p><p>解决方案：当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。</p><p>继承包含这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。</p><p>继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。</p><p>举例说明继承的风险，我们需要完成一个两数相减的功能，由类A来负责。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line">System.out.println(<span class="string">"100-50="</span>+a.func1(<span class="number">100</span>, <span class="number">50</span>));</span><br><span class="line">System.out.println(<span class="string">"100-80="</span>+a.func1(<span class="number">100</span>, <span class="number">80</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>100-50=50</p><p>100-80=20</p><p>后来，我们需要增加一个新的功能：完成两数相加，然后再与100求和，由类B来负责。即类B需要完成两个功能：</p><ul><li>两数相减。</li><li>两数相加，然后再加100。</li></ul><p>由于类A已经实现了第一个功能，所以类B继承类A后，只需要再完成第二个功能就可以了，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> func1(a,b)+<span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">B b = <span class="keyword">new</span> B();</span><br><span class="line">System.out.println(<span class="string">"100-50="</span>+b.func1(<span class="number">100</span>, <span class="number">50</span>));</span><br><span class="line">System.out.println(<span class="string">"100-80="</span>+b.func1(<span class="number">100</span>, <span class="number">80</span>));</span><br><span class="line">System.out.println(<span class="string">"100+20+100="</span>+b.func2(<span class="number">100</span>, <span class="number">20</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类B完成后，运行结果：</p><p>100-50=150</p><p>100-80=180</p><p>100+20+100=220</p><p>我们发现原本运行正常的相减功能发生了错误。原因就是类B在给方法起名时无意中重写了父类的方法，造成所有运行相减功能的代码全部调用了类B重写后的方法，造成原本运行正常的功能出现了错误。在本例中，引用基类A完成的功能，换成子类B之后，发生了异常。在实际编程中，我们常常会通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的几率非常大。如果非要重写父类的方法，比较通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替。</p><p>里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义：</p><ul><li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li><li>子类中可以增加自己特有的方法。</li><li>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</li><li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li></ul><p>看上去很不可思议，因为我们会发现在自己编程中常常会违反里氏替换原则，程序照样跑的好好的。所以大家都会产生这样的疑问，假如我非要不遵循里氏替换原则会有什么后果？</p><p>后果就是：你写的代码出问题的几率将会大大增加。</p><h3 id="设计模式六大原则（3）：依赖倒置原则"><a href="#设计模式六大原则（3）：依赖倒置原则" class="headerlink" title="设计模式六大原则（3）：依赖倒置原则"></a><strong>设计模式六大原则（3）：依赖倒置原则</strong></h3><p>定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</p><p>问题由来：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。</p><p>解决方案：将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。</p><p>依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。</p><p>依赖倒置原则的核心思想是面向接口编程，我们依旧用一个例子来说明面向接口编程比相对于面向实现编程好在什么地方。场景是这样的，母亲给孩子讲故事，只要给她一本书，她就可以照着书给孩子讲故事了。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"很久很久以前有一个阿拉伯的故事……"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mother</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">narrate</span><span class="params">(Book book)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"妈妈开始讲故事"</span>);</span><br><span class="line">System.out.println(book.getContent());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Mother mother = <span class="keyword">new</span> Mother();</span><br><span class="line">mother.narrate(<span class="keyword">new</span> Book());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>妈妈开始讲故事</p><p>很久很久以前有一个阿拉伯的故事……</p><p>运行良好，假如有一天，需求变成这样：不是给书而是给一份报纸，让这位母亲讲一下报纸上的故事，报纸的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Newspaper</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"林书豪38+7领导尼克斯击败湖人……"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这位母亲却办不到，因为她居然不会读报纸上的故事，这太荒唐了，只是将书换成报纸，居然必须要修改Mother才能读。假如以后需求换成杂志呢？换成网页呢？还要不断地修改Mother，这显然不是好的设计。原因就是Mother与Book之间的耦合性太高了，必须降低他们之间的耦合度才行。</p><p>我们引入一个抽象的接口IReader。读物，只要是带字的都属于读物：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IReader</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mother类与接口IReader发生依赖关系，而Book和Newspaper都属于读物的范畴，他们各自都去实现IReader接口，这样就符合依赖倒置原则了，代码修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Newspaper</span> <span class="keyword">implements</span> <span class="title">IReader</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"林书豪17+9助尼克斯击败老鹰……"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">IReader</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"很久很久以前有一个阿拉伯的故事……"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mother</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">narrate</span><span class="params">(IReader reader)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"妈妈开始讲故事"</span>);</span><br><span class="line">System.out.println(reader.getContent());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Mother mother = <span class="keyword">new</span> Mother();</span><br><span class="line">mother.narrate(<span class="keyword">new</span> Book());</span><br><span class="line">mother.narrate(<span class="keyword">new</span> Newspaper());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>妈妈开始讲故事</p><p>很久很久以前有一个阿拉伯的故事……</p><p>妈妈开始讲故事</p><p>林书豪17+9助尼克斯击败老鹰……</p><p>这样修改后，无论以后怎样扩展Client类，都不需要再修改Mother类了。这只是一个简单的例子，实际情况中，代表高层模块的Mother类将负责完成主要的业务逻辑，一旦需要对它进行修改，引入错误的风险极大。所以遵循依赖倒置原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险。</p><p>采用依赖倒置原则给多人并行开发带来了极大的便利，比如上例中，原本Mother类与Book类直接耦合时，Mother类必须等Book类编码完成后才可以进行编码，因为Mother类依赖于Book类。修改后的程序则可以同时开工，互不影响，因为Mother与Book类一点关系也没有。参与协作开发的人越多、项目越庞大，采用依赖导致原则的意义就越重大。现在很流行的TDD开发模式就是依赖倒置原则最成功的应用。</p><p>传递依赖关系有三种方式，以上的例子中使用的方法是接口传递，另外还有两种传递方式：构造方法传递和setter方法传递，相信用过Spring框架的，对依赖的传递方式一定不会陌生。</p><p>在实际编程中，我们一般需要做到如下3点：</p><ul><li>低层模块尽量都要有抽象类或接口，或者两者都有。</li><li>变量的声明类型尽量是抽象类或接口。</li><li>使用继承时遵循里氏替换原则。</li></ul><p>依赖倒置原则的核心就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置。</p><h3 id="设计模式六大原则（4）：接口隔离原则"><a href="#设计模式六大原则（4）：接口隔离原则" class="headerlink" title="设计模式六大原则（4）：接口隔离原则"></a><strong>设计模式六大原则（4）：接口隔离原则</strong></h3><p>定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。<br>问题由来：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。</p><p>解决方案：将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。</p><p>举例来说明接口隔离原则：</p><p><img src="http://www.uml.org.cn/sjms/images/2012110231.jpg" alt=""></p><p>（图1 未遵循接口隔离原则的设计）</p><p>这个图的意思是：类A依赖接口I中的方法1、方法2、方法3，类B是对类A依赖的实现。类C依赖接口I中的方法1、方法4、方法5，类D是对类C依赖的实现。对于类B和类D来说，虽然他们都存在着用不到的方法（也就是图中红色字体标记的方法），但由于实现了接口I，所以也必须要实现这些用不到的方法。对类图不熟悉的可以参照程序代码来理解，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I i)</span></span>&#123;</span><br><span class="line">i.method1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I i)</span></span>&#123;</span><br><span class="line">i.method2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I i)</span></span>&#123;</span><br><span class="line">i.method3();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">I</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"类B实现接口I的方法1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"类B实现接口I的方法2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"类B实现接口I的方法3"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于类B来说，method4和method5不是必需的，但是由于接口A中有这两个方法，</span></span><br><span class="line"><span class="comment">//所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I i)</span></span>&#123;</span><br><span class="line">i.method1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I i)</span></span>&#123;</span><br><span class="line">i.method4();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I i)</span></span>&#123;</span><br><span class="line">i.method5();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">I</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"类D实现接口I的方法1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于类D来说，method2和method3不是必需的，但是由于接口A中有这两个方法，</span></span><br><span class="line"><span class="comment">//所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"类D实现接口I的方法4"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"类D实现接口I的方法5"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line">a.depend1(<span class="keyword">new</span> B());</span><br><span class="line">a.depend2(<span class="keyword">new</span> B());</span><br><span class="line">a.depend3(<span class="keyword">new</span> B());</span><br><span class="line"></span><br><span class="line">C c = <span class="keyword">new</span> C();</span><br><span class="line">c.depend1(<span class="keyword">new</span> D());</span><br><span class="line">c.depend2(<span class="keyword">new</span> D());</span><br><span class="line">c.depend3(<span class="keyword">new</span> D());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果接口过于臃肿，只要接口中出现的方法，不管对依赖于它的类有没有用处，实现类中都必须去实现这些方法，这显然不是好的设计。如果将这个设计修改为符合接口隔离原则，就必须对接口I进行拆分。在这里我们将原有的接口I拆分为三个接口，拆分后的设计如图2所示：</p><p><img src="http://www.uml.org.cn/sjms/images/2012110232.jpg" alt=""></p><p>（图2 遵循接口隔离原则的设计）</p><p>照例贴出程序的代码，供不熟悉类图的朋友参考：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I3</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I1 i)</span></span>&#123;</span><br><span class="line">i.method1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I2 i)</span></span>&#123;</span><br><span class="line">i.method2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I2 i)</span></span>&#123;</span><br><span class="line">i.method3();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">I1</span>, <span class="title">I2</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"类B实现接口I1的方法1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"类B实现接口I2的方法2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"类B实现接口I2的方法3"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I1 i)</span></span>&#123;</span><br><span class="line">i.method1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I3 i)</span></span>&#123;</span><br><span class="line">i.method4();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I3 i)</span></span>&#123;</span><br><span class="line">i.method5();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">I1</span>, <span class="title">I3</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"类D实现接口I1的方法1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"类D实现接口I3的方法4"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"类D实现接口I3的方法5"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。本文例子中，将一个庞大的接口变更为3个专用的接口所采用的就是接口隔离原则。在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</p><p>说到这里，很多人会觉的接口隔离原则跟之前的单一职责原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。</p><p>采用接口隔离原则对接口进行约束时，要注意以下几点：</p><ul><li>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</li><li>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。</li><li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li></ul><p>运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。</p><h3 id="设计模式六大原则（5）：迪米特法则"><a href="#设计模式六大原则（5）：迪米特法则" class="headerlink" title="设计模式六大原则（5）：迪米特法则"></a><strong>设计模式六大原则（5）：迪米特法则</strong></h3><p>定义：一个对象应该对其他对象保持最少的了解。</p><p>问题由来：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</p><p>解决方案：尽量降低类与类之间的耦合。</p><p>自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。低耦合的优点不言而喻，但是怎么样编程才能做到低耦合呢？那正是迪米特法则要去完成的。</p><p>迪米特法则又叫最少知道原则，最早是在1987年由美国Northeastern University的Ian Holland提出。通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。迪米特法则还有一个更简单的定义：只与直接的朋友通信。首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。</p><p>举一个例子：有一个集团公司，下属单位有分公司和直属部门，现在要求打印出所有下属单位的员工ID。先来看一下违反迪米特法则的设计。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//总公司员工</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String id;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分公司员工</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubEmployee</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String id;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubCompanyManager</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;SubEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span></span>&#123;</span><br><span class="line">List&lt;SubEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;SubEmployee&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">SubEmployee emp = <span class="keyword">new</span> SubEmployee();</span><br><span class="line"><span class="comment">//为分公司人员按顺序分配一个ID</span></span><br><span class="line">emp.setId(<span class="string">"分公司"</span>+i);</span><br><span class="line">list.add(emp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompanyManager</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmployee</span><span class="params">()</span></span>&#123;</span><br><span class="line">List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">30</span>; i++)&#123;</span><br><span class="line">Employee emp = <span class="keyword">new</span> Employee();</span><br><span class="line"><span class="comment">//为总公司人员按顺序分配一个ID</span></span><br><span class="line">emp.setId(<span class="string">"总公司"</span>+i);</span><br><span class="line">list.add(emp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(SubCompanyManager sub)</span></span>&#123;</span><br><span class="line">List&lt;SubEmployee&gt; list1 = sub.getAllEmployee();</span><br><span class="line"><span class="keyword">for</span>(SubEmployee e:list1)&#123;</span><br><span class="line">System.out.println(e.getId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line"><span class="keyword">for</span>(Employee e:list2)&#123;</span><br><span class="line">System.out.println(e.getId());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">CompanyManager e = <span class="keyword">new</span> CompanyManager();</span><br><span class="line">e.printAllEmployee(<span class="keyword">new</span> SubCompanyManager());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在这个设计的主要问题出在CompanyManager中，根据迪米特法则，只与直接的朋友发生通信，而SubEmployee类并不是CompanyManager类的直接朋友（以局部变量出现的耦合不属于直接朋友），从逻辑上讲总公司只与他的分公司耦合就行了，与分公司的员工并没有任何联系，这样设计显然是增加了不必要的耦合。按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合。修改后的代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubCompanyManager</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;SubEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span></span>&#123;</span><br><span class="line">List&lt;SubEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;SubEmployee&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">SubEmployee emp = <span class="keyword">new</span> SubEmployee();</span><br><span class="line"><span class="comment">//为分公司人员按顺序分配一个ID</span></span><br><span class="line">emp.setId(<span class="string">"分公司"</span>+i);</span><br><span class="line">list.add(emp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEmployee</span><span class="params">()</span></span>&#123;</span><br><span class="line">List&lt;SubEmployee&gt; list = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line"><span class="keyword">for</span>(SubEmployee e:list)&#123;</span><br><span class="line">System.out.println(e.getId());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompanyManager</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmployee</span><span class="params">()</span></span>&#123;</span><br><span class="line">List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">30</span>; i++)&#123;</span><br><span class="line">Employee emp = <span class="keyword">new</span> Employee();</span><br><span class="line"><span class="comment">//为总公司人员按顺序分配一个ID</span></span><br><span class="line">emp.setId(<span class="string">"总公司"</span>+i);</span><br><span class="line">list.add(emp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(SubCompanyManager sub)</span></span>&#123;</span><br><span class="line">sub.printEmployee();</span><br><span class="line">List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line"><span class="keyword">for</span>(Employee e:list2)&#123;</span><br><span class="line">System.out.println(e.getId());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后，为分公司增加了打印人员ID的方法，总公司直接调用来打印，从而避免了与分公司的员工发生耦合。</p><p>迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个“中介”来发生联系，例如本例中，总公司就是通过分公司这个“中介”来与分公司的员工发生联系的。过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。</p><h3 id="设计模式六大原则（6）：开闭原则"><a href="#设计模式六大原则（6）：开闭原则" class="headerlink" title="设计模式六大原则（6）：开闭原则"></a><strong>设计模式六大原则（6）：开闭原则</strong></h3><p>定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p><p>问题由来：在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。</p><p>解决方案：当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</p><p>开闭原则是面向对象设计中最基础的设计原则，它指导我们如何建立稳定灵活的系统。开闭原则可能是设计模式六项原则中定义最模糊的一个了，它只告诉我们对扩展开放，对修改关闭，可是到底如何才能做到对扩展开放，对修改关闭，并没有明确的告诉我们。以前，如果有人告诉我“你进行设计的时候一定要遵守开闭原则”，我会觉的他什么都没说，但貌似又什么都说了。因为开闭原则真的太虚了。</p><p>在仔细思考以及仔细阅读很多设计模式的文章后，终于对开闭原则有了一点认识。其实，我们遵循设计模式前面5大原则，以及使用23种设计模式的目的就是遵循开闭原则。也就是说，只要我们对前面5项原则遵守的好了，设计出的软件自然是符合开闭原则的，这个开闭原则更像是前面五项原则遵守程度的“平均得分”，前面5项原则遵守的好，平均分自然就高，说明软件设计开闭原则遵守的好；如果前面5项原则遵守的不好，则说明开闭原则遵守的不好。</p><p>其实笔者认为，开闭原则无非就是想表达这样一层意思：用抽象构建框架，用实现扩展细节。因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。当然前提是我们的抽象要合理，要对需求的变更有前瞻性和预见性才行。</p><p>说到这里，再回想一下前面说的5项原则，恰恰是告诉我们用抽象构建框架，用实现扩展细节的注意事项而已：单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。</p><p>最后说明一下如何去遵守这六个原则。对这六个原则的遵守并不是是和否的问题，而是多和少的问题，也就是说，我们一般不会说有没有遵守，而是说遵守程度的多少。任何事都是过犹不及，设计模式的六个设计原则也是一样，制定这六个原则的目的并不是要我们刻板的遵守他们，而需要根据实际情况灵活运用。对他们的遵守程度只要在一个合理的范围内，就算是良好的设计。我们用一幅图来说明一下。</p><p><img src="http://www.uml.org.cn/sjms/images/2012110233.jpg" alt=""></p><p>图中的每一条维度各代表一项原则，我们依据对这项原则的遵守程度在维度上画一个点，则如果对这项原则遵守的合理的话，这个点应该落在红色的同心圆内部；如果遵守的差，点将会在小圆内部；如果过度遵守，点将会落在大圆外部。一个良好的设计体现在图中，应该是六个顶点都在同心圆中的六边形。</p><p><img src="http://www.uml.org.cn/sjms/images/2012110234.jpg" alt=""></p><p>在上图中，设计1、设计2属于良好的设计，他们对六项原则的遵守程度都在合理的范围内；设计3、设计4设计虽然有些不足，但也基本可以接受；设计5则严重不足，对各项原则都没有很好的遵守；而设计6则遵守过渡了，设计5和设计6都是迫切需要重构的设计。</p><p>参考文献：</p><p>《设计模式》</p><p>《设计模式之禅》</p><p>《大话设计模式》</p><p><a href="https://www.cnblogs.com/Sam-2018/p/principle.html" target="_blank" rel="noopener">https://www.cnblogs.com/Sam-2018/p/principle.html</a></p><p><a href="https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA)" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA)</a></p><p><a href="http://www.uml.org.cn/sjms/201211023.asp" target="_blank" rel="noopener">http://www.uml.org.cn/sjms/201211023.asp</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swagger文档和Druid数据源</title>
      <link href="/2020/02/05/spring8/"/>
      <url>/2020/02/05/spring8/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot整合Swagger文档和Druid数据源"><a href="#SpringBoot整合Swagger文档和Druid数据源" class="headerlink" title="SpringBoot整合Swagger文档和Druid数据源"></a>SpringBoot整合Swagger文档和Druid数据源</h2><p>“你写的都是一堆垃圾代码！”</p><p>“你说的对，我走了，rm -rf /* “</p><h3 id="Swagger文档"><a href="#Swagger文档" class="headerlink" title="Swagger文档"></a>Swagger文档</h3><p>我们之前在对项目进行测试的时候，使用的都是PostMan，PostMan虽然提供了很多不同的测试接口以及类型，但是在使用的时候也需要很多的配置，写URL路径等等。而且，如果传过来的json数据过多，显然无法轻易的排查差错。</p><p>并且随着互联网技术的发展，现在的网站架构基本都由原来的后端渲染，变成了：前端渲染、先后端分离的形态，而且前端技术和后端技术在各自的道路上越走越远。<br>前端和后端的唯一联系，变成了API接口；API文档变成了前后端开发人员联系的纽带，变得越来越重要，swagger就是一款让你更好的书写API文档的框架。</p><p>所以，就有了Swagger文档这个框架，帮助我们快捷排查错误和API文档查看。</p><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><h5 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h5><p>Swagger API项目由字典网站Wordnik的技术联合创始人[1] Tony Tam于2011年创建。在Wordnik产品的开发过程中，对API文档自动化和客户端SDK生成的需求成为造成挫败感的主要原因。Tam 基于REST架构风格的灵活性并使用为SOAP构建的许多工具功能，设计了API 的简单JSON表示形式协议。用户界面的概念由Ayush Gupta提出，他认为交互式用户界面将使希望“尝试”并根据API开发的最终用户受益。Ramesh Pidikiti领导了初始代码生成器的实现，而设计师/开发人员Zeke Sikilianos创造了Swagger这个名字。Swagger API项目于2011年9月成为开源项目。发布后不久，该项目中添加了许多新组件，包括独立的验证器，对Node.js的支持和Ruby on Rails。</p><p>在Swagger成立之初，小公司和独立开发商的吸引力不大。RESTful API通常没有机器可读的描述机制，而Swagger提供了一种简单且可发现的方式。Tam被邀请参加API行业一些思想领袖的会议，其中包括John Musser（ProgrammableWeb），Marsh Gardiner（Apigee，现在是Google产品），Marco Palladino（Kong）和Kin Lane（API传播者），讨论标准化工作。关于API说明。虽然会议没有为此制定具体计划，但它使Swagger成为了API领域的一项关键创新。</p><p>在使用Apache 2.0开源许可证的帮助下，许多产品和在线服务开始在其产品中包括Swagger，在Apigee，Intuit，Microsoft，IBM和其他开始公开认可Swagger项目的公司采用之后，这些产品和在线服务迅速加速。</p><p>在创建Swagger之后不久，便引入了用于描述RESTful API的替代结构，其中最受欢迎的是2013年4月的API Blueprint和2013 年9月的RAML。尽管这些竞争产品比Swagger具有更强的财务支持，但它们最初专注于Swagger的不同用例，截至2014年中，Swagger的兴趣增长速度超过了两者的结合[来源：Google趋势]。</p><p>2015年11月，维护Swagger的公司SmartBear Software宣布，它正在Linux基金会（称为OpenAPI Initiative）的赞助下，帮助创建一个新组织。包括Google，IBM和Microsoft在内的各种公司都是创始成员。[2]</p><p>在2016年1月1日，Swagger规范被重命名为OpenAPI规范，并被移至GitHub中的新存储库。虽然规范本身未更改，但重命名表示API描述格式和开源工具之间的区别。</p><p>根据托管存储库Sonatype和npm的数据，截至2017年7月，每天Swagger工具的下载量超过100,000次。</p><h5 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h5><p>Swagger的开源工具用法可以分为不同的用例：开发，与API的交互以及文档。</p><p><strong>开发API</strong><br>创建API时，可以使用Swagger工具根据代码本身自动生成Open API文档。这被非正式地称为代码优先或自底向上的API开发。尽管软件代码本身可以准确地表示Open API文档，但许多API开发人员[ 谁？]认为这是一种过时的技术，因为它在项目的源代码中嵌入了API描述，并且通常对于非开发人员来说很难做出贡献。</p><p>另外，使用Swagger Codegen，开发人员可以将源代码与Open API文档分离，并直接从设计中生成客户端和服务器代码。尽管被认为很复杂，但许多行业专家认为这是更现代的API工作流程[ 需要引用 ]，并且通过延迟编码方面来设计API时具有更大的自由度。</p><p><strong>与API交互</strong><br>使用Swagger Codegen项目，最终用户可以直接从OpenAPI文档中生成客户端SDK，从而减少了对人工生成的客户端代码的需求。截至2017年8月，Swagger Codegen项目支持50多种不同语言和格式的客户端SDK生成。</p><p><strong>文档API</strong><br>当由OpenAPI文档描述时，可使用Swagger开源工具通过Swagger UI与API直接交互。该项目允许通过基于HTML的交互式用户界面直接连接到实时API 。可以直接从UI和界面用户探索的选项发出请求。</p><h4 id="使用Swagger"><a href="#使用Swagger" class="headerlink" title="使用Swagger"></a>使用Swagger</h4><p>在一个项目的pom文件中添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- swagger --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>之后再写一个，由前端URL请求到后端的json数据，…….这里省略。</p><p>打开浏览器：</p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8888&#x2F;swagger-ui.html#&#x2F;</span><br></pre></td></tr></table></figure><p>可以得到一个Swagger页面：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/swaggeranddruid/3.png" alt=""></p><p>然后点击controller的一个方法，进行测试：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/swaggeranddruid/1.png" alt=""></p><p>还能够看到各种状态信息</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/swaggeranddruid/4.png" alt=""></p><p>也可以选择各种的测试</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/swaggeranddruid/5.png" alt=""></p><h3 id="Druid数据源"><a href="#Druid数据源" class="headerlink" title="Druid数据源"></a>Druid数据源</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>druid，阿里巴巴数据库事业部出品，为监控而生的数据库连接池 。</p><p>它包括三部分： </p><ul><li>DruidDriver 代理Driver，能够提供基于Filter－Chain模式的插件体系。 </li><li>DruidDataSource 高效可管理的数据库连接池。 </li><li>SQLParser 。</li></ul><p>功能：</p><ul><li>可以监控数据库访问性能，Druid内置提供了一个功能强大的StatFilter插件，能够详细统计SQL的执行性能，这对于线上分析数据库访问性能有帮助。</li><li>替换DBCP和C3P0。Druid提供了一个高效、功能强大、可扩展性好的数据库连接池。 </li><li>数据库密码加密。直接把数据库密码写在配置文件中，这是不好的行为，容易导致安全问题。DruidDruiver和DruidDataSource都支持PasswordCallback。 </li><li>SQL执行日志，Druid提供了不同的LogFilter，能够支持Common-Logging、Log4j和JdkLog，你可以按需要选择相应的LogFilter，监控你应用的数据库访问情况。</li><li>扩展JDBC，如果你要对JDBC层有编程的需求，可以通过Druid提供的Filter-Chain机制，很方便编写JDBC层的扩展插件。</li></ul><h4 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h4><table><thead><tr><th>功能类别</th><th>功能</th><th>Druid</th><th>HikariCP</th><th>DBCP</th><th>Tomcat-jdbc</th><th>C3P0</th></tr></thead><tbody><tr><td>性能</td><td>PSCache</td><td>是</td><td>否</td><td>是</td><td>是</td><td>是</td></tr><tr><td>LRU</td><td>是</td><td>否</td><td>是</td><td>是</td><td>是</td><td></td></tr><tr><td>SLB负载均衡支持</td><td>是</td><td>否</td><td>否</td><td>否</td><td>否</td><td></td></tr><tr><td>稳定性</td><td>ExceptionSorter</td><td>是</td><td>否</td><td>否</td><td>否</td><td>否</td></tr><tr><td>扩展</td><td>扩展</td><td>Filter</td><td></td><td></td><td>JdbcIntercepter</td><td></td></tr><tr><td>监控</td><td>监控方式</td><td>jmx/log/http</td><td>jmx/metrics</td><td>jmx</td><td>jmx</td><td>jmx</td></tr><tr><td>支持SQL级监控</td><td>是</td><td>否</td><td>否</td><td>否</td><td>否</td><td></td></tr><tr><td>Spring/Web关联监控</td><td>是</td><td>否</td><td>否</td><td>否</td><td>否</td><td></td></tr><tr><td></td><td>诊断支持</td><td>LogFilter</td><td>否</td><td>否</td><td>否</td><td>否</td></tr><tr><td>连接泄露诊断</td><td>logAbandoned</td><td>否</td><td>否</td><td>否</td><td>否</td><td></td></tr><tr><td>安全</td><td>SQL防注入</td><td>是</td><td>无</td><td>无</td><td>无</td><td>无</td></tr><tr><td>支持配置加密</td><td>是</td><td>否</td><td>否</td><td>否</td><td>否</td><td></td></tr></tbody></table><p>而我们Springboot默认使用的链接池是：<strong>HikariCP</strong></p><p>我们可以自行选择，面对不同的场景，是否使用Druid。</p><h4 id="使用Druid"><a href="#使用Druid" class="headerlink" title="使用Druid"></a>使用Druid</h4><p>首先先添加依赖：</p><h5 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- druid --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在yml中添加配置：</p><h5 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">druidDataSource</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mango?useSSL=false&amp;serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">filters:</span> <span class="string">stat,wall,log4j,config</span></span><br><span class="line">      <span class="attr">max-active:</span> <span class="number">100</span></span><br><span class="line">      <span class="attr">initial-size:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">max-wait:</span> <span class="number">60000</span></span><br><span class="line">      <span class="attr">min-idle:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">time-between-eviction-runs-millis:</span> <span class="number">60000</span></span><br><span class="line">      <span class="attr">min-evictable-idle-time-millis:</span> <span class="number">300000</span></span><br><span class="line">      <span class="attr">validation-query:</span> <span class="string">select</span> <span class="string">'x'</span></span><br><span class="line">      <span class="attr">test-while-idle:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">test-on-borrow:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">test-on-return:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">pool-prepared-statements:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">max-open-prepared-statements:</span> <span class="number">50</span></span><br><span class="line">      <span class="attr">max-pool-prepared-statement-per-connection-size:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>stat：Druid内置提供一个StatFilter,用于统计监控信息。<br>wall：Druid防御SQL注入攻击的WallFilter就是通过Druid的SQL Parser分析。Druid提供的SQL Parser可以在JDBC层拦截SQL做相应处理，比如说分库分表、审计等。<br>log4j：这个就是日志记录的功能，可以把sql语句打印到log4j供排查问题。</p><h5 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h5><table><thead><tr><th>配置</th><th>缺省值</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td></td><td>配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。如果没有配置，将会生成一个名字，格式是：”DataSource-“ + System.identityHashCode(this). 另外配置此属性至少在1.0.5版本中是不起作用的，强行设置name会出错。<a href="http://blog.csdn.net/lanmo555/article/details/41248763" target="_blank" rel="noopener">详情-点此处</a>。</td></tr><tr><td>url</td><td></td><td>连接数据库的url，不同数据库不一样。例如： mysql : jdbc:mysql://10.20.153.104:3306/druid2 oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto</td></tr><tr><td>username</td><td></td><td>连接数据库的用户名</td></tr><tr><td>password</td><td></td><td>连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。<a href="https://github.com/alibaba/druid/wiki/使用ConfigFilter">详细看这里</a></td></tr><tr><td>driverClassName</td><td>根据url自动识别</td><td>这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName</td></tr><tr><td>initialSize</td><td>0</td><td>初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时</td></tr><tr><td>maxActive</td><td>8</td><td>最大连接池数量</td></tr><tr><td>maxIdle</td><td>8</td><td>已经不再使用，配置了也没效果</td></tr><tr><td>minIdle</td><td></td><td>最小连接池数量</td></tr><tr><td>maxWait</td><td></td><td>获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。</td></tr><tr><td>poolPreparedStatements</td><td>false</td><td>是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。</td></tr><tr><td>maxPoolPreparedStatementPerConnectionSize</td><td>-1</td><td>要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100</td></tr><tr><td>validationQuery</td><td></td><td>用来检测连接是否有效的sql，要求是一个查询语句，常用select ‘x’。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。</td></tr><tr><td>validationQueryTimeout</td><td></td><td>单位：秒，检测连接是否有效的超时时间。底层调用jdbc Statement对象的void setQueryTimeout(int seconds)方法</td></tr><tr><td>testOnBorrow</td><td>true</td><td>申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。</td></tr><tr><td>testOnReturn</td><td>false</td><td>归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。</td></tr><tr><td>testWhileIdle</td><td>false</td><td>建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。</td></tr><tr><td>keepAlive</td><td>false （1.0.28）</td><td>连接池中的minIdle数量以内的连接，空闲时间超过minEvictableIdleTimeMillis，则会执行keepAlive操作。</td></tr><tr><td>timeBetweenEvictionRunsMillis</td><td>1分钟（1.0.14）</td><td>有两个含义： 1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。 2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明</td></tr><tr><td>numTestsPerEvictionRun</td><td>30分钟（1.0.14）</td><td>不再使用，一个DruidDataSource只支持一个EvictionRun</td></tr><tr><td>minEvictableIdleTimeMillis</td><td></td><td>连接保持空闲而不被驱逐的最小时间</td></tr><tr><td>connectionInitSqls</td><td></td><td>物理连接初始化的时候执行的sql</td></tr><tr><td>exceptionSorter</td><td>根据dbType自动识别</td><td>当数据库抛出一些不可恢复的异常时，抛弃连接</td></tr><tr><td>filters</td><td></td><td>属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有： 监控统计用的filter:stat 日志用的filter:log4j 防御sql注入的filter:wall</td></tr><tr><td>proxyFilters</td><td></td><td>类型是List&lt;com.alibaba.druid.filter.Filter&gt;，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系</td></tr></tbody></table><h5 id="自定义配置文件"><a href="#自定义配置文件" class="headerlink" title="自定义配置文件"></a>自定义配置文件</h5><p>可以自定义配置文件，对Druid进行自定义属性配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource.druid"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidDataSourceProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jdbc</span></span><br><span class="line"><span class="keyword">private</span> String driverClassName;</span><br><span class="line"><span class="keyword">private</span> String url;</span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="comment">// jdbc connection pool</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> initialSize;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> minIdle;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxActive = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> maxWait;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> timeBetweenEvictionRunsMillis;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> minEvictableIdleTimeMillis;</span><br><span class="line"><span class="keyword">private</span> String validationQuery;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> testWhileIdle;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> testOnBorrow;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> testOnReturn;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> poolPreparedStatements;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxPoolPreparedStatementPerConnectionSize;</span><br><span class="line"><span class="comment">// filter</span></span><br><span class="line"><span class="keyword">private</span> String filters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="配置Servlet和Filter"><a href="#配置Servlet和Filter" class="headerlink" title="配置Servlet和Filter"></a>配置Servlet和Filter</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123;DruidDataSourceProperties<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">DruidConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DruidDataSourceProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">druidDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DruidDataSource druidDataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        druidDataSource.setDriverClassName(properties.getDriverClassName());</span><br><span class="line">        druidDataSource.setUrl(properties.getUrl());</span><br><span class="line">        druidDataSource.setUsername(properties.getUsername());</span><br><span class="line">        druidDataSource.setPassword(properties.getPassword());</span><br><span class="line">        druidDataSource.setInitialSize(properties.getInitialSize());</span><br><span class="line">        druidDataSource.setMinIdle(properties.getMinIdle());</span><br><span class="line">        druidDataSource.setMaxActive(properties.getMaxActive());</span><br><span class="line">        druidDataSource.setMaxWait(properties.getMaxWait());</span><br><span class="line">        druidDataSource.setTimeBetweenEvictionRunsMillis(properties.getTimeBetweenEvictionRunsMillis());</span><br><span class="line">        druidDataSource.setMinEvictableIdleTimeMillis(properties.getMinEvictableIdleTimeMillis());</span><br><span class="line">        druidDataSource.setValidationQuery(properties.getValidationQuery());</span><br><span class="line">        druidDataSource.setTestWhileIdle(properties.isTestWhileIdle());</span><br><span class="line">        druidDataSource.setTestOnBorrow(properties.isTestOnBorrow());</span><br><span class="line">        druidDataSource.setTestOnReturn(properties.isTestOnReturn());</span><br><span class="line">        druidDataSource.setPoolPreparedStatements(properties.isPoolPreparedStatements());</span><br><span class="line">        druidDataSource.setMaxPoolPreparedStatementPerConnectionSize(properties.getMaxPoolPreparedStatementPerConnectionSize());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            druidDataSource.setFilters(properties.getFilters());</span><br><span class="line">            druidDataSource.init();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> druidDataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册Servlet信息， 配置监控视图</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean&lt;Servlet&gt; <span class="title">druidServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServletRegistrationBean&lt;Servlet&gt; servletRegistrationBean = <span class="keyword">new</span> ServletRegistrationBean&lt;Servlet&gt;(<span class="keyword">new</span> StatViewServlet(), <span class="string">"/druid/*"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//白名单：</span></span><br><span class="line"><span class="comment">//        servletRegistrationBean.addInitParameter("allow","127.0.0.1,139.196.87.48");</span></span><br><span class="line">        <span class="comment">//IP黑名单 (存在共同时，deny优先于allow) : 如果满足deny的话提示:Sorry, you are not permitted to view this page.</span></span><br><span class="line">        servletRegistrationBean.addInitParameter(<span class="string">"deny"</span>,<span class="string">"192.168.1.119"</span>);</span><br><span class="line">        <span class="comment">//登录查看信息的账号密码, 用于登录Druid监控后台</span></span><br><span class="line">        servletRegistrationBean.addInitParameter(<span class="string">"loginUsername"</span>, <span class="string">"admin"</span>);</span><br><span class="line">        servletRegistrationBean.addInitParameter(<span class="string">"loginPassword"</span>, <span class="string">"admin"</span>);</span><br><span class="line">        <span class="comment">//是否能够重置数据.</span></span><br><span class="line">        servletRegistrationBean.addInitParameter(<span class="string">"resetEnable"</span>, <span class="string">"true"</span>);</span><br><span class="line">        <span class="keyword">return</span> servletRegistrationBean;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册Filter信息, 监控拦截器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean&lt;Filter&gt; <span class="title">filterRegistrationBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FilterRegistrationBean&lt;Filter&gt; filterRegistrationBean = <span class="keyword">new</span> FilterRegistrationBean&lt;Filter&gt;();</span><br><span class="line">        filterRegistrationBean.setFilter(<span class="keyword">new</span> WebStatFilter());</span><br><span class="line">        filterRegistrationBean.addUrlPatterns(<span class="string">"/*"</span>);</span><br><span class="line">        filterRegistrationBean.addInitParameter(<span class="string">"exclusions"</span>, <span class="string">"*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*"</span>);</span><br><span class="line">        <span class="keyword">return</span> filterRegistrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是注入属性和配置连接池相关的配置，如黑白名单，监控管理后台登录账户密码等。</p><p>@EnableConfigurationProperties：用于导入上一步的Druid配置信息</p><p> public ServletRegistrationBean<Servlet> druidServlet()：相当于Web Servlet配置</p><p>public FilterRegistrationBean<Filter> filterRegistrationBean()：相当于Web Filter配置</p><h5 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h5><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/swaggeranddruid/2.png" alt=""></p><p>我们发现，编译出现了错误，根据错误信息，发现缺少了log4j依赖。</p><p>log4j</p><p><strong>简介</strong></p><p>Apache Log4j是一个基于Java的日志记录工具。它是由Ceki Gülcü首创的，现在则是Apache软件基金会的一个项目。 log4j是几种Java日志框架（英语：Java logging framework）之一。</p><p>Gülcü此后开创了SLF4J和Logback项目，意图成为log4j的继任者。</p><p>log4j团队创建了log4j的继任者，版本号为2.0的新版本。log4j 2.0着重于log4j 1.2、1.3、java.util.logging和logback中的问题，并解决这些框架中的架构问题。此外，log4j 2.0提供了一个插件架构，这使得其更可扩展。log4j 2.0不是与1.x向后兼容的版本[2]，虽然有一个“适配器”可用</p><p><strong>日志等级</strong></p><p>下表中定义的log4j 1的日志级别和消息，以严重性递减排序。左栏列出了log4j的日志级别定义，右列提供了每个日志级别的简要说明。</p><table><thead><tr><th align="center"><strong>级别</strong></th><th align="center"><strong>描述</strong></th></tr></thead><tbody><tr><td align="center"><strong>OFF</strong></td><td align="center">最高级别，用于关闭日志记录。</td></tr><tr><td align="center"><strong>FATAL</strong></td><td align="center">导致应用程序提前终止的严重错误。一般这些信息将立即呈现在状态控制台上。</td></tr><tr><td align="center"><strong>ERROR</strong></td><td align="center">其他运行时错误或意外情况。一般这些信息将立即呈现在状态控制台上。</td></tr><tr><td align="center"><strong>WARN</strong></td><td align="center">使用已过时的API，API的滥用，潜在错误，其他不良的或意外的运行时的状况（但不一定是错误的）。一般这些信息将立即呈现在状态控制台上。</td></tr><tr><td align="center"><strong>INFO</strong></td><td align="center">令人感兴趣的运行时事件（启动/关闭）。一般这些信息将立即呈现在状态控制台上，因而要保守使用，并保持到最低限度。</td></tr><tr><td align="center"><strong>DEBUG</strong></td><td align="center">流经系统的详细信息。一般这些信息只记录到日志文件中。</td></tr><tr><td align="center"><strong>TRACE</strong></td><td align="center">最详细的信息。一般这些信息只记录到日志文件中。自版本1.2.12。</td></tr></tbody></table><p>这里暂时不对log4j进行研究，先完成Druid的测试。</p><h5 id="添加log4j-properties"><a href="#添加log4j-properties" class="headerlink" title="添加log4j.properties"></a>添加log4j.properties</h5><p>先添加pom依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- log4j --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在resource目录下建立一个log4j.properties文件，并添加：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### set log levels ###    </span></span><br><span class="line"><span class="meta">log4j.rootLogger</span> = <span class="string">INFO,DEBUG, console, infoFile, errorFile ,debugfile,mail </span></span><br><span class="line"><span class="attr">LocationInfo</span>=<span class="string">true    </span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.appender.console</span> = <span class="string">org.apache.log4j.ConsoleAppender  </span></span><br><span class="line"><span class="meta">log4j.appender.console.Target</span> = <span class="string">System.out  </span></span><br><span class="line"><span class="meta">log4j.appender.console.layout</span> = <span class="string">org.apache.log4j.PatternLayout </span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.appender.console.layout.ConversionPattern</span> =<span class="string">[%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125;]-[%p]:%m   %x %n </span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.appender.infoFile</span> = <span class="string">org.apache.log4j.DailyRollingFileAppender  </span></span><br><span class="line"><span class="meta">log4j.appender.infoFile.Threshold</span> = <span class="string">INFO  </span></span><br><span class="line"><span class="meta">log4j.appender.infoFile.File</span> = <span class="string">C:/logs/log</span></span><br><span class="line"><span class="meta">log4j.appender.infoFile.DatePattern</span> = <span class="string">'.'yyyy-MM-dd'.log'  </span></span><br><span class="line"><span class="meta">log4j.appender.infoFile.Append</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">log4j.appender.infoFile.layout</span> = <span class="string">org.apache.log4j.PatternLayout  </span></span><br><span class="line"><span class="meta">log4j.appender.infoFile.layout.ConversionPattern</span> =<span class="string">[%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125;]-[%p]:%m  %x %n </span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.appender.errorFile</span> = <span class="string">org.apache.log4j.DailyRollingFileAppender  </span></span><br><span class="line"><span class="meta">log4j.appender.errorFile.Threshold</span> = <span class="string">ERROR  </span></span><br><span class="line"><span class="meta">log4j.appender.errorFile.File</span> = <span class="string">C:/logs/error  </span></span><br><span class="line"><span class="meta">log4j.appender.errorFile.DatePattern</span> = <span class="string">'.'yyyy-MM-dd'.log'  </span></span><br><span class="line"><span class="meta">log4j.appender.errorFile.Append</span>=<span class="string">true  </span></span><br><span class="line"><span class="meta">log4j.appender.errorFile.layout</span> = <span class="string">org.apache.log4j.PatternLayout  </span></span><br><span class="line"><span class="meta">log4j.appender.errorFile.layout.ConversionPattern</span> =<span class="string">[%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125;]-[%p]:%m  %x %n</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.appender.debugfile</span> = <span class="string">org.apache.log4j.DailyRollingFileAppender  </span></span><br><span class="line"><span class="meta">log4j.appender.debugfile.Threshold</span> = <span class="string">DEBUG  </span></span><br><span class="line"><span class="meta">log4j.appender.debugfile.File</span> = <span class="string">C:/logs/debug  </span></span><br><span class="line"><span class="meta">log4j.appender.debugfile.DatePattern</span> = <span class="string">'.'yyyy-MM-dd'.log'  </span></span><br><span class="line"><span class="meta">log4j.appender.debugfile.Append</span>=<span class="string">true  </span></span><br><span class="line"><span class="meta">log4j.appender.debugfile.layout</span> = <span class="string">org.apache.log4j.PatternLayout  </span></span><br><span class="line"><span class="meta">log4j.appender.debugfile.layout.ConversionPattern</span> =<span class="string">[%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125;]-[%p]:%m  %x %n</span></span><br></pre></td></tr></table></figure><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>在浏览器输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8888&#x2F;druid&#x2F;login.html</span><br></pre></td></tr></table></figure><p>用户名和密码均为admin，登录</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/swaggeranddruid/6.png" alt=""></p><p>打开数据源页，可以看到数据源的配置信息</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/swaggeranddruid/7.png" alt=""></p><p>再输入<a href="http://localhost:8888/user/findAll，进行访问后，打开SQL监控页面：" target="_blank" rel="noopener">http://localhost:8888/user/findAll，进行访问后，打开SQL监控页面：</a></p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/swaggeranddruid/8.png" alt=""></p><p>我们可以从这里监控到每一次的SQL读取。</p><p>Druid除了拥有更好的性能之外，还能对SQL语句的进行进行更好的监控和管理。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 排错指南 </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> Swagger </tag>
            
            <tag> Druid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker部署MySQL</title>
      <link href="/2020/02/03/docker1/"/>
      <url>/2020/02/03/docker1/</url>
      
        <content type="html"><![CDATA[<h2 id="Dokcer"><a href="#Dokcer" class="headerlink" title="Dokcer"></a>Dokcer</h2><p>每次我们要使用一个又一个的工具的时候，总是需要非常麻烦的下载和安装，特别不方便。</p><p>但是，”人总是越来越懒的“——鲁迅。（我没有说过）</p><p>为了不怎么麻烦，节约一点时间，便诞生了Docker这个，非常方便的，一键安装所有工具的  “工具”。</p><h3 id="使用docker"><a href="#使用docker" class="headerlink" title="使用docker"></a>使用docker</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Docker是一个开源的应用容器引擎；是一个轻量级容器技术；<br>Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使<br>用这个镜像；<br>运行中的这个镜像称为容器，容器启动是非常快速的。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/docker/1.png" alt=""></p><p>Docker利用Linux核心中的资源分离机制，例如cgroups，以及Linux核心名字空间（namespaces），来创建独立的容器（containers）。这可以在单一Linux实体下运作，避免引导一个虚拟机造成的额外负担。Linux核心对名字空间的支持完全隔离了工作环境中应用程序的视野，包括行程树、网络、用户ID与挂载文件系统，而核心的cgroup提供资源隔离，包括CPU、存储器、block I/O与网络。从0.9版本起，Dockers在使用抽象虚拟是经由libvirt的LXC与systemd - nspawn提供界面的基础上，开始包括libcontainer库做为以自己的方式开始直接使用由Linux核心提供的虚拟化的设施，</p><p>依据行业分析公司“451研究”：“Dockers是有能力打包应用程序及其虚拟容器，可以在任何Linux服务器上运行的依赖性工具，这有助于实现灵活性和便携性，应用程序在任何地方都可以运行，无论是公用云、私有云、单机等。”</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/docker/2.jpg" alt=""></p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/docker/3.jpg" alt=""></p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）；</p><p>docker客户端(Client)：连接docker主机进行操作；</p><p>docker仓库(Registry)：用来保存各种打包好的软件镜像；</p><p>docker镜像(Images)：软件打包好的镜像；放在docker仓库中；</p><p>docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/docker/4.jpg" alt=""></p><p>使用Docker的步骤：</p><p>1）、安装Docker</p><p>2）、去Docker仓库找到这个软件对应的镜像；</p><p>3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器；</p><p>4）、对容器的启动停止就是对软件的启动停止</p><h4 id="在Liunx上安装docker"><a href="#在Liunx上安装docker" class="headerlink" title="在Liunx上安装docker"></a>在Liunx上安装docker</h4><p>可以选择安装虚拟机或者是买一台云服务器，以下使用虚拟机进行试验：</p><p>1）、VMWare、VirtualBox（安装）；<br>2）、导入虚拟机文件centos7-atguigu.ova；<br>3）、双击启动linux虚拟机;使用 root/ 123456登陆<br>4）、使用客户端连接linux服务器进行命令操作；<br>5）、设置虚拟机网络；<br>桥接网络=选好网卡==接入网线；<br>6）、设置好网络以后使用命令重启虚拟机的网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure><p>7）、查看linux的ip地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr</span><br></pre></td></tr></table></figure><p>​    8）、使用客户端连接linux；</p><h4 id="2）、在linux虚拟机上安装docker"><a href="#2）、在linux虚拟机上安装docker" class="headerlink" title="2）、在linux虚拟机上安装docker"></a>2）、在linux虚拟机上安装docker</h4><p>步骤：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1、检查内核版本，必须是3.10及以上</span><br><span class="line">uname -r</span><br><span class="line">2、安装docker</span><br><span class="line">yum install docker</span><br><span class="line">3、输入y确认安装</span><br><span class="line">4、启动docker</span><br><span class="line">[root@localhost ~]# systemctl start docker</span><br><span class="line">[root@localhost ~]# docker -v</span><br><span class="line">Docker version 1.12.6, build 3e8e77d/1.12.6</span><br><span class="line">5、开机启动docker</span><br><span class="line">[root@localhost ~]# systemctl enable docker</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.</span><br><span class="line">6、停止docker</span><br><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure><h3 id="Docker常用命令-amp-操作"><a href="#Docker常用命令-amp-操作" class="headerlink" title="Docker常用命令&amp;操作"></a>Docker常用命令&amp;操作</h3><h4 id="1）、镜像操作"><a href="#1）、镜像操作" class="headerlink" title="1）、镜像操作"></a>1）、镜像操作</h4><table><thead><tr><th>操作</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>检索</td><td>docker  search 关键字  eg：docker  search redis</td><td>我们经常去docker  hub上检索镜像的详细信息，如镜像的TAG。</td></tr><tr><td>拉取</td><td>docker pull 镜像名:tag</td><td>:tag是可选的，tag表示标签，多为软件的版本，默认是latest</td></tr><tr><td>列表</td><td>docker images</td><td>查看所有本地镜像</td></tr><tr><td>删除</td><td>docker rmi image-id</td><td>删除指定的本地镜像</td></tr></tbody></table><p><a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p><h4 id="2）、容器操作"><a href="#2）、容器操作" class="headerlink" title="2）、容器操作"></a>2）、容器操作</h4><p>软件镜像（QQ安装程序）—-运行镜像—-产生一个容器（正在运行的软件，运行的QQ）；</p><p>步骤：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1、搜索镜像</span><br><span class="line">[root@localhost ~]# docker search tomcat</span><br><span class="line">2、拉取镜像</span><br><span class="line">[root@localhost ~]# docker pull tomcat</span><br><span class="line">3、根据镜像启动容器</span><br><span class="line">docker run --name mytomcat -d tomcat:latest</span><br><span class="line">4、docker ps  </span><br><span class="line">查看运行中的容器</span><br><span class="line">5、 停止运行中的容器</span><br><span class="line">docker stop  容器的id</span><br><span class="line">6、查看所有的容器</span><br><span class="line">docker ps -a</span><br><span class="line">7、启动容器</span><br><span class="line">docker start 容器id</span><br><span class="line">8、删除一个容器</span><br><span class="line"> docker rm 容器id</span><br><span class="line">9、启动一个做了端口映射的tomcat</span><br><span class="line">[root@localhost ~]# docker run -d -p 8888:8080 tomcat</span><br><span class="line">-d：后台运行</span><br><span class="line">-p: 将主机的端口映射到容器的一个端口    主机端口:容器内部的端口</span><br><span class="line"></span><br><span class="line">10、为了演示简单关闭了linux的防火墙</span><br><span class="line">service firewalld status ；查看防火墙状态</span><br><span class="line">service firewalld stop：关闭防火墙</span><br><span class="line">11、查看容器的日志</span><br><span class="line">docker logs container-name/container-id</span><br><span class="line"></span><br><span class="line">更多命令参看</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/docker/</span><br><span class="line">可以参考每一个镜像的文档</span><br></pre></td></tr></table></figure><h4 id="3）、安装MySQL示例"><a href="#3）、安装MySQL示例" class="headerlink" title="3）、安装MySQL示例"></a>3）、安装MySQL示例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure><p>错误的启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run --name mysql01 -d mysql</span><br><span class="line">42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846</span><br><span class="line"></span><br><span class="line">mysql退出了</span><br><span class="line">[root@localhost ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                           PORTS               NAMES</span><br><span class="line">42f09819908b        mysql               "docker-entrypoint.sh"   34 seconds ago      Exited (1) 33 seconds ago                            mysql01</span><br><span class="line">538bde63e500        tomcat              "catalina.sh run"        About an hour ago   Exited (143) About an hour ago                       compassionate_</span><br><span class="line">goldstine</span><br><span class="line">c4f1ac60b3fc        tomcat              "catalina.sh run"        About an hour ago   Exited (143) About an hour ago                       lonely_fermi</span><br><span class="line">81ec743a5271        tomcat              "catalina.sh run"        About an hour ago   Exited (143) About an hour ago                       sick_ramanujan</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//错误日志</span><br><span class="line">[root@localhost ~]# docker logs 42f09819908b</span><br><span class="line">error: database is uninitialized and password option is not specified </span><br><span class="line">  You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个</span><br></pre></td></tr></table></figure><p>正确的启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysql</span><br><span class="line">b874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f</span><br><span class="line">[root@localhost ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">b874c56bec49        mysql               "docker-entrypoint.sh"   4 seconds ago       Up 3 seconds        3306/tcp            mysql01</span><br></pre></td></tr></table></figure><p>做了端口映射</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysql</span><br><span class="line">ad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434</span><br><span class="line">[root@localhost ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">ad10e4bc5c6a        mysql               "docker-entrypoint.sh"   4 seconds ago       Up 2 seconds        0.0.0.0:3306-&gt;3306/tcp   mysql02</span><br></pre></td></tr></table></figure><p>几个其他的高级操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mysql03 -v &#x2F;conf&#x2F;mysql:&#x2F;etc&#x2F;mysql&#x2F;conf.d -e MYSQL_ROOT_PASSWORD&#x3D;my-secret-pw -d mysql:tag</span><br><span class="line">把主机的&#x2F;conf&#x2F;mysql文件夹挂载到 mysqldocker容器的&#x2F;etc&#x2F;mysql&#x2F;conf.d文件夹里面</span><br><span class="line">改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（&#x2F;conf&#x2F;mysql）</span><br><span class="line"></span><br><span class="line">docker run --name some-mysql -e MYSQL_ROOT_PASSWORD&#x3D;my-secret-pw -d mysql:tag --character-set-server&#x3D;utf8mb4 --collation-server&#x3D;utf8mb4_unicode_ci</span><br><span class="line">指定mysql的一些配置参数</span><br></pre></td></tr></table></figure><h3 id="使用Navicat连接docker的mysql"><a href="#使用Navicat连接docker的mysql" class="headerlink" title="使用Navicat连接docker的mysql"></a>使用Navicat连接docker的mysql</h3><h4 id="下载安装Navicat"><a href="#下载安装Navicat" class="headerlink" title="下载安装Navicat"></a>下载安装Navicat</h4><p>适应navicat去连接虚拟机的mysql，可以使得我们的数据库有一个可以操作的界面，这样就有更好的操作空间，这里暂时不过多赘述，自行下载安装便是了。</p><h4 id="常见的错误"><a href="#常见的错误" class="headerlink" title="常见的错误"></a>常见的错误</h4><p>这里才是主要说的一点，现在大多数人学习的时候，采用的都是mysql80以上的版本，但是这样通常会出现一个问题：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/docker/7.jpg" alt=""></p><p>原因：mysql 8.0 默认使用 caching_sha2_password 身份验证机制；客户端不支持新的加密方式。</p><p>解决：</p><p>修改用户（root）的加密方式</p><p>步骤：<br>1、进入mysql容器内部：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker exec -it mysql01 bash   ## mysql01是容器的别名，这里也可以用容器的id代替</span><br></pre></td></tr></table></figure><p>2、登录mysql：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@e285125c99d6:/# mysql -u root -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 11</span><br><span class="line">Server version: 8.0.13 MySQL Community Server - GPL</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.</span><br></pre></td></tr></table></figure><p>3、设置用户配置项<br>1）、查看用户信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select host,user,plugin,authentication_string from mysql.user; </span></span><br><span class="line">+-----------+------------------+-----------------------+------------------------------------------------------------------------+</span><br><span class="line">| host      | user             | plugin                | authentication_string                                                  |</span><br><span class="line">+-----------+------------------+-----------------------+------------------------------------------------------------------------+</span><br><span class="line">| %         | root             | caching_sha2_password | $A$005$HF7;krfwhkKHp5fPenQm4J2dm/RJtbbyjtCUVdDCcboXQw3ALxsif/sS1 |</span><br><span class="line">| localhost | mysql.infoschema | caching_sha2_password | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |</span><br><span class="line">| localhost | mysql.session    | caching_sha2_password | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |</span><br><span class="line">| localhost | mysql.sys        | caching_sha2_password | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |</span><br><span class="line">| localhost | root             | mysql_native_password | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9                              |</span><br><span class="line">+-----------+------------------+-----------------------+------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>备注：host为 % 表示不限制ip localhost表示本机使用 plugin非mysql_native_password 则需要修改密码</p><p>2）、修改加密方式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '123456';  ### 123456 mysql的登录密码</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>然后再查看用户信息:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select host,user,plugin,authentication_string from mysql.user;</span></span><br><span class="line">+-----------+------------------+-----------------------+------------------------------------------------------------------------+</span><br><span class="line">| host      | user             | plugin                | authentication_string                                                  |</span><br><span class="line">+-----------+------------------+-----------------------+------------------------------------------------------------------------+</span><br><span class="line">| %         | root             | mysql_native_password | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9                              |</span><br><span class="line">| localhost | mysql.infoschema | caching_sha2_password | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |</span><br><span class="line">| localhost | mysql.session    | caching_sha2_password | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |</span><br><span class="line">| localhost | mysql.sys        | caching_sha2_password | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |</span><br><span class="line">| localhost | root             | mysql_native_password | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9                              |</span><br><span class="line">+-----------+------------------+-----------------------+------------------------------------------------------------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>4、测试：连接成功</p><h3 id="部署SpringBoot项目"><a href="#部署SpringBoot项目" class="headerlink" title="部署SpringBoot项目"></a>部署SpringBoot项目</h3><p>cd到相应的目录下，使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar xxxx.jar</span><br></pre></td></tr></table></figure><p>但是这样只要关闭了终端，项目还是会结束。</p><p>所以需要加一个：nohub 让其能够在后台运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar xxxx.jar</span><br></pre></td></tr></table></figure><p>nohup java -jar 自己的springboot项目.jar &gt;日志文件名.log 2&gt;&amp;1 &amp;</p><h4 id="命令详解："><a href="#命令详解：" class="headerlink" title="命令详解："></a>命令详解：</h4><p><strong>nohup java -jar 自己的springboot项目.jar &gt;日志文件名.log  2&gt;&amp;1 &amp;</strong></p><p>nohup：不挂断地运行命令，退出帐户之后继续运行相应的进程。</p><p>“&gt;”：日志文件名.log：是nohup把command的输出重定向到当前目录的指定的“日志文件名.log”文件中，即输出内容不打印到屏幕上，而是输出到”日志文件名.log”文件中。不指定文件名会在当前目录创建nohup.out，如果当前目录的 nohup.out 文件不可写，输出重定向到 $HOME/nohup.out 文件中。如果没有文件能创建或打开以用于追加，那么 Command 参数指定的命令不可调用。</p><p>”2&gt;&amp;1“：2就是标准错误，1是标准输出，该命令相当于把标准错误重定向到标准输出么。这里&amp;相当于标准错误等效于标准输出，即把标准错误和标准输出同时输出到指定的“日志文件名.log”文件中。</p><p>java -jar 自己的springboot项目.jar：执行springboot的项目，如果单单只执行该命令，linux只会短暂的运行该项目，当退出控制台后会自动关闭该项目。</p><p>最后的&amp;：让改作业在后台运行。</p><p>所以一般仅仅是测试项目，建议使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar xxxx.jar</span><br><span class="line">或者是：</span><br><span class="line">nohup java -jar xxxx.jar &amp;</span><br></pre></td></tr></table></figure><h4 id="结束项目"><a href="#结束项目" class="headerlink" title="结束项目"></a>结束项目</h4><p>这个和liunx结束项目的方法是一致的。</p><p>查看当前所有进程：</p><p><strong>ps -aux</strong></p><p>查看筛选的进程：</p><p><strong>ps -aux|grep “xxxxxx”</strong></p><p>查看二次筛选的进程：</p><p><strong>ps -aux|grep “xxxxxx”|grep -v “aaa”</strong></p><p>结束进程：<br><strong>kill -9 8888</strong></p><p>注：</p><ol><li>grep -v “grep”是指过滤掉含有”grep”的进程</li><li>“|”是指用前面的输出作为输入</li><li>kill后面跟的是进程号</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 排错指南 </tag>
            
            <tag> Docker </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排错：mybatis报错：Invalid bound statement (not found)</title>
      <link href="/2020/02/01/error1/"/>
      <url>/2020/02/01/error1/</url>
      
        <content type="html"><![CDATA[<h3 id="Invalid-bound-statement-not-found"><a href="#Invalid-bound-statement-not-found" class="headerlink" title="Invalid bound statement (not found)"></a>Invalid bound statement (not found)</h3><p>在使用mybatis时，有时候会出现一些逻辑上解释不通的错误，这个时候就需要一本排错指南，记住这些常见的错误。</p><p>出现错误并不代表他复杂且难以理解，在有时候，某些错误就和电脑重开机就能解决90%的问题一样，充满玄学。</p><h4 id="第一种：语法错误"><a href="#第一种：语法错误" class="headerlink" title="第一种：语法错误"></a><strong>第一种：语法错误</strong></h4><p>Java DAO层接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(@Param(<span class="string">"id"</span>)</span>String id)</span>;</span><br></pre></td></tr></table></figure><p>Java 对应的mapper.xml文件:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"xxx.xxx.xxx.Mapper"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 删除数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"delete"</span> <span class="attr">parameterType</span>=<span class="string">"java.lang.String"</span>&gt;</span></span><br><span class="line">        DELETE FROM xxx WHERE id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>检查：1. 接口中方法名（delete）与xml文件中 id=”delete”是否一致</p><p>　　　2. xml文件中的 namespace=”xxx.xxx.xxx.Mapper” 中的路径是否与接口文件路径一致</p><p>　　　3.parameterType类型 与 resultType类型是否准确；resultMap与resultType是不一样的。</p><h4 id="第二种：编译错误"><a href="#第二种：编译错误" class="headerlink" title="第二种：编译错误"></a><strong>第二种：编译错误</strong></h4><p>　定位到项目路径下：target\classes\ 中报错路径下，寻找对应的xml文件是否存在。</p><p>（1）若不存在对应的xml文件，则需要在pom.xml中加入以下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/*.java<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>　　删除classes文件夹中文件，重新编译，出现了对应的xml文件即可。</p><p>（2）若存在xml文件，则打开xml文件，检查其中报错部分是否与源文件一致，不一致，则</p><p>　　先清除classes文件夹中文件，执行命令：mvn clean 清理内容，重新编译后即可。</p><h4 id="第三种：配置错误"><a href="#第三种：配置错误" class="headerlink" title="第三种：配置错误"></a><strong>第三种：配置错误</strong></h4><p>在配置文件中指定扫描包时，配置路径有问题。例如：spring配置文件中”basePackage” 属性包名的指定一定要具体到接口所在包，而不要写父级甚至更高级别的包 ，否则可能出现问题；cn.dao 与cn.*也可能导致错误；注解扫描时，可能没有扫描到包等。</p><h4 id="第四种-细节错误"><a href="#第四种-细节错误" class="headerlink" title="第四种 细节错误"></a>第四种 细节错误</h4><p>比如：</p><p>忘记在配置文件上加别名</p><p>忘记开启驼峰命名法</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:/mapper/*.xml</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.example.thymeleaf.pojo</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="第五种-弱智型错误"><a href="#第五种-弱智型错误" class="headerlink" title="第五种 弱智型错误"></a>第五种 弱智型错误</h4><p>再比如：</p><p>文件头没加@MapperSacn</p><p>或者是xml的文件头没加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
            <tag> 排错指南 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>InnoDB存储引擎</title>
      <link href="/2020/01/29/mysql3/"/>
      <url>/2020/01/29/mysql3/</url>
      
        <content type="html"><![CDATA[<h2 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h2><h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><p>InnoDB存储引擎是多线程的模型，因此其后台有多个不同的后台线程，负责处理不同的任务。</p><h4 id="Master-Thread"><a href="#Master-Thread" class="headerlink" title="Master Thread"></a>Master Thread</h4><p>Master Thread是一个非常核心的后台线程,主要负责将缓冲池的数据异步刷新到磁盘,保证数据的一致性,包括脏页的刷新、合并插入缓冲、UNDO页的回收等。</p><h4 id="IO-Thread"><a href="#IO-Thread" class="headerlink" title="IO Thread"></a>IO Thread</h4><p>在InnoDB存储引擎使用大量的AIO（Async IO） 来处理IO请求，这样可以极大提高数据库的性能。<br>在Linux平台下 IO Thread的数量不能进行调整，在windows平台1.0.x版本开始 分别使用 innodb_read_io_threads 和 innodb_write_io_theads参数进行设置,如:</p><p>mysql&gt;SHOW VARIABLES LIKE ‘innodb_version’\G;</p><p>mysql&gt; SHOW VARIABLES LIKE ‘innodb_%io_threads’\G;</p><p>通过SHOW ENGINE INNODB STATUS\G; 观察 InnoDB 中的IO Thread。</p><h4 id="Purge-Thread"><a href="#Purge-Thread" class="headerlink" title="Purge Thread"></a>Purge Thread</h4><p>事务被提交后,其所使用的undolog可能不再需要，因此需要Purge Thread来回收已经使用并分配的undo页。<br>在InnoDB 1.1 版本中 innodb_purge_rgreads设为大于1,存储启动将其设为1,并报错。</p><p>在InnoDB1.2版本开始 InnoDB 支持多个Purge Thread。</p><h4 id="Page-Cleaner-Thread"><a href="#Page-Cleaner-Thread" class="headerlink" title="Page Cleaner Thread"></a>Page Cleaner Thread</h4><p>Page Cleaner Thread在InnoDB 1.2.x版本中引入的。其作用是将之前版本中的脏页的刷新操作放入到单独的线程中完成。</p><h3 id="InnoDB内存"><a href="#InnoDB内存" class="headerlink" title="InnoDB内存"></a>InnoDB内存</h3><h4 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h4><p>InnoDB存储引擎是基于磁盘存储的,并将其中的记录按照页的方式进行管理。<br>缓存池简单来说就是一块内存区域。</p><p>通过参数innodb_buffer_pool_size配置缓存池: show variables like ‘innodb_buffer_pool_size’\G</p><p>内存结构：</p><p><img src="https://box.kancloud.cn/4cd2284ff4362e47710ebe90aa9fc9d4_794x299.png" alt=""></p><p>具体来看缓冲池中缓存的数据页类型有:<br>索引页: 缓存数据表索引<br>数据页: 缓存数据页，占缓冲池的绝大部分<br>undo页: undo页是保存事务，为回滚做准备的。<br>插入缓冲(Insert buffer): 上面提到的插入数据时要先插入到缓存池中。<br>自适应哈希索引(adaptive hash index): 除了B+ Tree索引外，在缓冲池还会维护一个哈希索引，以便在缓冲池中快速找到数据页。<br>InnoDB存储的锁信息(lock info):<br>数据字典(data dictionary):<br>内存中除了缓冲池外外还有:<br>重做日志缓冲redo log: 为了避免数据丢失的问题，当前数据库系统普遍采用了write ahead log策略，既当事务提交时先写重做日志，再修改写页。当由于发生宕机而导致数据丢失时，可以通过重做日志进行恢复。InnoDB先将重做日志放到这个缓冲区，然后按照一定的频率更新到重做日志文件中。重做日志一般在下列情况下会刷新内容到文件:</p><p>1.Master Thread每一秒将重做日志缓冲刷新到重做日志文件<br>2.每个事务提交时会将重做日志缓冲刷新到重做日志文件<br>3.当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件<br>额外内存池: InnoDB存储引擎中，对内存的管理师通过一种称为内存堆的方式进行的，在对一些数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不够时，会从缓冲池中进行申请。<br>缓冲池是一个很大的内存区域，InnoDB是如何对这些内存进行管理的呢。答案就使用LRU list。<br>LRU(Latest Recent Used, 最近最少使用)算法默认的是最近使用的放到表头，最早使用的放到表尾，依次排列。当有LRU填满时有新的进来就把最早的淘汰掉。InnoDB则是在这个基础上进行了修改:</p><p>最近使用的不放到表头，而是根据配置放到一定比例处，这个地方叫做midpoint, midpoint之前的成为new列表，之后的成为old列表。淘汰的同样是表尾的页。<br>为了保证new列表的不经常使用时能够淘汰，设置了一个超时时间:innodb_old_blocks_time，当数据在midpoint(我理解应该是在old列表中，不然这个点的页就一个，变化也比较频繁)的时间超过找个时间时就会被提升到表头，new列表的表尾页则被置换到old列表中。<br>这么做的原因主要是因为常见的索引或数据的扫描操作会连续读取大量的页，甚至是全表扫描。如果采用原来的LRU算法就会更新全部的缓冲池，其他查询需要的热点数据就会被冲走，导致更多的磁盘读取操作，降低数据库的性能。<br>LRU是用来管理已经读取的页，当数据库启动时LRU是空列表,既只有表头，没有内容。这时页都放在Free List中。当需要有数据读写时要进行需要获取分页，这时要从Free List中删除分页，然后添加到LRU list中。到一定时间Free List中的分页就会被分配完毕，这时候就正常使用上面的LRU策略。<br>LRU列表中的页被修改后，称该页为脏页(dirty page),既缓冲池中的数据和磁盘上的数据产生了不一致，这时脏页会被加入到一个Flush 列表中(注意，同时存在两个列表中)。然后根据刷新的机制定时的刷新到磁盘中。</p><p>InnoDB 1.0.x开始允许多个缓存实例。</p><p>参数innodb_buffer_pool_instances来进行配置 默认唯一。</p><p><img src="https://box.kancloud.cn/3908739be0890daefa25489ed6c4d488_700x94.png" alt=""></p><p>参数innodb_buffer_pool_instances可以设置大于1的值就可以得到多个缓冲池实例。</p><p>再通过命令SHOW ENGINE INNODB STATUS\G; 观察内容</p><p>mysql5.6开始:<br>SELECT POOL_ID POOL_SIZE, FREE_BUFFERS,DATABASE_PAGES FROM INNODB_BUFFER_POOL_STATS\G<br>查看缓冲状态。</p><h4 id="LRU-List、Free-List-和-Flush-List"><a href="#LRU-List、Free-List-和-Flush-List" class="headerlink" title="LRU List、Free List 和 Flush List"></a>LRU List、Free List 和 Flush List</h4><p>缓存池默认页大小16kB，同样使用LRU算法进行缓冲池进行管理。</p><p><img src="https://box.kancloud.cn/8b5de1bc2ab5e5df499a92cdd1e15757_802x363.png" alt=""></p><p>通过information_schema架构下的表观察unzip_LRU列表中的页:SELECT TABLE_NAME,SPACE,PAGE_NUMBER,COMPRESSED_SIZE FROM INNODB_BUFFER_PAGE_LRU WHERE C OMPRSSED_SIZE &lt;&gt; 0;</p><p>Flush List为脏页列表;</p><p><img src="https://box.kancloud.cn/0a771448997c98db048fddca47971938_792x154.png" alt=""></p><h4 id="重做日志缓冲"><a href="#重做日志缓冲" class="headerlink" title="重做日志缓冲"></a>重做日志缓冲</h4><p><img src="https://box.kancloud.cn/f75f7e4ec65857de30137f676e37cc77_841x328.png" alt=""></p><h4 id="额外的内存池"><a href="#额外的内存池" class="headerlink" title="额外的内存池"></a>额外的内存池</h4><p>在对一些数据结构本身的内存进行分配时,需要从额外的内存池中进行申请,当该区域的内存不够的时候,会从缓冲池进行申请。</p><h3 id="InnoDB存储引擎三大特性"><a href="#InnoDB存储引擎三大特性" class="headerlink" title="InnoDB存储引擎三大特性"></a>InnoDB存储引擎三大特性</h3><h4 id="插入缓冲"><a href="#插入缓冲" class="headerlink" title="插入缓冲"></a>插入缓冲</h4><p>innodb使用insert buffer”欺骗”数据库:对于为非唯一索引，辅助索引的修改操作并非实时更新索引的叶子页,而是把若干对同一页面的更新缓存起来做合并为一次性更新操作,转化随机IO 为顺序IO,这样可以避免随机IO带来性能损耗，提高数据库的写性能。</p><p><img src="https://box.kancloud.cn/d68efa9ed3220fc7016e36450b2a534e_826x388.png" alt=""></p><p>IBUF_POOL_SIZE_PER_MAX_SIZE参数修改默认为2 即为最大缓存为1/2 如果将其改为3 这最大能够使用1/3的缓存池内存。</p><h5 id="聚簇索引与非聚簇索引的区别"><a href="#聚簇索引与非聚簇索引的区别" class="headerlink" title="聚簇索引与非聚簇索引的区别"></a>聚簇索引与非聚簇索引的区别</h5><p>聚集索引的叶子节点存储的是数据，而且是按照物理顺序存储的;非聚集索引叶子节点是地址(也就是聚集索引键地址)，是按照逻辑顺序存储的(以上言论是从网上了解到的，但是，聚集索引也不是按照物理地址连续的，而是逻辑上连续的)。</p><h5 id="高并发后的insert会发生什么？"><a href="#高并发后的insert会发生什么？" class="headerlink" title="高并发后的insert会发生什么？"></a>高并发后的insert会发生什么？</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t ( id int auto_increment, </span><br><span class="line">name varchar(30),primary key (id),key(name));  </span><br><span class="line">Query OK, 0 rows affected (0.21 sec)</span><br></pre></td></tr></table></figure><p>我们知道，主键是行唯一的标识符，在应用程序中行记录的插入顺序是按照主键递增的顺序进行插入的。因此，插入聚集索引一般是顺序的，不需要磁盘的随机读取，速度会很快，但是我们看到上一个表还有一个叫做name的索引字段，这样的情况下产生了一个非聚集的并且不是唯一的索引。在进行插入操作时，数据页的存放还是按主键id的执行顺序存放，但是对于非聚集索引，叶子节点的插入不再是顺序的了。这时就需要离散地访问非聚集索引页，插入性能在这里变低了。然而这并不是这个name字段上索引的错误，是因为B+树的特性决定了非聚集索引插入的离散性</p><h5 id="插入缓冲的实现"><a href="#插入缓冲的实现" class="headerlink" title="插入缓冲的实现"></a>插入缓冲的实现</h5><p><img src="http://www.plantuml.com/plantuml/svg/LKvB2e906DxFAMPfLz1TkuuHD98G5iwqQ5U14j6Bx06zo22em5wOA5YdyH_r5WtOfc_vlIah6mp9V3m5yyXx2xxs-EAk84t5KhRTfPrLjhOIxm3HF7DUi3abaGtMap_sSU0MCAiI7KijGWi82yY9Y8-EUPk2I8qIBEdrdyXd7q77GJiEBYMT4eFXObDLYG6tC7queb39ZN1TyQN_RvaEqey9_NF-1SO-k9Eqtqsw8Knw4FhS7iRlZTZKAvgAAAitlW00" alt=""></p><p>在innodb的1.0x版本开始，引入了change buffer，可以把它看成insert buffer的升级版，innodb可以对DML操作-INSERT/DELETE/UPDATE都进行缓冲。<br>1.将一个辅助索引插入到页(space,offset)<br>2.检查这个页是否在缓冲池中<br>在:直接插入<br>不在:继续<br>3.缓存进入insert buffer<br>4.构造一个search key<br>5.查询insert buffer树<br>6.生成逻辑记录并插入树中</p><h5 id="insert-buffer内部实现原理"><a href="#insert-buffer内部实现原理" class="headerlink" title="insert buffer内部实现原理"></a>insert buffer内部实现原理</h5><p>在mysql4.1版本之后，insert buffer是通过一全局唯一的一个B+树进行管理所有表的辅助索引。而这颗树存放在共享表空间中，格式为ibdata1，所以如果试图通过独立表空间idb文件恢复表中数据的时候，往往会导致CHECK TABLE失败，这是因为表的辅助索引中的数据可能还在INSERT BUFFER中，也就是共享表空间中，所以通过ibd文件进行恢复后，还需要进行REPAIR TABLE 操作来重建表上所有的辅助索引。</p><p>insert buffer的b+树的非叶子节点存放的是查询的search key（键值），其构造如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mysql/8.png" alt=""></p><ul><li>space为表空间id</li><li>marker用来兼容老版本</li><li>offset表示页所在偏移量</li></ul><p>叶子节点会比非叶子节点多俩数据，一个是metadata，一个是secondary index record。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mysql/7.png" alt=""></p><ul><li>metadata 记录的每一列的类型,长度</li><li>secondary index record 记录的具体值</li></ul><p>为了保证每个辅助索引页Merge Insert Buffer的B+树必须成功，还需要有一个特殊的页用来标记每个辅助索引页（space，page_no）的可用空间。这个页的类型为Insert Buffer Bitmap。它会标记16385个辅助索引页，每个辅助索引页会在其中占用4bit的位置来记录信息，具体信息如下：</p><p>Merge Insert Buffer的操作可能发生在以下几种情况下：</p><ul><li>辅助索引页被读取到缓冲池时；</li><li>Insert Buffer Bitmap页追踪到该辅助索引页已无可用空间时；</li><li>Master Thread。</li></ul><p>第一种情况为当辅助索引页被读取到缓冲池中时，例如这在执行正常的SELECT查询操作，这时需要检查Insert Buffer Bitmap页，然后确认该辅助索引页是否有记录存放于Insert Buffer B+树中。若有，则将Insert Buffer B+树中该页的记录插入到该辅助索引页中。可以看到对该页多次的记录操作通过一次操作合并到了原有的辅助索引页中，因此性能会有大幅提高。<br>Insert Buffer Bitmap页用来追踪每个辅助索引页的可用空间，并至少有1/32页的空间。若插入辅助索引记录时检测到插入记录后可用空间会小于1/32页，则会强制进行一个合并操作，即强制读取辅助索引页，将Insert Buffer B+树中该页的记录及待插入的记录插入到辅助索引页中。这就是上述所说的第二种情况。<br>还有一种情况，之前在分析Master Thread时曾讲到，在Master Thread线程中每秒或每10秒会进行一次Merge Insert Buffer的操作，不同之处在于每次进行merge操作的页的数量不同。</p><h5 id="缓冲的限制条件"><a href="#缓冲的限制条件" class="headerlink" title="缓冲的限制条件"></a>缓冲的限制条件</h5><p>插入缓冲的启用需要满足一下两个条件：<br>1）索引是辅助索引（secondary index）<br>2）索引不适合唯一的<br>原因是因为插入缓冲本身就是为了解决二级索引离散插入的问题，所以建立一个缓冲区将部分离散的索引数据合并，使用一次大的IO操作统一刷到磁盘，如果索引是唯一的，那这么做将失去意义，而且每次还需要去询问数据页是否已经存在，还会增加额外的IO操作。</p><h5 id="插入缓冲性能影响"><a href="#插入缓冲性能影响" class="headerlink" title="插入缓冲性能影响"></a>插入缓冲性能影响</h5><p>任何一项技术在带来好处的同时，必然也带来坏处。插入缓冲主要带来如下两个坏处：<br>1）可能导致数据库宕机后实例恢复时间变长。如果应用程序执行大量的插入和更新操作，且涉及非唯一的聚集索引，一旦出现宕机，这时就有大量内存中的插入缓冲区数据没有合并至索引页中，导致实例恢复时间会很长。<br>2）在写密集的情况下，插入缓冲会占用过多的缓冲池内存，默认情况下最大可以占用1/2，这在实际应用中会带来一定的问题。</p><h5 id="观察"><a href="#观察" class="headerlink" title="观察"></a>观察</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">engine</span> <span class="keyword">innodb</span> <span class="keyword">status</span>\g;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> BUFFER <span class="keyword">AND</span> ADAPTIVE <span class="keyword">HASH</span> <span class="keyword">INDEX</span></span><br><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line">Ibuf: <span class="keyword">size</span> <span class="number">1</span>, free <span class="keyword">list</span> <span class="keyword">len</span> <span class="number">0</span>, seg <span class="keyword">size</span> <span class="number">2</span>, <span class="number">2</span> merges</span><br><span class="line">merged <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">0</span>, <span class="keyword">delete</span> mark <span class="number">0</span>, <span class="keyword">delete</span> <span class="number">0</span></span><br><span class="line">discarded <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">0</span>, <span class="keyword">delete</span> mark <span class="number">0</span>, <span class="keyword">delete</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">34679</span>, node <span class="keyword">heap</span> has <span class="number">0</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">34679</span>, node <span class="keyword">heap</span> has <span class="number">0</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">34679</span>, node <span class="keyword">heap</span> has <span class="number">1</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">34679</span>, node <span class="keyword">heap</span> has <span class="number">0</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">34679</span>, node <span class="keyword">heap</span> has <span class="number">1</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">34679</span>, node <span class="keyword">heap</span> has <span class="number">0</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">34679</span>, node <span class="keyword">heap</span> has <span class="number">0</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">34679</span>, node <span class="keyword">heap</span> has <span class="number">0</span> buffer(s)</span><br><span class="line"><span class="number">0.00</span> <span class="keyword">hash</span> searches/s, <span class="number">0.00</span> non-<span class="keyword">hash</span> searches/s</span><br></pre></td></tr></table></figure><p>从上面可以看到其中有一部分叫做INSERT BUFFER AND ADAPTIVE HASH INDEX，其中的seg size指的就是当前insert buffer的大小，具体计算方式为seg_size*16KB =32KB，free list len表示空闲列表的长度，size表示已经合并记录页的数量。</p><h4 id="二次写（double-write）"><a href="#二次写（double-write）" class="headerlink" title="二次写（double write）"></a>二次写（double write）</h4><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p>doublewrite由两部分组成,一部分是内存的doublewrite buffer,大小为2MB,另一部分是物理磁盘上共享表空间中联系的128个页,即2个区(extent),大小同样为2MB。<br>脏读刷新先复制到内存中的doublewrite buffer，之后doublewrite buffer再分两次，每次1MB写入共享表空间的物理磁盘，然后马上调用fsync函数，同步磁盘，避免缓冲写带来的问题。如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mysql/12.png" alt=""></p><p>通过命令SHOW GLOBAL STATUS LIKE ‘innodb dblwr%’\G观察doublewrite运行的情况。</p><h5 id="页断裂（partial-write）"><a href="#页断裂（partial-write）" class="headerlink" title="页断裂（partial write）"></a>页断裂（partial write）</h5><p>所谓页断裂是数据库宕机时(OS重启，或主机掉电重启)，数据库页面只有部分写入磁盘，导致页面出现不一致的情况。那么为什么会不一样呢？因为数据库，OS和磁盘读写的基本单位是块，也可以称之为(page size)block size。我们知道数据库的块一般为8K，16K；而OS的块则一般为4K；IO块则更小，linux内核要求IO block size&lt;=OS block size。磁盘IO除了IO block size，还有一个概念是扇区(IO sector)，扇区是磁盘物理操作的基本单位，而IO 块是磁盘操作的逻辑单位，一个IO块对应一个或多个扇区，扇区大小一般为512个字节。所以各个块大小的关系可以梳理如下：<br>DB block &gt; OS block &gt;= IO block &gt; 磁盘 sector，而且他们之间保持了整数倍的关系。所以说当数据库突然宕机，就会造成部分DB block的数据实际上并未写入到磁盘的sector中，出现了页断裂的情况，进而导致数据不一致的现象。</p><h5 id="数据库日志的三种格式"><a href="#数据库日志的三种格式" class="headerlink" title="数据库日志的三种格式"></a>数据库日志的三种格式</h5><p>数据库系统实现日志主要有三种格式，逻辑日志(logical logging)，物理日志(physical logging)，物理逻辑日志(physiological logging)，逻辑日志，记录一个个逻辑操作，不涉及物理存储位置信息，比如mysql的binlog；物理日志，则是记录一个个具体物理位置的操作，比如在2号表空间，1号文件，48页的233这个offset地方写入了8个字节的数据，通过(group_id,file_id,page_no,offset)4元组，就能唯一确定数据存储在磁盘的物理位置；物理逻辑日志是物理日志和逻辑日志的混合，如果一个数据库操作(DDL，DML，DCL)产生的日志跨越了多个页面，那么会产生多个物理页面的日志，但对于每个物理页面日志，里面记录则是逻辑信息。这里我举一个简单的INSERT操作来说明几种日志形式。<br>比如innodb表T(c1,c2, key key_c1(c1)),插入记录row1(1,’abc’)<br>逻辑日志：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert OP, T, 1,’abc’&gt;</span><br></pre></td></tr></table></figure><p>逻辑物理日志：因为表T含有索引key_c1, 一次插入操作至少涉及两次B树操作，二次B树必然涉及至少两个物理页面,因此至少有两条日志</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert OP, page_no_1, log_body&gt;</span><br><span class="line">&lt;insert OP, page_no_2, log_body&gt;</span><br></pre></td></tr></table></figure><p>物理理日志：由于一次INSERT操作，物理上来说要修改页头信息(如,页内的记录数要加1)，要修改相邻记录里的链表指针，要修改Slot属性等，因此对应逻辑物理日志的每一条日志，都会有N条物理日志产生。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt; group_id,file_id,page_no,offset1, value1&gt;</span><br><span class="line">&lt; group_id,file_id,page_no,offset2, value2&gt;</span><br><span class="line">……</span><br><span class="line">&lt; group_id,file_id,page_no,offsetN, valueN&gt;</span><br></pre></td></tr></table></figure><p>因此对于上述一个INSERT操作，会产生一条逻辑日志，二条逻辑物理日志，2*N条物理日志。从上面简单的分析可以看出，逻辑日志的日志量最小，而物理日志的日志量最大；物理日志是纯物理的；而逻辑物理日志则页间物理，页内逻辑，所谓physical-to-a-page, logical-within-a-page。</p><h5 id="页断裂和数据一致性"><a href="#页断裂和数据一致性" class="headerlink" title="页断裂和数据一致性"></a>页断裂和数据一致性</h5><p>前面我们分析了异常重启导致页断裂的原因，而页断裂就意味着数据库页面不完整，那么数据库页面不完整就意味着数据库不一致。我们知道，数据库异常重启时，自身有异常恢复机制，主流数据库基本原理类似：第一阶段重做redo日志，恢复数据页和undo页到异常crash时的状态；第二阶段，根据undo页的内容，回滚没有提交事务的修改。通过两个阶段保证了数据库的一致性。对于mysql而言，在第一阶段，若出现页断裂问题，则无法通过重做redo日志恢复，进而导致恢复中断，数据库不一致。这里大家可能会有疑问，数据库的redo不是记录了所有的变更，并且是物理的吗？理论上来说，无论页面是否断裂，从上一个检查点对应的redo位置开始，一直重做redo，页面自然能恢复到正常状态。对吗？</p><h5 id="redo格式与数据一致性"><a href="#redo格式与数据一致性" class="headerlink" title="redo格式与数据一致性"></a>redo格式与数据一致性</h5><p>回到“发生页断裂后，是否会影响数据库一致性”的问题，发生页断裂后，对于利用纯物理日志实现redo的数据库不受影响，因为每一条redo日志完全不依赖物理页的状态，并且是幂等的(执行一次与N次，结果是一样的)，而逻辑物理日志则不行，比如修改页头信息，页内记录数加1，slot信息修改等都依赖于页面处于一个一致状态，否则就无法正确重做redo。而mysql正是采用这种日志类型，另外要说明一点，redo日志的页大小一般设计为512个字节，因此redo日志页本身不会发生页断裂。所以发生页面断裂时，异常恢复就会出现问题，需要借助于double write技术来辅助处理。</p><h5 id="doubleWrite的实现"><a href="#doubleWrite的实现" class="headerlink" title="doubleWrite的实现"></a>doubleWrite的实现</h5><p>在InnoDB将BP中的Dirty Page刷（flush）到磁盘上时，首先会将（memcpy函数）Page刷到InnoDB tablespace的一个区域中，我们称该区域为Double write Buffer（大小为2MB，每次写入1MB，128个页，每个页16k,其中120个页为后台线程的批量刷Dirty Page，还有8个也是为了前台起的sigle Page Flash线程，用户可以主动请求，并且能迅速的提供空余的空间）。在向Double write Buffer写入成功后，第二步、再将数据分别刷到一个共享空间和真正应该存在的位置。具体的流程如下图所示：<br><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mysql/9.png" alt=""></p><h5 id="doubleWrite的保护机制"><a href="#doubleWrite的保护机制" class="headerlink" title="doubleWrite的保护机制"></a>doubleWrite的保护机制</h5><p>下面来看下在不同的写入阶段，操作系统crash后，double write带来的保护机制：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mysql/10.png" alt=""></p><p>阶段一：copy过程中，操作系统crash，重启之后，脏页未刷到磁盘，但更早的数据并没有发生损坏，重新写入即可阶段二：write到共享表空间过程中，操作系统crash，重启之后，脏页未刷到磁盘，但更早的数据并没有发生损坏，重新写入即可阶段三：write到独立表空间过程中，操作系统crash，重启之后，发现：（1）数据文件内的页损坏：头尾checksum值不匹配（即出现了partial page write的问题）。从共享表空间中的doublewrite segment内恢复该页的一个副本到数据文件，再应用redo log；（2）若页自身的checksum匹配，但与doublewrite segment中对应页的checksum不匹配，则统一可以通过apply redo log来恢复。）阶段X：recover过程中，操作系统crash，重启之后，innodb面对的情况同阶段三一样（数据文件损坏，但共享表空间内有副本），再次应用redo log即可。</p><h5 id="doubleWrite对性能的影响"><a href="#doubleWrite对性能的影响" class="headerlink" title="doubleWrite对性能的影响"></a>doubleWrite对性能的影响</h5><p>系统需要将数据写两份，一般认为，Double Write是会降低系统性能的。peter猜测可能会有5-10%的性能损失，但是因为实现了数据的一致，是值得的。Mark Callaghan认为这应该是存储层面应该解决的问题，放在数据库层面无疑是牺牲了很多性能的。事实上，Double Write对性能影响并没有你想象（写两遍性能应该降低了50%吧？）的那么大。在BP中一次性往往会有很多的Dirty Page同时被flush，Double Write则把这些写操作，由随机写转化为了顺序写。而在Double Write的第二个阶段，因为Double Write Buffer中积累了很多Dirty Page，所以向真正的数据文件中写数据的时候，可能有很多写操作可以合并，这样有可能会降低Fsync的调用次数。基于上面的原因，Double Write并没有想象的那么糟。最后发现打开和关闭Double Write对效率的影响并不大。</p><h4 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h4><p>哈希索引只有Memory, NDB两种引擎支持，Memory引擎默认支持哈希索引，如果多个hash值相同，出现哈希碰撞，那么索引以链表方式存储。但是，Memory引擎表只对能够适合机器的内存切实有限的数据集。要使InnoDB或MyISAM支持哈希索引，可以通过伪哈希索引来实现，但是innodb还实现了一种叫做自适应哈希索引来达到目的。<br>InnoDB存储引擎会监控对表上各索引页的查询。如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引(Adaptive Hash Index, AHI)。AHI是通过缓冲池的B+树页构造而来，因此建立的速度很快，而且不需要对整张表构建哈希索引。InnoDB存储引擎会自动根据访问的频率和模式来自动地为某些热点页建立哈希索引。</p><h5 id="状态监控"><a href="#状态监控" class="headerlink" title="状态监控"></a>状态监控</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G</span><br><span class="line">……</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">0.00 hash searches/s, 0.00 non-hash searches/s</span><br></pre></td></tr></table></figure><p>1、34673：字节为单位，占用内存空间总量</p><p>2、通过hash searches、non-hash searches计算自适应hash索引带来的收益以及付出，确定是否开启自适应hash索引</p><h5 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h5><p>　　1、只能用于等值比较，例如=， &lt;=&gt;，in<br>　　2、无法用于排序<br>　　3、有冲突可能<br>　　4、MySQL自动管理，人为无法干预。</p><h5 id="自适应哈希索引的控制"><a href="#自适应哈希索引的控制" class="headerlink" title="自适应哈希索引的控制"></a>自适应哈希索引的控制</h5><p>由于innodb不支持hash索引，但是在某些情况下hash索引的效率很高，于是出现了adaptive hash index功能，但是通过上面的状态监控，可以计算其收益以及付出，控制该功能开启与否。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mysql/11.png" alt=""></p><h4 id="其他关键特性"><a href="#其他关键特性" class="headerlink" title="其他关键特性"></a>其他关键特性</h4><h5 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h5><p>为了提高磁盘操作性能，当前的数据库系统都采用异步IO（Asynchronous IO,AIO）的方式来处理磁盘操作。<br>与AIO对应的是 Sync IO，Sync IO每次进行IO操作 需要等到改操作结束才能继续接下来的操作。但是如果用户是一条索引扫描的查询，那么需要扫描索引页，也就是需要进行多次的IO操作。如果是这样的话就没有必要了。</p><p>用户发送一个IO请求就可以发送另一个IO请求，当全部发送完毕，等待所有的IO操作的完成，这就是AIO。<br>AIO的另一个优势 可以进行IO Merge操作，也就是将多个IO何必为一个IO。<br>若通过Linux操作系统下的iostat 命令 可以观察 rrqm/s和wrqm/s。<br>InnoDB 1.1.x 开始（InnoDB Plugin 不支持）提供了内核级别AIO的支持，称为 NatIve AIO。因此编译或者运行该版本MySQL时需要libaio的支持。若没有则会出现如下的提示：</p><p><img src="https://box.kancloud.cn/caa0fef240a025c16fbe4d9d842f0009_846x84.png" alt=""></p><p>Native AIO只有windows 和linux系统支持。Mac OSX不支持。参数innodb_use_native_aio 控制师傅启动 liunx默认不启动。</p><p>SHOW VARIABLES LIKE ‘innodb_use_native_aio’\G</p><p><img src="https://box.kancloud.cn/18a374770ed2be0874341ccf079c9cf2_677x117.png" alt=""></p><p>官方显示，启用NatIve AIO，恢复速度可以提高75%。<br>read ahead方式读取都是通过AIO完成，脏页的刷新和磁盘写入操作则全部由AIO完成。</p><h5 id="刷新邻接页"><a href="#刷新邻接页" class="headerlink" title="刷新邻接页"></a>刷新邻接页</h5><p>InnoDB存储引擎还提供了Flush Neighbor Page(刷新邻接页)的特性。工作原理：当刷新脏页时，InnoDB存储引擎会检测所在区的所有页，如果是脏页，那么一起进行刷新。<br>参数innodb_flush_neighbors 控制是否启用改特性.如果是机械硬盘建议启用，如果是固态硬盘就不建议使用 IOPS性能的磁盘 则建议设置为0，关闭此特性。</p><h5 id="启动、关闭和恢复"><a href="#启动、关闭和恢复" class="headerlink" title="启动、关闭和恢复"></a>启动、关闭和恢复</h5><p>关闭时参数innodb_fast_shutdown影响着表存储引擎InnoDB的行为。该参数可取值为0、1、2，默认为1</p><p><img src="https://box.kancloud.cn/fc3c79f738da0285b045df30098e7257_824x319.png" alt=""></p><p>当正常关闭MySQL数据库时，下次的启动应该会非常“正常”。但是没有正常关闭 如用kill命令关闭数据库，在MySQL 数据库运行中重启服务器，或者关闭数据库时，将参数innodb_fast_shuidown设为了2时,下次MySQL数据库启动时都会对InnoDB存储引擎的表进行恢复操作。</p><p>参数innodb_force_recovery影响了正规InnoDB存储引擎恢复的状况。默认为0，代表当发生需要恢复时，进行所有恢复的操作，当不能进行有效恢复时，如数据页发送了corruption，MySQL数据库可能发送宕机（crash），并把错误写入错误日志中去。</p><p>如果用户知道怎么进行恢复 比如进行alter table操作是发生意外了，数据库重启会对InnoDB进行回滚操作，对于大表涞水需要很长时间，所以可以把表删除，从备份中导入数据到表。速度就会比回滚操作快。</p><p><img src="https://box.kancloud.cn/9b3c7309d263250656fdfb9387f8fbf9_804x237.png" alt=""></p><p>如果innodb_force_recovery 设置为3 则不需要回滚,因此数据库很快就启动完成了。 但是需要仔细确认是否需要回滚事务操作。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务的特性和隔离级别</title>
      <link href="/2020/01/28/mysql2/"/>
      <url>/2020/01/28/mysql2/</url>
      
        <content type="html"><![CDATA[<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>在执行SQL语句的时候，某些业务要求，一系列操作必须全部执行，而不能仅执行一部分。例如，一个转账操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 从id=1的账户给id=2的账户转账100元</span></span><br><span class="line"><span class="comment">-- 第一步：将id=1的A账户余额减去100</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance = balance - <span class="number">100</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 第二步：将id=2的B账户余额加上100</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance = balance + <span class="number">100</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>这两条SQL语句必须全部执行，或者，由于某些原因，如果第一条语句成功，第二条语句失败，就必须全部撤销。</p><p>这种把多条语句作为一个整体进行操作的功能，被称为数据库<strong>事务</strong>。数据库事务可以确保该事务范围内的所有操作都可以全部成功或者全部失败。如果事务失败，那么效果就和没有执行这些SQL一样，不会对数据库数据有任何改动。</p><h3 id="事务管理-ACID"><a href="#事务管理-ACID" class="headerlink" title="事务管理(ACID)"></a>事务管理(ACID)</h3><p>讲到事务，一般就有一些评判标准，就像volatile有一致性和可见性而没有原子性一样，对于事务，也有四种特性：</p><h4 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h4><p>这个原子性和并发中的原子性类似，但不完全一样。并发中的原子性表示操作不可分割，要么执行完，要么不执行。这个放在数据库也是一样的：</p><p>举个例子，A向B转账，会出现两个步骤：</p><ul><li>A扣除100块</li><li>B获得100块</li></ul><p>这两个步骤要么不执行，要么一起执行，这就是原子性。</p><h4 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h4><p>就以上面的例子而言，一致性就是必须符合运算逻辑：</p><ul><li>A必须扣除的数值是100，而不是90或者是其他数值。</li><li>B收到的数值必须是A扣除的数值，假如A因特殊原因只扣到50，B也只能收到50。</li></ul><h4 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a><strong>持久性（Durability）</strong></h4><p>表示事务结束后的数据不随着外界原因导致数据丢失</p><p>操作前A：800，B：200<br>操作后A：600，B：400<br>如果在操作前（事务还没有提交）服务器宕机或者断电，那么重启数据库以后，数据状态应该为<br>A：800，B：200<br>如果在操作后（事务已经提交）服务器宕机或者断电，那么重启数据库以后，数据状态应该为<br>A：600，B：400</p><h4 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a><strong>隔离性（Isolation）</strong></h4><p>针对多个用户同时操作，主要是排除其他事务对本次事务的影响。就比如多个事务同时进行，存在ABCD互相转账，要根据实际情况来进行数据的隔离。</p><h3 id="隔离的级别"><a href="#隔离的级别" class="headerlink" title="隔离的级别"></a>隔离的级别</h3><h4 id="未提交读（Read-uncommitted）"><a href="#未提交读（Read-uncommitted）" class="headerlink" title="未提交读（Read uncommitted）"></a>未提交读（Read uncommitted）</h4><p>未提交读是最低的隔离级别，但这种隔离级别有着最高的效率，在这种情况允许一个未提交的事务去读取另一个未提交的事务，可以让一个事务被数据库处理之前，已经把两个事务应该处理的数据处理完毕。</p><p>但是如此高效率的处理方式，容易引起一个糟糕的现象，叫做脏读：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mysql/1.png" alt=""></p><p>在T3时刻，事务2去读取了事务1的数据，并进行了处理，然后提交。但是这个时候，如果发生了因为第一类丢失更新而导致的回滚，（第一类丢失更新是指在高并发情况下产生的数据丢不一致，但现已经被克服，所以会产生回滚），但是因为数据是在事务2被处理完成的，如果将事务1进行回滚，将不会回滚为2，而是直接为0。这样会导致最后的订单数少于总库存量。</p><p>还有一种情况下：</p><ul><li><p>T1 事务读取账户余额 100 块，取钱，将余额修改为 50 块，但并没有提交。</p></li><li><p>T2 事务读取了 <strong>尚未提交</strong> 的数据，认为余额是 50 块。</p></li><li><p>T1 事务回滚。</p></li><li><p>T2 事务存钱 100 块，将余额计算为 50 + 100 = 150 块，此为脏数据，实际余额应该为 200 块。</p></li></ul><p>在高并发情况下，很容易会发生第一类丢失更新，这个时候，事务1执行过程中修改了数据X，在未提交前，事务2读取了X，而事务1却回滚了，这样事务2就形成了脏读。也就是说，当前事务读到的数据是别的事务想要修改成为的但是没有修改成功的数据。</p><h4 id="读写提交（Read-committed）"><a href="#读写提交（Read-committed）" class="headerlink" title="读写提交（Read committed）"></a>读写提交（Read committed）</h4><p>是指一个事务只能读取到另外一个事务已经提交的数据。</p><p>就以上述例子而言，因为总是读取到尚未提交的数据，才导致的数据不一致，那么，就只读取已经提交的数据便可以的，如此克服脏读：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mysql/2.png" alt=""></p><p>但是读写提交也会导致下面的问题：那就是当我们事务2读取到了库存之后，事务1马上提交事务，导致事务2读取到的库存是脏的、错误的库存。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mysql/3.png" alt=""></p><p>T3时刻读取到库存为1，由于事务尚未提交，所以就导致了事务2误以为还能够进行减库存，但随之事务1便进行了提交，最后发现减库存失败的现象，这种现象会导致订单的数量多于商品的库存量。</p><h4 id="可重复读（Repeatable-Read）"><a href="#可重复读（Repeatable-Read）" class="headerlink" title="可重复读（Repeatable Read）"></a>可重复读（Repeatable Read）</h4><p><strong>这正是 MySQL InnoDB 的默认事务隔离级别</strong><br>它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。同时也克服了不可重读的场景：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mysql/4.png" alt=""></p><p>此级别可能出现的问题——幻读（Phantom Read）：当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mysql/5.png" alt=""></p><p>很多人容易搞混不可重复读和幻读，确实这两者有些相似。但不可重复读重点在于 update 和 delete，而幻读的重点在于 insert。</p><p>InnoDB 存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题</p><h4 id="可串行化（Serializable）"><a href="#可串行化（Serializable）" class="headerlink" title="可串行化（Serializable）"></a>可串行化（Serializable）</h4><ul><li>这是最高的隔离级别</li><li>它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之,它是在每个读的数据行上加上共享锁。</li><li>在这个级别，可能导致大量的超时现象和锁竞争</li></ul><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mysql/6.png" alt=""></p><p>InnoDB 实现方式：这种事务的隔离级别下，所有 select 语句都会被隐式的转化为 select … in share mode。</p><p><strong>首先这些读数据读错了，但是不管脏读，不可重复读，还是幻读，都是读操作似乎不会对数据库的数据造成影响，但是我们代码里面有后续的操作，一般都要用读出来的值进行对数据加工处理，然后就会对数据造成影响。</strong></p><p>在SpingBoot中，可以通过application.yml来统一设置事务的隔离级别，也可以在方法上使用@Translational（isolation=isolation.Serializable），指定事务的隔离级别。</p><h3 id="InnoDB下幻读是如何在RR级别下被解决的？"><a href="#InnoDB下幻读是如何在RR级别下被解决的？" class="headerlink" title="InnoDB下幻读是如何在RR级别下被解决的？"></a>InnoDB下幻读是如何在RR级别下被解决的？</h3><p><strong>RR(Repeatable Read)</strong> </p><p>一个事务A在事务执行过程中第一次读取的值和第二次读取的值一致（解决了不可重复读），但是其他事务B 的insert 或者 delete的操作，会影响到俩次查询的条数（现象：幻读）</p><h4 id="MVCC实现原理"><a href="#MVCC实现原理" class="headerlink" title="MVCC实现原理"></a>MVCC实现原理</h4><p>MVCC(Multi Version Concurrency Control的简称)，代表多版本并发控制。与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control)。<br>MVCC最大的优势：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能</p><p><strong>MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number)。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</strong><br> 下面看一下在REPEATABLE READ隔离级别下，MVCC具体是如何操作的。</p><ul><li><p>SELECT</p><p>InnoDB会根据以下两个条件检查每行记录：</p><ol><li>InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。</li><li>行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。</li></ol><p>只有符合上述两个条件的记录，才能返回作为查询结果</p></li><li><p>INSERT</p><p>InnoDB为新插入的每一行保存当前系统版本号作为行版本号。</p></li><li><p>DELETE</p><p>InnoDB为删除的每一行保存当前系统版本号作为行删除标识。</p></li><li><p>UPDATE</p><p>InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。<br> 保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作</p></li></ul><h4 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> mvcctest( </span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment, </span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>));</span><br></pre></td></tr></table></figure><p><strong>transaction 1:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mvcctest <span class="keyword">values</span>(<span class="literal">NULL</span>,<span class="string">'mi'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mvcctest <span class="keyword">values</span>(<span class="literal">NULL</span>,<span class="string">'kong'</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>假设系统初始事务ID为1:</p><table><thead><tr><th>ID</th><th>NAME</th><th>创建时间</th><th>过期时间</th></tr></thead><tbody><tr><td>1</td><td>mi</td><td>1</td><td>undefined</td></tr><tr><td>2</td><td>kong</td><td>1</td><td>undefined</td></tr></tbody></table><p><strong>transaction 2:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> mvcctest;  //(1)</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> mvcctest;  //(2)</span><br><span class="line"><span class="keyword">commit</span></span><br></pre></td></tr></table></figure><h5 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h5><p>假设当执行事务2的过程中，准备执行语句(2)时，开始执行事务3：</p><p><strong>transaction 3:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mvcctest <span class="keyword">values</span>(<span class="literal">NULL</span>,<span class="string">'qu'</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>ID</th><th>NAME</th><th>创建时间</th><th>过期时间</th></tr></thead><tbody><tr><td>1</td><td>mi</td><td>1</td><td>undefined</td></tr><tr><td>2</td><td>kong</td><td>1</td><td>undefined</td></tr><tr><td>3</td><td>qu</td><td>3</td><td>undefined</td></tr></tbody></table><p>事务3执行完毕，开始执行事务2 语句2，由于事务2只能查询创建时间小于等于2的，所以事务3新增的记录在事务2中是查不出来的，这就通过乐观锁的方式避免了幻读的产生</p><h5 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h5><p>假设当执行事务2的过程中，准备执行语句(2)时，开始执行事务4：</p><p><strong>transaction session 4:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">update</span> mvcctest <span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">'fan'</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>InnoDB执行UPDATE，实际上是新插入了一行记录，并保存其创建时间为当前事务的ID，同时保存当前事务ID到要UPDATE的行的删除时间</p><table><thead><tr><th>ID</th><th>NAME</th><th>创建时间</th><th>过期时间</th></tr></thead><tbody><tr><td>1</td><td>mi</td><td>1</td><td>undefined</td></tr><tr><td>2</td><td>kong</td><td>1</td><td>4</td></tr><tr><td>2</td><td>fan</td><td>4</td><td>undefined</td></tr></tbody></table><p>事务4执行完毕，开始执行事务2 语句2，由于事务2只能查询创建时间小于等于2的，所以事务修改的记录在事务2中是查不出来的，这样就保证了事务在两次读取时读取到的数据的状态是一致的</p><h5 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h5><p>假设当执行事务2的过程中，准备执行语句(2)时，开始执行事务5：</p><p><strong>transaction session 5:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> mvcctest <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>ID</th><th>NAME</th><th>创建时间</th><th>过期时间</th></tr></thead><tbody><tr><td>1</td><td>mi</td><td>1</td><td>undefined</td></tr><tr><td>2</td><td>kong</td><td>1</td><td>5</td></tr></tbody></table><p>事务5执行完毕，开始执行事务2 语句2，由于事务2只能查询创建时间小于等于2、并且过期时间大于等于2，所以id=2的记录在事务2 语句2中，也是可以查出来的,这样就保证了事务在两次读取时读取到的数据的状态是一致的</p><h4 id="InnoDB锁机制"><a href="#InnoDB锁机制" class="headerlink" title="InnoDB锁机制"></a>InnoDB锁机制</h4><p>  数据库使用锁是为了支持更好的并发，提供数据的完整性和一致性。InnoDB是一个支持行锁的存储引擎，锁的类型有：共享锁（S）、排他锁（X）、意向共享（IS）、意向排他（IX）。为了提供更好的并发，<strong>InnoDB提供了非锁定读：不需要等待访问行上的锁释放，读取行的一个快照。</strong></p><p><strong>InnoDB有三种行锁的算法：</strong></p><h5 id="Record-Lock"><a href="#Record-Lock" class="headerlink" title="Record Lock"></a>Record Lock</h5><p>单个行记录上的锁。record lock锁住的永远是索引，而非记录本身，即使该表上没有任何索引，那么innodb会在后台创建一个隐藏的聚集主键索引，那么锁住的就是这个隐藏的聚集主键索引。所以说当一条sql没有走任何索引时，那么将会在每一条聚集索引后面加X锁，这个类似于表锁，但原理上和表锁应该是完全不同的。</p><h5 id="Gap-Lock"><a href="#Gap-Lock" class="headerlink" title="Gap Lock"></a>Gap Lock</h5><p>间隙锁定是对索引记录之间的间隙的锁定，或者是对第一个或最后一个索引记录之前的间隙的锁定。例如，<code>SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE;</code>防止其他事务将value <code>15</code>插入column中<code>t.c1</code>，无论该列 中是否已有这样的值，因为该范围中所有现有值之间的间隙都是锁定的。</p><p>间隙可能跨越单个索引值，多个索引值，甚至为空。</p><p>间隙锁是性能和并发性之间权衡的一部分，并且在某些事务隔离级别而非其他级别中使用。</p><p>对于使用唯一索引来锁定唯一行来锁定行的语句，不需要间隙锁定。（这不包括搜索条件仅包含多列唯一索引的某些列的情况；在这种情况下，会发生间隙锁定。）例如，如果该<code>id</code>列具有唯一索引，则以下语句仅使用一个具有<code>id</code>值100 的行的索引记录锁定，其他会话是否在前面的间隙中插入行并不重要：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">child</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>如果id未建立索引或索引不唯一，则该语句会锁定前面的间隙。</p><p>在这里还值得注意的是，可以通过不同的事务将冲突的锁保持在间隙上。例如，事务A可以在间隙上保留一个共享的间隙锁（间隙S锁），而事务B可以在同一间隙上保留排他的间隙锁（间隙X锁）。允许冲突的间隙锁的原因是，如果从索引中清除记录，则必须合并由不同事务保留在记录上的间隙锁。</p><p>间隙锁定InnoDB是“ 纯粹抑制性的 ”，这意味着它们的唯一目的是防止其他事务插入间隙。间隙锁可以共存。一个事务进行的间隙锁定不会阻止另一事务对相同的间隙进行间隙锁定。共享和专用间隙锁之间没有区别。它们彼此不冲突，并且执行相同的功能。</p><p>间隙锁定可以显式禁用。如果将事务隔离级别更改为，则会发生这种情况 READ COMMITTED。在这种情况下，将禁用间隙锁定来进行搜索和索引扫描，并且间隙锁定仅用于外键约束检查和重复键检查。</p><p>使用READ COMMITTED隔离级别还有其他影响 。MySQL评估WHERE条件后，将释放不匹配行的记录锁。对于 UPDATE语句，请InnoDB 执行“ 半一致 ”读取，以便将最新的提交版本返回给MySQL，以便MySQL可以确定行是否与的WHERE 条件匹配UPDATE。</p><h5 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next-Key Lock"></a>Next-Key Lock</h5><p>Next-Key Lock是索引记录上的记录锁定和索引记录之前的间隙上的间隙锁定的组合。</p><p>InnoDB执行行级锁定，以使其在搜索或扫描表索引时对遇到的索引记录设置共享或排他锁。因此，行级锁实际上是索引记录锁。索引记录上的Next-Key Lock也会影响该索引记录之前的“ 间隙 ”。即，Next-Key Lock是索引记录锁定加上索引记录之前的间隙上的间隙锁定。如果一个会话R在索引中的记录上具有共享或排他锁 ，则另一会话不能R在索引顺序之前的间隙中插入新的索引记录 。</p><p>假定索引包含值10、11、13和20。此索引的可能的Next-Key Lock涵盖以下间隔，其中，圆括号表示排除区间端点，方括号表示包括端点：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(negative infinity, 10]</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, positive infinity)</span><br></pre></td></tr></table></figure><p>对于最后一个间隔，Next-Key Lock将间隙锁定在索引中的最大值之上，并且“ supreumum ” 伪记录的值高于索引中实际的任何值。最高不是真正的索引记录，因此，实际上，此Next-Key Lock仅锁定最大索引值之后的间隙。</p><p>默认情况下，InnoDB以 REPEATABLE READ事务隔离级别运行。在这种情况下，请InnoDB使用next-key锁进行搜索和索引扫描。</p><p>用于Next-Key Lock事务数据出现类似于在下面SHOW ENGINE INNODB STATUS和 InnoDB的监视器 输出：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RECORD LOCKS space id 58 page no 3 n bits 72 index `PRIMARY` of table `test`.`t` </span><br><span class="line">trx id 10080 lock_mode X</span><br><span class="line">Record <span class="keyword">lock</span>, <span class="keyword">heap</span> <span class="keyword">no</span> <span class="number">1</span> <span class="keyword">PHYSICAL</span> <span class="built_in">RECORD</span>: n_fields <span class="number">1</span>; compact format; info bits 0</span><br><span class="line"> 0: len 8; hex 73757072656d756d; asc supremum;;</span><br><span class="line"></span><br><span class="line">Record <span class="keyword">lock</span>, <span class="keyword">heap</span> <span class="keyword">no</span> <span class="number">2</span> <span class="keyword">PHYSICAL</span> <span class="built_in">RECORD</span>: n_fields <span class="number">3</span>; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 1: len 6; hex 00000000274f; asc     'O;;</span><br><span class="line">2: len 7; hex b60000019d0110; asc        ;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL体系结构</title>
      <link href="/2020/01/27/mysql1/"/>
      <url>/2020/01/27/mysql1/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h2><p>现在来讲一讲数据库，数据库是虚拟世界与现实世界的第一层抽象。数据库在任何领域，都有着非常重要的作用，我们的身体、每一个器官、每一个细胞，都可以是一个数据库。数据库可以是世界上所有信息的载体，而并非仅仅只体现在计算机学科身上。</p><h3 id="数据库简介"><a href="#数据库简介" class="headerlink" title="数据库简介"></a>数据库简介</h3><h4 id="技术初衷"><a href="#技术初衷" class="headerlink" title="技术初衷"></a>技术初衷</h4><p>在操作系统出现之后，随着计算机应用范围的扩大、需要处理的数据迅速膨胀。最初，数据与程序一样，以简单的文件作为主要存储形式。以这种方式组织的数据在逻辑上更简单，但可扩展性差，访问这种数据的程序需要了解数据的具体组织格式。当系统数据量大或者用户访问量大时，应用程序还需要解决数据的完整性、一致性以及安全性等一系列的问题。因此，必须开发出一种系统软件，它应该能够像操作系统屏蔽了硬件访问复杂性那样，屏蔽数据访问的复杂性。由此产生了数据管理系统，即数据库。</p><h4 id="数据库管理系统"><a href="#数据库管理系统" class="headerlink" title="数据库管理系统"></a>数据库管理系统</h4><p>数据库管理系统（英语：Database Management System，简称DBMS）是为管理数据库而设计的电脑软件系统，一般具有存储、截取、安全保障、备份等基础功能。数据库管理系统可以依据它所支持的数据库模型来作分类，例如关系式、XML；或依据所支持的电脑类型来作分类，例如服务器聚类、移动电话；或依据所用查询语言来作分类，例如SQL、XQuery；或依据性能冲量重点来作分类，例如最大规模、最高运行速度；亦或其他的分类方式。不论使用哪种分类方式，一些DBMS能够跨类别，例如，同时支持多种查询语言。</p><h4 id="数据库的分类"><a href="#数据库的分类" class="headerlink" title="数据库的分类"></a>数据库的分类</h4><p>随着数据库技术与其他分支学科技术的结合，出现了多种新型数据库，例如：与分布处理技术结合产生的分布式数据库、与并行处理技术结合产生的并行数据库、与人工智能结合产生的演绎数据库、与多媒体技术结合产生的多媒体数据库。另外，数据库技术应用于特定的领域，出现了工程数据库、 地理数据库、统计数据库、空间数据库等特定领域数据库。</p><h5 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h5><ul><li>MySQL<ul><li><a href="https://zh.wikipedia.org/wiki/MariaDB" target="_blank" rel="noopener">MariaDB</a></li><li><a href="https://zh.wikipedia.org/w/index.php?title=Percona_Server&action=edit&redlink=1" target="_blank" rel="noopener">Percona Server</a></li></ul></li><li><a href="https://zh.wikipedia.org/wiki/PostgreSQL" target="_blank" rel="noopener">PostgreSQL</a></li><li><a href="https://zh.wikipedia.org/wiki/Microsoft_Access" target="_blank" rel="noopener">Microsoft Access</a></li><li><a href="https://zh.wikipedia.org/wiki/Microsoft_SQL_Server" target="_blank" rel="noopener">Microsoft SQL Server</a></li><li><a href="https://zh.wikipedia.org/w/index.php?title=Google_Fusion_Tables&action=edit&redlink=1" target="_blank" rel="noopener">Google Fusion Tables</a></li><li><a href="https://zh.wikipedia.org/wiki/FileMaker" target="_blank" rel="noopener">FileMaker</a></li><li><a href="https://zh.wikipedia.org/wiki/Oracle数据库" target="_blank" rel="noopener">Oracle数据库</a></li><li><a href="https://zh.wikipedia.org/wiki/Sybase" target="_blank" rel="noopener">Sybase</a></li><li><a href="https://zh.wikipedia.org/wiki/DBASE" target="_blank" rel="noopener">dBASE</a></li><li><a href="https://zh.wikipedia.org/wiki/Clipper" target="_blank" rel="noopener">Clipper</a></li><li><a href="https://zh.wikipedia.org/wiki/FoxPro" target="_blank" rel="noopener">FoxPro</a></li><li><a href="https://zh.wikipedia.org/w/index.php?title=Foshub&action=edit&redlink=1" target="_blank" rel="noopener">foshub</a></li></ul><p>几乎所有的数据库管理系统都配备了一个<a href="https://zh.wikipedia.org/wiki/開放式資料庫連接" target="_blank" rel="noopener">开放式数据库连接</a>（ODBC）驱动程序，令各个数据库之间得以互相集成。</p><h5 id="非关系数据库-NoSQL"><a href="#非关系数据库-NoSQL" class="headerlink" title="非关系数据库(NoSQL)"></a>非关系数据库(NoSQL)</h5><ul><li><p><a href="https://zh.wikipedia.org/wiki/BigTable" target="_blank" rel="noopener">BigTable</a>（Google）</p></li><li><p><a href="https://zh.wikipedia.org/wiki/Cassandra" target="_blank" rel="noopener">Cassandra</a></p></li><li><p><a href="https://zh.wikipedia.org/wiki/MongoDB" target="_blank" rel="noopener">MongoDB</a></p></li><li><p><a href="https://zh.wikipedia.org/wiki/CouchDB" target="_blank" rel="noopener">CouchDB</a></p></li><li><p><a href="https://zh.wikipedia.org/wiki/Redis" target="_blank" rel="noopener">Redis</a></p><p><strong>键值数据库</strong></p></li><li><p><a href="https://zh.wikipedia.org/wiki/Apache_Cassandra" target="_blank" rel="noopener">Apache Cassandra</a></p></li><li><p><a href="https://zh.wikipedia.org/w/index.php?title=Dynamo&action=edit&redlink=1" target="_blank" rel="noopener">Dynamo</a></p></li><li><p><a href="https://zh.wikipedia.org/wiki/LevelDB" target="_blank" rel="noopener">LevelDB</a>（Google）</p></li></ul><h4 id="数据库技术的发展"><a href="#数据库技术的发展" class="headerlink" title="数据库技术的发展"></a>数据库技术的发展</h4><p>随着互联网的普及，数据库使用环境也随之发生变化，这种变化主要体现为XML和Java技术的大量使用、要求支持各种互联网环境下的应用服务器、极容易出现大量用户同时访问数据库、要求支持7x24小时不间断运行和高安全性等。</p><p>为解决由于这些变化所带来的新问题，数据库管理系统也逐渐产生变化，包括：</p><p>(一)网络化的大型通用数据库管理系统的出现</p><p>由于互联网应用的用户数量无法预测，这就要求数据库相比以前拥有能处理更大量的数据以及为更多的用户提供服务的能力，即更好的可伸缩性及高可用性，因此，能够支持Internet的数据库应用已经成为数据库系统的重要方面，学术界及各主流数据库公司都将大型通用数据管理系统作为主要发展方向。例如Oracle公司从 8 版起全面支持互联网应用，微软公司更是将 SQL Server 作为 其整个 .NET计划中的一个重要的成分。</p><p>(二)数据库安全系统及技术的提升</p><p>由于数据库系统在现代计算机系统中的地位越来越趋于核心的地位，数据库系统的安全问题自然受到越来越多的关注。在当前各国所引用或制定的 一系列安全标准中，最重要的两个是由美国国防部制定的《可信计算机系统的评估标准》(简称TCSEC)和《可信计算机系统的评估标准关于可信数据库系统的解释》(简称 TDI)。当前，所有数据库的开发必须遵从相应的安全标准。</p><p>(三)XML及Web数据管理技术的普及</p><p>随着越来越多的Web应用，如电子商务、数字图书馆、信息服务等采用XML作为数据表现形式、越来越多网站采用XML作为信息发布的语言，以XML格式数据为主的半结构化数据逐步成为网上数据交换和数据表示的标准。而XML具有如下的一些特征：面向显示、半结构化和无结构、不同形式的数据源，动态变化以及数据海量等。因此，支持这种结构松散、形式多样、动态变化的海量数据的存储、共享、管理、检索，成了数据库技术的大势所趋。</p><p>Web数据管理是一个很松散的概念，大体上它是指在Web环境下对各种复杂信息的有效组织与集成，进行方便而准确的信息查询和发布。当前Web数据管理的研究开发方向主要包括：半结构化数据管理、Web数据查询、Web信息集成、XML数据管理等。到当前为止，XML 与 Web 数据管理的研究工作中主要集中在如下的一些方面。</p><ol><li>半结构化数据</li></ol><p>2.Web 数据查询</p><p>3.XML 相关标准</p><p>4.XML 数据管理</p><p>(四)嵌入式移动数据库技术</p><p>随着移动通信技术的迅速发展和投入使用，加上移动智能电话、移动计算机的大量普及，国内外许多研究机构都展开了对移动数据库的研究，并获取了许多有价值的成果。移动数据库技术涉及数据库技术、分布式计算技术以及移动通信技术等多个学科领域，具有较高的学术起点。</p><h4 id="数据库模型"><a href="#数据库模型" class="headerlink" title="数据库模型"></a>数据库模型</h4><ul><li><p><a href="https://zh.wikipedia.org/w/index.php?title=物件模型&action=edit&redlink=1" target="_blank" rel="noopener">对象模型</a></p></li><li><p>层次模型（轻量级数据访问协议）</p></li><li><p>网状模型（大型数据储存）</p></li><li><p>关系模型</p></li><li><p>面向对象模型</p></li><li><p>半结构化模型</p></li><li><p><a href="https://zh.wikipedia.org/w/index.php?title=平面模型&action=edit&redlink=1" target="_blank" rel="noopener">平面模型</a>（表格模型，一般在形式上是一个二维<a href="https://zh.wikipedia.org/wiki/数组" target="_blank" rel="noopener">数组</a>。如表格模型数据<a href="https://zh.wikipedia.org/wiki/Excel" target="_blank" rel="noopener">Excel</a>)</p></li></ul><p><strong>架构</strong></p><p>数据库的架构可以大致区分为三个概括层次：内层、概念层和外层。</p><ul><li>内层：最接近实际存储体，亦即有关数据的实际存储方式。</li><li>外层：最接近用户，即有关个别用户观看数据的方式。</li><li>概念层：介于两者之间的间接层。</li></ul><p><strong>数据库索引</strong></p><p>数据索引的观念由来已久，像是一本书前面几页都有目录，目录也算是索引的一种，只是它的分类较广，例如车牌、身份证字号、条码等，都是一个索引的号码，当我们看到号码时，可以从号码中看出其中的端倪，若是要找的人、车或物品，也只要提供相关的号码，即可迅速查到正确的人事物。</p><p>另外，索引跟字段有着相应的关系，索引即是由字段而来，其中字段有所谓的关键字段（Key Field），该字段具有唯一性，即其值不可重复，且不可为”<a href="https://zh.wikipedia.org/wiki/空值" target="_blank" rel="noopener">空值</a>（null）”。例如：在合并数据时，索引便是扮演欲附加字段数据之指向性用途的角色。故此索引为不可重复性且不可为空。</p><p><strong>数据库事务</strong></p><p>事务（transaction）包含一组数据库操作的逻辑工作单元，在事务中包含的数据库操作是不可分割的整体，这些操作要么一起做，要么一起回滚（Roll Back）到执行前的状态。 事务的<a href="https://zh.wikipedia.org/wiki/ACID" target="_blank" rel="noopener">ACID</a>特性：</p><ul><li>基元性（atomicity）</li><li>一致性（consistency）</li><li>隔离性（isolation）</li><li>持续性（durability）</li></ul><p>事务的并发性是指多个事务的并行操作轮流交叉运行，事务的并发可能会访问和存储不正确的数据，破坏交易的隔离性和数据库的一致性。</p><p><strong>网状数据模型的数据结构</strong></p><p>满足下面两个条件的基本层次联系的集合为网状模型。</p><ol><li>允许一个以上的结点无双亲；</li><li>一个结点可以有多于一个的双亲。</li></ol><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p>MySQL数据库是一个应用最为广泛，且免费的数据库。这个数据库无论在性能，还是在可操作性上，都非常的出众。现在众多的企业，都在使用着MySQL。</p><h4 id="定义数据库和实例"><a href="#定义数据库和实例" class="headerlink" title="定义数据库和实例"></a>定义数据库和实例</h4><p><strong>数据库</strong>：物理操作系统文件或其他形式文件类型的集合。在MySQL数据库中，数据库文件可以是frm、MYD、MYI、ibd结尾的文件。可以看做为，数据库仅仅是一个静态的TXT文件，单独的存放在硬盘中。</p><p><strong>实例</strong>：MySQL数据库由后台线程以及共享内存区组成。MySQL数据库实例在系统上的表现就是一个进程。也正是由实例，来操作数据库。</p><h4 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h4><p>Read Uncommitted（读取未提交内容）</p><p>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。</p><p>Read Committed（读取提交内容）</p><p>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。</p><p>Repeatable Read（可重读）(默认)</p><p>这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。</p><p>Serializable（可串行化）</p><p>这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</p><p>这四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。例如：</p><p>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</p><p>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</p><p>幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</p><p>在MySQL中，实现了这四种隔离级别，分别有可能产生问题如下所示：</p><p><img src="https://box.kancloud.cn/c67eb13942f3ba82f96499bcd14bd47a_686x140.png" alt=""></p><h4 id="MySQL构成"><a href="#MySQL构成" class="headerlink" title="MySQL构成"></a>MySQL构成</h4><p>数据库和实例，是两个不同的事物，但是也可以结合到一起，就好似，数据库是一个巨大的压缩包，你要用解压缩软件（实例），去操作这个压缩包。数据库文件一般都是二进制文件，因为二进制是最基础的类型，能够存储任何的信息。我们需要实例，去对二进制文件进行增删改查操作，</p><p>MySQL由以下几部分组成：</p><ul><li>连接池组件</li><li>管理服务和工具组件</li><li>SQL接口组件</li><li>查询分析器组件</li><li>优化器组件</li><li>缓冲组件</li><li>插件式存储引擎</li><li>物理文件</li></ul><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1580119995136&di=ccfb19525fab0e9fac77845a2d5d0443&imgtype=jpg&src=http%3A%2F%2Fimg1.imgtn.bdimg.com%2Fit%2Fu%3D3988714236%2C2708734242%26fm%3D214%26gp%3D0.jpg" alt=""></p><p>由图可以发现，MySQL数据库区别于其他数据库的最重要的一个特点就是其插件式服务。它提供了一系列标准的管理和服务支持，如SQL分析器和优化器，而存储引擎是底层物理结构的实现，<strong>存储引擎是基于表的，而不是数据库</strong>。</p><h4 id="存储引擎类型"><a href="#存储引擎类型" class="headerlink" title="存储引擎类型"></a>存储引擎类型</h4><h5 id="innoDB存储引擎"><a href="#innoDB存储引擎" class="headerlink" title="innoDB存储引擎"></a>innoDB存储引擎</h5><p>Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别。 该引擎还提供了行级锁和外键约束，它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。</p><p>但是该引擎不支持FULLTEXT类型的索引，而且它没有保存表的行数，当SELECT COUNT(*) FROM TABLE时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用Innodb引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表。</p><p>其特点十行锁设计、支持危机，并支持类型与Oracle的非锁定读，即默认读取操作不会产生锁。</p><p>InnoDB通过使用多版本并发控制（MVCC） 来获取高并发性，并且实现了SQL标准的4种隔离，默认为REPEATABLE级别。同时使用一种被称为next-keylocking的策略来避免幻读（phantom）现象的产生。 除此之外，InnoDB存储引擎还提供了插入缓冲(insert buffer)、二次写（double write）、自适应哈希索引（adaptive hash index）、InnoDB存储的锁信息（lock info）、数据字典信息（data dictionary）等高性能和高可用的功能。<br>对于表中数据的存储， InnoDB存储引擎采用了聚集（slustered）的方式，因此每张表的存储都是按主键的顺序存放。如果没有显式地在表定义时指定主键，InnoDB存储引擎会为每一行生成一个6字节的ROWID，并以此为主键。</p><h5 id="MylSAM存储引擎"><a href="#MylSAM存储引擎" class="headerlink" title="MylSAM存储引擎"></a>MylSAM存储引擎</h5><p>在MySQL 5.1 及之前的版本，是MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT(插入)或UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。不过和Innodb不同，MyISAM中存储了表的行数，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyISAM也是很好的选择。</p><p>MyISAM存储引擎不支持事务、表锁设计，支持全文索引，主要面向一些OLAP数据库应用。 MyISAM存储引擎另一个与众不同的地方是它的缓冲池只缓存（cache）索引文件，而不缓冲数据文件。</p><p>MyISAM存储引擎表由MYD和MYI组成，MYD用来存放数据文件，MYI用来存放索引文件。 可以通过myisampack工具来进一步压缩数据文件</p><p>（采用赫夫曼【Huffman】）编码静态算法来压缩数据，因此压缩之后的数据表示只读的， 也可以通过该工具解压数据文件。 从5.0版本之前 默认支持表大小为4GB，5.0开始默认支持256TB的单表数据。）</p><p><strong>简单介绍区别</strong>：</p><ul><li>1、MyISAM是非事务安全的，而InnoDB是事务安全的</li><li>2、MyISAM锁的粒度是表级的，而InnoDB支持行级锁</li><li>3、MyISAM支持全文类型索引，而InnoDB不支持全文索引</li><li>4、MyISAM相对简单，效率上要优于InnoDB，小型应用可以考虑使用MyISAM</li><li>5、MyISAM表保存成文件形式，跨平台使用更加方便</li></ul><p><strong>应用场景</strong>：</p><ul><li>1、MyISAM管理非事务表，提供高速存储和检索以及全文搜索能力，如果再应用中执行大量select操作，应该选择MyISAM</li><li>2、InnoDB用于事务处理，具有ACID事务支持等特性，如果在应用中执行大量insert和update操作，应该选择InnoDB</li></ul><h5 id="NDB存储引擎"><a href="#NDB存储引擎" class="headerlink" title="NDB存储引擎"></a>NDB存储引擎</h5><p>NDB存储引擎是一个集群存储引擎，类似于Oracle 的RAC集群，不过与其架构不同的是，其结构是share nothing 的集群架构，因此能提供更高的可用性。NDB的特点是数据全部放在内存中（mysql 5.1版本开始，可以将非索引数据放在磁盘上），因此主键查找速度极快，并且通过添加NDB数据存储节点（Data Node）可以线性地提高数据库性能，是高可用、高性能的集群系统。</p><p>注意：NDB存储引擎的连接操作（JOIN）是在MySQL数据库层完成的 ，而不是在存储引擎层完成的。 这意味着，复杂的挎包和操作需要巨大的网络开销，因此查询速度很慢。</p><h5 id="Memory存储引擎"><a href="#Memory存储引擎" class="headerlink" title="Memory存储引擎"></a>Memory存储引擎</h5><p>Memory存储引擎（之前称为HEAP存储引擎）将表中的数据存放在内存中，如果数据重启或者发生崩溃，表中的数据将不在 所以适合用于存储临时数据的临时表，以及数据仓库的纬度表。 Memory存储引擎默认使用哈希索引，而不是我们熟悉的B+树状索引。<br>Memory存储引擎速度非常快，但是也有一定的限制。比如:只支持表锁,并发性能差。并且不支持TEXT和BLOB列类型。最重要的是，存储变长字段（varchar）时是按照定常字段（char）的方式进行的，因此会浪费内存（已经给出了patch解决方案）。</p><p>MySQL数据库使用Memory存储引擎作为临时表存放查询中间的结果集。 如果中间结果集大于Memory存储引擎表的容量设置，或者含有TEXT或BLOB列类型字段，则MySQL数据库会转换成MyISAM存储引擎表而存放到磁盘。因为MyISAM不缓存数据文件，所以这是产生的临时表的性能对于查询会有损失。</p><h5 id="Archive存储引擎"><a href="#Archive存储引擎" class="headerlink" title="Archive存储引擎"></a>Archive存储引擎</h5><p>Archive存储引擎只支持INSERT 和 SELECT 操作, MySQL5.1版本支持索引。 Archive存储引擎使用zlib算法将数据行进行压缩 压缩比一般可达1:10。可以用来做日志信息。 Archive存储引擎使用行锁来实现高并发的插入操作，但是其本身不是书屋安全的存储引擎，其设计目标主要是提供高数的插入和压缩功能。</p><h5 id="Federated-存储引擎"><a href="#Federated-存储引擎" class="headerlink" title="Federated 存储引擎"></a>Federated 存储引擎</h5><p>Federated 存储引擎表并不存放数据，它只是指向一台远程MySQL数据库服务器上的表。这非常类似于SQL Server 的链接服务器和Oracle的透明网关，不同的是，当前Federated存储引擎只支持MySQL数据库表，不支持异构数据库表。</p><h5 id="Maria存储引擎"><a href="#Maria存储引擎" class="headerlink" title="Maria存储引擎"></a>Maria存储引擎</h5><p>Maria存储引擎 是新开发订单引擎，设计目标主要是取代MyISAM存储引擎，从而成为MySQL的默认存储引擎。<br>特点：注册缓存数据和索引文件，应用了行锁设计，提供了MVCC功能，支持事务和非事务安全的选项，以及更好的BLOB字符类型的处理性能。</p><h5 id="其他存储引擎"><a href="#其他存储引擎" class="headerlink" title="其他存储引擎"></a>其他存储引擎</h5><p>如：Merge、CSV、Sphinx和Infobright等。</p><p>不同之处：存储容量的限制、事务支持、锁的粒度、MVCC支持、支持的索引、备份和复制等。</p><p><img src="https://box.kancloud.cn/67c9fd3b0f58f5d7b83140026b5c9c21_836x582.png" alt=""></p><h4 id="数据库的链接方式"><a href="#数据库的链接方式" class="headerlink" title="数据库的链接方式"></a>数据库的链接方式</h4><h5 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h5><p>TCP/IP套接字方式MySQL数据库 在任何的平台下都提供的链接方式，也是网络中使用最多的链接方式。<br>链接例如：mysql -h【ip】 -u 【用户名】 -p【密码】 &gt; mysql -h127.0.0.1 -u root -proot<br>判断客户端是否允许链接Mysql实例<br>链接完数据库<br>选择数据库 use mysql;<br>在查询表select host,user,password from user;<br>就可以得到相对应的链接ip</p><h5 id="命名管道和共享内存"><a href="#命名管道和共享内存" class="headerlink" title="命名管道和共享内存"></a>命名管道和共享内存</h5><p><img src="https://box.kancloud.cn/7961c80f6443a8a63416658f2bbc856d_858x228.png" alt=""></p><h5 id="UNIX域套接字"><a href="#UNIX域套接字" class="headerlink" title="UNIX域套接字"></a>UNIX域套接字</h5><p>linux和UNIX环境下 可以使用. UNIX域套接字不是网络协议 所以只能在同一台服务器上使用。<br>用户可以在配置文件中知道套接字文件的路径 如果–socket=/tmp/mysql.sock。<br>通过命令查找UNIX域套接字文件SHOW VARIABLES LIKE ‘socket’\G</p><p><img src="https://box.kancloud.cn/aa479d02d235c06a2799f21198eef7be_484x115.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot整合Security框架</title>
      <link href="/2020/01/24/spring7/"/>
      <url>/2020/01/24/spring7/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h2><p>“万一我随便输入一个账号，再随便输入一堆密码，就登录到了马云的淘宝号呢？”:yum:</p><p>“那阿里又要向社会输入工作十年的人才了。”:happy:</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>我们之前在众多的实验中，无论虽然对业务逻辑的处理和持久层的操作，都封装在后端，无法被轻易访问。但是，要调用的时候，还是需要通过前端的控制层，以及thymeleaf页面来完成，这个时候很多操作都可以从url头直接进行，而不加以限制，这样是不完善的。</p><p>粗俗一点讲，就是我们需要登录了才能访问页面，其他的请求将通通加以限制。</p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Spring Security是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架（简单说是对访问权限进行控制嘛）。它提供了一组可以在Spring应用上下文中配置的Bean，充分利用了Spring IoC，DI（控制反转Inversion of Control ,DI:Dependency Injection 依赖注入）和AOP（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。</p><p>可以简单地认为 Spring Security 是放在用户和 Spring 应用之间的一个安全屏障, 每一个 web 请求都先要经过 Spring Security 进行 Authenticate 和 Authoration 验证。</p><p>我们现在来使用Security框架，来制作需要登录验证的网站模型。</p><h3 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h3><p>security的理解的使用比较繁杂，我们先把基础配置和重点分开来讲：</p><h4 id="依赖与设置"><a href="#依赖与设置" class="headerlink" title="依赖与设置"></a>依赖与设置</h4><h5 id="引入pom依赖："><a href="#引入pom依赖：" class="headerlink" title="引入pom依赖："></a>引入pom依赖：</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="配置yml"><a href="#配置yml" class="headerlink" title="配置yml:"></a>配置yml:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:&#x2F;mapper&#x2F;*.xml</span><br><span class="line">  type-aliases-package: com.example.security.pojo</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br><span class="line">    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;springtest?useSSL&#x3D;false&amp;serverTimezone&#x3D;GMT%2B8&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    tomcat:</span><br><span class="line">      max-idle: 10</span><br><span class="line">      max-wait: 10000</span><br><span class="line">      max-active: 50</span><br><span class="line">      initial-size: 5</span><br><span class="line">server:</span><br><span class="line">  port: 8888</span><br></pre></td></tr></table></figure><p>这里还是使用mybatis来操作持久层</p><h5 id="mapper"><a href="#mapper" class="headerlink" title="mapper"></a>mapper</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.example.security.dao.UserMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUser"</span> <span class="attr">parameterType</span>=<span class="string">"String"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">        select * from t_user_roles where username =#&#123;username&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>mapper的设置，直接获取全部属性。</p><h5 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h5><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/security/1.png" alt=""></p><p>这是数据库的设置，注意roles形式是固定，必须有ROLE_ 前缀</p><h4 id="必要的组件"><a href="#必要的组件" class="headerlink" title="必要的组件"></a>必要的组件</h4><p>这里将所有必要的组件类列出来，这里不是重点，但是很有必要。</p><h5 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Alias</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String roles;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="dao层"><a href="#dao层" class="headerlink" title="dao层"></a>dao层</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">User <span class="title">getUser</span><span class="params">(String username)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">     UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.getUser(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"login"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/mypage"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">my</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"mypage"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/admin"</span>)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"admin"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/logout"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">logoutpage</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span>&#123;</span><br><span class="line">        <span class="comment">//Authentication 是一个接口，用来表示用户认证信息</span></span><br><span class="line">        Authentication auth= SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        <span class="keyword">if</span> (auth!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">new</span> SecurityContextLogoutHandler().logout(request,response,auth);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重定向到 login</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:/login?logout"</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里列出了控制层要接收的所有映射，现在暂时不说明他们各自的作用，待会会结合Security的各个配置一并讲解出来。</p><h3 id="Security——登录和注销"><a href="#Security——登录和注销" class="headerlink" title="Security——登录和注销"></a>Security——登录和注销</h3><p>这里开始讲述，Security是如何将它们整合起来的。大家可能会发现，上面的Controller层代码并没有Service层的注入，那么控制层是如何从数据库获取验证的呢？这里由下而上，从Service的注入开始。</p><h4 id="UserDetailsService"><a href="#UserDetailsService" class="headerlink" title="UserDetailsService"></a>UserDetailsService</h4><p>Service层的注入在了一个接入了UserDetailsService接口的类里面。而这个类通过重写UserDetailsService的方法，来获取到数据库的用户信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUserDetailService</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String s)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"通过用户名加载用户"</span>);</span><br><span class="line">        com.example.security.pojo.User user = userService.getUserName(s);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UsernameNotFoundException(<span class="string">"用户不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(user.getUsername() ,user.getPassword(),</span><br><span class="line">                createAuthority(user.getRoles()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里是将数据库的角色分割，构造GrantedAuthority</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;SimpleGrantedAuthority&gt; <span class="title">createAuthority</span><span class="params">(String roles)</span> </span>&#123;</span><br><span class="line">        String[] roleArray = roles.split(<span class="string">","</span>);</span><br><span class="line">        List&lt;SimpleGrantedAuthority&gt; authorityList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String role : roleArray) &#123;</span><br><span class="line">            authorityList.add(<span class="keyword">new</span> SimpleGrantedAuthority(role));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> authorityList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里重写了loadUserByUsername方法，这个方法会返回一个User类，我们会使用服务层的API，从数据库读取数据，让我们的user获得各项信息，在结合自己定义的方法，把我们的Roles划分为一个ArrayList列表。再使用Security的User类去重新构造它，并且返回。</p><p>注意，返回的这个User类是属于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.User;</span><br></pre></td></tr></table></figure><p>这里在下犯了一个错误，就是不应该直接把实体类的名称直接定义为User，这样导致两个User类产生了冲突，所以在loadUserByUsername方法开头的user实例，使用地址的方式去声明。</p><p>那么这个类的方法又会被谁调用呢？</p><h4 id="WebSecurityConfigurerAdapter"><a href="#WebSecurityConfigurerAdapter" class="headerlink" title="WebSecurityConfigurerAdapter"></a>WebSecurityConfigurerAdapter</h4><p>这个方法会被继承了WebSecurityConfigurerAdapter的类所调用。我们首先要继承WebSecurityConfigurerAdapter，并重写两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfiguration</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MyUserDetailService myUserDetailService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AuthenticationSuccessHandler authenticationSuccessHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">"/"</span>, <span class="string">"/index"</span>).permitAll()<span class="comment">//允许/、/index的访问</span></span><br><span class="line">                .antMatchers(<span class="string">"/mypage/**"</span>).hasAnyRole(<span class="string">"USER"</span>)<span class="comment">//用户USER角色的用户访问有关/mypage下面的所有</span></span><br><span class="line">                .antMatchers(<span class="string">"/admin/**"</span>).hasAnyRole(<span class="string">"ADMIN"</span>)<span class="comment">//同上</span></span><br><span class="line">                .anyRequest().authenticated()<span class="comment">//其它所有访问都拦截</span></span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()<span class="comment">//添加登陆</span></span><br><span class="line">                .loginPage(<span class="string">"/login"</span>).permitAll()<span class="comment">//登陆页面“/login"允许访问</span></span><br><span class="line">                .defaultSuccessUrl(<span class="string">"/mypage"</span>)<span class="comment">//成功默认跳转 url</span></span><br><span class="line">                .usernameParameter(<span class="string">"user"</span>)</span><br><span class="line">                .passwordParameter(<span class="string">"password"</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .logout()</span><br><span class="line">                .permitAll()</span><br><span class="line">                <span class="comment">//设置注销操作</span></span><br><span class="line">                <span class="comment">//所有用户都可以访问（可以使用注销）</span></span><br><span class="line">                .and()</span><br><span class="line">                .exceptionHandling().accessDeniedPage(<span class="string">"/error"</span>);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        auth</span><br><span class="line">                .userDetailsService(myUserDetailService)</span><br><span class="line">                .passwordEncoder(<span class="keyword">new</span> MyPassWordEncoder());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在重写了configure(AuthenticationManagerBuilder auth)方法后，调用auth的注册，我们就能把用户的信息注册到整个Servelet的上下文中，使其全局存在，注意这里的MyPassWordEncoder：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPassWordEncoder</span> <span class="keyword">implements</span> <span class="title">PasswordEncoder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encode</span><span class="params">(CharSequence charSequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> charSequence.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(CharSequence charSequence, String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.equals(charSequence.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是需要重写PasswordEncoder去实现的，这是为了完成Security的密码加密功能，这里暂时不做延伸。</p><p>然后重写的configure(HttpSecurity http)方法，这个方法就是用来拦截请求和注册的，非常的关键。</p><p>一开始，便使用了authorizeRequests，来配置和定义请求，使用antMatchers来定义页面和权限的信息。</p><p>.and()的作用是连接表示还有事务需要配置</p><p>使用.formLogin()去定义登录页面，对于需要权限的请求，都需要跳转到某个url进行登录操作，使用loginPage(“/login”)，表示url，permitAll()表示全部需要权限的页面</p><p>最后的logout()表示注销的页面，这里默认为logout，但注销操作实际上要根据业务的需要去定义，一般不会直接定位到某个页面。</p><p>.exceptionHandling().accessDeniedPage(“/error”);表示出现权限不足时，需要跳转的页面。</p><p>这里就需要重新提起Controller层的操作了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"login"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然我们定义了跳转页面，但是我们仍然需要对/login请求进行重新规划，在defaultSuccessUrl中，定义了登录成功后会跳转的URL，这就表示了，如果登录成功，则跳转到相应的URL页面，否则，仍然返回login页面。</p><h4 id="注销的实现"><a href="#注销的实现" class="headerlink" title="注销的实现"></a>注销的实现</h4><p>重新看回Controller层的/logout页面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/logout"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">logoutpage</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span>&#123;</span><br><span class="line">    <span class="comment">//Authentication 是一个接口，用来表示用户认证信息</span></span><br><span class="line">    Authentication auth= SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">    <span class="keyword">if</span> (auth!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">new</span> SecurityContextLogoutHandler().logout(request,response,auth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重定向到 login</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:/login?logout"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们接受到了一个请求，使用（HttpServletRequest request, HttpServletResponse response），去处理这请求。</p><p>首先看到SecurityContextHolder.getContext().getAuthentication(); 它获取了我们存在于服务器中的上下文，同时又获取到了该用户的名字，如果该用户存在，则new一个新的用户去相应logout页面，最后再重定向回来。重定向在thymeleaf中也有所提及，是重新访问url页面并执行方法的意思。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>开始测试，首先需要HTML页面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.w3.org/1999/xhtml"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>登陆页面<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:if</span>=<span class="string">"$&#123;param.error&#125;"</span>&gt;</span></span><br><span class="line">    密码错误</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:if</span>=<span class="string">"$&#123;param.logout&#125;"</span>&gt;</span></span><br><span class="line">    您已注销</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">"@&#123;/login&#125;"</span> <span class="attr">action</span>=<span class="string">""</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    用户名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"user"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码:<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"remember-me"</span>&gt;</span>记住我<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"登陆"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="登录界面"><a href="#登录界面" class="headerlink" title="登录界面"></a>登录界面</h5><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/security/2.png" alt=""></p><p>这个就是登录界面.。</p><h5 id="权限页面"><a href="#权限页面" class="headerlink" title="权限页面"></a>权限页面</h5><p>当我们登录了张三这个用户的身份后，将自动跳转到mypage页面</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/security/4.png" alt=""></p><p>再尝试去访问admin页面。</p><p> <img src="https://gitee.com/antarctica/img_sotre/raw/img/img/security/3.png" alt=""></p><p>于是点击退出</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/security/5.png" alt=""></p><p>然后再次用管理员的账号去登录管理员界面</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/security/6.png" alt=""></p><p>完成！余下HTML页面会在文章最后的源码连接中放出。</p><h3 id="Security——记住我"><a href="#Security——记住我" class="headerlink" title="Security——记住我"></a>Security——记住我</h3><p>在WebSecurityConfigurerAdapter，选择记住我，但是这个.rememberMe()，也是有着许许多多的层级关系的。</p><h4 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h4><p>我们直接配置中使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.rememberMe();</span><br></pre></td></tr></table></figure><p>开启的rememberMe()功能，但是它是存储于一个全局的Cookies中的，它会存在一段时间，在这段时间中，即使你切到其他页面，再切回来，也不用登录，但是一旦清除了Cookies，那就必须重新登录了。</p><p>同时，除了通过自己去编辑注销之外，还可以使用Security中自带的注销方法，它还可以自定义注销成功跳转的目录。：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.logout().logoutSuccessUrl(<span class="string">"/"</span>);</span><br></pre></td></tr></table></figure><p>同时，在控制层中注释掉logout的映射关系，并在html页面上改成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>退出<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">"@&#123;/logout&#125;"</span> <span class="attr">method</span>=<span class="string">"post"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"注销"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>它就会提交一个logout请求，而Security就会自动识别到这个请求，来完成我们的注销功能</p><p>可以在浏览器中按F12，打开application 的cookies页面，查看jsession信息。</p><h4 id="自定义Cookies"><a href="#自定义Cookies" class="headerlink" title="自定义Cookies"></a>自定义Cookies</h4><p>我们还可以使用自定义Cookies去存储用户信息，使我们在关闭浏览器后，还缓存固定的时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http.authorizeRequests()                </span><br><span class="line">    .and()</span><br><span class="line">                .rememberMe()</span><br><span class="line">                .key(<span class="string">"uniqueAndSecret"</span>)</span><br><span class="line">                .rememberMeCookieName(<span class="string">"remember-me"</span>)</span><br><span class="line">                .tokenValiditySeconds(<span class="number">60</span>);</span><br></pre></td></tr></table></figure><p>重新添加这段代码后，我们就将用户信息缓存在了Cookies中。</p><p>使用.key(“uniqueAndSecret”)，指定缓存的键名，.rememberMeCookieName(“remember-me”)指定Cookies名。</p><p>.tokenValiditySeconds(60);则是指定Cookies时间，这里使用60秒来进行测试，我们可以在测试后发现，它确实在关闭浏览器后，仍然仍然存在。</p><h4 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h4><p>但是使用Cookies还是有着弊端，那就是我们再使用什么清理垃圾软件清理缓存的时候，将全部被清除掉，或者对于不支持缓存的浏览器而言，也是极其致命的，于是，我们可以将数据放到数据库中。这样就没有问题了。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/security/8.jpg" alt=""></p><h5 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http.authorizeRequests()</span><br><span class="line">        .and()</span><br><span class="line">        .rememberMe()</span><br><span class="line">        .tokenRepository(persistentTokenRepository())</span><br><span class="line">        .tokenValiditySeconds(<span class="number">60</span>)</span><br><span class="line">        .userDetailsService(myUserDetailService);</span><br></pre></td></tr></table></figure><p>增加这项配置，注意 .tokenRepository 将会注册一个处理方法：</p><h5 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PersistentTokenRepository <span class="title">persistentTokenRepository</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    JdbcTokenRepositoryImpl jdbcTokenRepository = <span class="keyword">new</span> JdbcTokenRepositoryImpl();</span><br><span class="line">    <span class="comment">// 配置数据源</span></span><br><span class="line">    jdbcTokenRepository.setDataSource(dataSource);</span><br><span class="line">    <span class="comment">// 第一次启动的时候自动建表</span></span><br><span class="line">     <span class="comment">//jdbcTokenRepository.setCreateTableOnStartup(true);</span></span><br><span class="line">    <span class="keyword">return</span> jdbcTokenRepository;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里配置了PersistentTokenRepository，也就是Token的处理方法。当我们开启了这个后，可以访问页面，这个时候便可以再去观察数据库，你会发现：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/security/7.png" alt=""></p><p>这个便是我们的登录的信息，它会被存储在数据库里，它也会再时间过期后，将用户登录信息给无效化。</p><h3 id="Security——定制跳转"><a href="#Security——定制跳转" class="headerlink" title="Security——定制跳转"></a>Security——定制跳转</h3><p>我们也可以在登录成功后，定制跳转页面，使得我们拥有admin权限的用户直接跳转到后台管理页面，而user权限的则跳转默认的主页。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">AuthenticationSuccessHandler authenticationSuccessHandler;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"AppSecurityConfigurer()调用-------"</span>);</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            <span class="comment">//spring-scurity 5.0之后需要过滤静态资源</span></span><br><span class="line"></span><br><span class="line">            .antMatchers(<span class="string">"/login"</span>,<span class="string">"/css/**"</span>,<span class="string">"/js/**"</span>,<span class="string">"/img/**"</span>).permitAll()</span><br><span class="line">            <span class="comment">//指定用户可以访问的多个url模式。</span></span><br><span class="line">            <span class="comment">// 特别的，任何用户可以访问以"/resources"开头的url资源，或者等于"/signup"或about</span></span><br><span class="line"></span><br><span class="line">            .antMatchers(<span class="string">"/"</span>,<span class="string">"/home"</span>).hasRole(<span class="string">"USER"</span>)</span><br><span class="line">            <span class="comment">//任何以"/home"开头的请求限制用户具有 "ROLE_USER"角色。</span></span><br><span class="line">            <span class="comment">// 你可能已经注意的，尽管我们调用的hasRole方法，但是不用传入"ROLE_"前缀</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            .antMatchers(<span class="string">"/admin/**"</span>).hasAnyRole(<span class="string">"ADMIN"</span>,<span class="string">"DBA"</span>)</span><br><span class="line">            <span class="comment">//这个是拥有其中一个权限都能使用</span></span><br><span class="line"></span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            <span class="comment">//任何没有匹配上的其他的url请求，需要用户被验证。</span></span><br><span class="line"></span><br><span class="line">            .and()</span><br><span class="line">            <span class="comment">//拼接</span></span><br><span class="line"></span><br><span class="line">            .formLogin().loginPage(<span class="string">"/login"</span>)</span><br><span class="line">            <span class="comment">//开始设置登录操作</span></span><br><span class="line">            <span class="comment">//设置登录页面的访问地址</span></span><br><span class="line"></span><br><span class="line">            .successHandler(authenticationSuccessHandler)</span><br><span class="line">            <span class="comment">//设置了一个认证处理，登录成功后不同用户需要跳转到不同的页面</span></span><br><span class="line">            <span class="comment">//以此认证，视为通行证</span></span><br><span class="line"></span><br><span class="line">            .usernameParameter(<span class="string">"loginName"</span>).passwordParameter(<span class="string">"password"</span>)</span><br><span class="line">            <span class="comment">//登录时接受传递的参数 loginName 和password</span></span><br><span class="line">            <span class="comment">//注意大小写</span></span><br><span class="line"></span><br><span class="line">            .and()</span><br><span class="line">            .logout().permitAll()</span><br><span class="line">            <span class="comment">//设置注销操作</span></span><br><span class="line">            <span class="comment">//所有用户都可以访问（可以使用注销）</span></span><br><span class="line"></span><br><span class="line">            .and()</span><br><span class="line">            .exceptionHandling().accessDeniedPage(<span class="string">"/accessDenied"</span>);</span><br><span class="line">    <span class="comment">//指定异常处理页面</span></span><br><span class="line">    <span class="comment">//特别是在没有权限的时候使用发生的错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这便是我们重新写的http处理。注释写完整了各个位置的含义。</p><p>以下是AuthenticationSuccessHandler 处理方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthenticationSuccessHandler</span> <span class="keyword">extends</span> <span class="title">SimpleUrlAuthenticationSuccessHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//spring security 通过RedirectStrategy 对象负责所有重定向事务</span></span><br><span class="line">    <span class="keyword">private</span> RedirectStrategy redirectStrategy=<span class="keyword">new</span> DefaultRedirectStrategy();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    重写 handle 方法，方法中通过 RedirectStrategy 对象重定向到指定的url</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">//通过determineTargetURL方法返回需要跳转的URL</span></span><br><span class="line">        String targetUrl=determineTargetUrl(authentication);</span><br><span class="line">        <span class="comment">//重定向请求指定的URL</span></span><br><span class="line">        redirectStrategy.sendRedirect(request,response,targetUrl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    从Authentication 对象中提取当前登录用户的角色，并根据其角色返回适当的URL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">determineTargetUrl</span><span class="params">(Authentication authentication)</span> </span>&#123;</span><br><span class="line">        String url=<span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前登录用户的角色权限到集合 authentication</span></span><br><span class="line">        Collection&lt;? extends GrantedAuthority&gt; authorities=authentication.getAuthorities();</span><br><span class="line">        <span class="comment">//Collection是最基本的集合接口，</span></span><br><span class="line">        <span class="comment">// 一个Collection代表一组Object，即Collection的元素（Elements）。</span></span><br><span class="line">        <span class="comment">// 一些Collection允许相同的元素而另一些不行。一些能排序而另一些不行。</span></span><br><span class="line">        <span class="comment">// Java SDK不提供直接继承自Collection的类，</span></span><br><span class="line">        <span class="comment">// Java SDK提供的类都是继承自Collection的“子接口”如List和Set。</span></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; roles=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将角色名称添加到List集合</span></span><br><span class="line">        <span class="keyword">for</span> (GrantedAuthority a:authorities)</span><br><span class="line">        &#123;</span><br><span class="line">            roles.add(a.getAuthority());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断不同角色跳转到不同的URL</span></span><br><span class="line">        <span class="keyword">if</span>(isAdmin(roles))</span><br><span class="line">        &#123;</span><br><span class="line">            url=<span class="string">"/admin"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (isUser(roles))&#123;</span><br><span class="line">            url=<span class="string">"/home"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;url=<span class="string">"/accessDenied"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"url="</span>+url);</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isUser</span><span class="params">(List&lt;String&gt; roles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (roles.contains(<span class="string">"ROLE_USER"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAdmin</span><span class="params">(List&lt;String&gt; roles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (roles.contains(<span class="string">"ROLE_ADMIN"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//set 和  get</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedirectStrategy <span class="title">getRedirectStrategy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redirectStrategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRedirectStrategy</span><span class="params">(RedirectStrategy redirectStrategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.redirectStrategy = redirectStrategy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码地址：</p><p><a href="https://github.com/Antarctica000/SpringBoot/tree/master/security">https://github.com/Antarctica000/SpringBoot/tree/master/security</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot整合Thymeleaf</title>
      <link href="/2020/01/21/spring6/"/>
      <url>/2020/01/21/spring6/</url>
      
        <content type="html"><![CDATA[<h2 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h2><p>在下在此奉劝大家，不要再学JSP了。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="Thymeleaf的概念："><a href="#Thymeleaf的概念：" class="headerlink" title="Thymeleaf的概念："></a>Thymeleaf的概念：</h4><p><strong>Thymeleaf</strong>是适用于Web和独立环境的现代服务器端Java模板引擎。</p><p>Thymeleaf的主要目标是为您的开发工作流程带来优雅的<em>自然模板</em> -HTML可以在浏览器中正确显示，也可以作为静态原型工作，从而可以在开发团队中加强协作。</p><p>可以在Web（基于servlet ）和非Web环境中工作。 它更适合在基于MVC的Web应用程序的视图层提供XHTML / HTML5，但它甚至可以在脱机环境中处理任何XML文件。 它提供完整的Spring Framework。</p><p>在Web应用程序中，Thymeleaf旨在成为JavaServer Pages （JSP）的完全替代品，并实现自然模板的概念：模板文件可以直接在浏览器中打开，并且仍然可以正确显示为网页。</p><p>对了，Thymeleaf取代了JSP。</p><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul><li><p>用于<a href="https://zh.wikipedia.org/wiki/XML" target="_blank" rel="noopener">XML</a> ， <a href="https://zh.wikipedia.org/wiki/XHTML" target="_blank" rel="noopener">XHTML</a>和<a href="https://zh.wikipedia.org/wiki/HTML5" target="_blank" rel="noopener">HTML5的</a> Java 模板引擎 。</p></li><li><p>适用于Web和非Web（离线）环境。 没有硬依赖<a href="https://zh.wikipedia.org/wiki/Java_Servlet" target="_blank" rel="noopener">Servlet</a> API。</p></li><li><p>基于称为</p><p>方言的</p><p>模块化特征集。</p><ul><li>方言特征（例如：评估，迭代等）通过将它们链接到模板的标签和/或属性来应用。</li><li>开箱即用的两种方言：Standard和SpringStandard（适用于<a href="https://zh.wikipedia.org/wiki/Spring_Framework" target="_blank" rel="noopener">Spring MVC</a>应用程序，与标准语法相同）。</li><li>开发人员可以扩展和创建自定义方言。</li></ul></li><li><p>几种模板模式：</p><ul><li><strong><a href="https://zh.wikipedia.org/wiki/XML" target="_blank" rel="noopener">XML</a></strong> ：验证<a href="https://zh.wikipedia.org/wiki/文档类型定义" target="_blank" rel="noopener">DTD</a>与否。</li><li><strong><a href="https://zh.wikipedia.org/wiki/XHTML" target="_blank" rel="noopener">XHTML</a> 1.0和1.1</strong> ：是否针对标准<a href="https://zh.wikipedia.org/wiki/文档类型定义" target="_blank" rel="noopener">DTD进行</a>验证。</li><li><strong><a href="https://zh.wikipedia.org/wiki/HTML5" target="_blank" rel="noopener">HTML5</a></strong> ：XML格式的代码和基于遗留的HTML5。 传统的非XML代码将自动清理并转换为<a href="https://zh.wikipedia.org/wiki/XML" target="_blank" rel="noopener">XML</a>格式。</li></ul></li><li><p>完整（和可扩展）的<strong>国际化</strong>支持。</p></li><li><p>可配置的高性能<strong>解析模板缓存</strong> ，可将输入/输出降至最低。</p></li><li><p>自动DOCTYPE转换 - 从模板<a href="https://zh.wikipedia.org/wiki/文档类型定义" target="_blank" rel="noopener">DTD</a>到结果DTD-用于（可选）验证模板和结果代码。</p></li><li><p>极易扩展：如果需要，可以用作模板引擎框架。</p></li><li><p>完整的文档，包括几个示例应用。</p></li></ul><h4 id="常用场景"><a href="#常用场景" class="headerlink" title="常用场景"></a>常用场景</h4><p>Thymeleaf现在经常和Spring组件一起，成为一个完整的SSM框架。</p><p><strong>SSM</strong>：</p><p><strong>Spring</strong><br>　　Spring就像是整个项目中装配bean的大工厂，在配置文件中可以指定使用特定的参数去调用实体类的构造方法来实例化对象。也可以称之为项目中的粘合剂。<br>　　Spring的核心思想是IoC（控制反转），即不再需要程序员去显式地<code>new</code>一个对象，而是让Spring框架帮你来完成这一切。<br><strong>SpringMVC</strong><br>　　SpringMVC在项目中拦截用户请求，它的核心Servlet即DispatcherServlet承担中介或是前台这样的职责，将用户请求通过HandlerMapping去匹配Controller，Controller就是具体对应请求所执行的操作。SpringMVC相当于SSH框架中struts。<br><strong>mybatis</strong><br>　　mybatis是对jdbc的封装，它让数据库底层操作变的透明。mybatis的操作都是围绕一个sqlSessionFactory实例展开的。mybatis通过配置文件关联到各实体类的Mapper文件，Mapper文件中配置了每个类对数据库所需进行的sql语句映射。在每次与数据库交互时，通过sqlSessionFactory拿到一个sqlSession，再执行sql命令。</p><p>到现在，新一代的SSM定义应该为SpringBoot+SpringMVC+MyBatis。</p><p>于是，现在开始学习关于SpringMVC的知识。</p><h3 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h3><p>Thymeleaf有很多的语法，虽然一个一个列出来并不复杂，但是为了更好的去理解它们的使用，而不是仅仅的列出公式。我希望能够将常用的抽离出来，并且将它们整合为一个项目。然后再单独的讲一下不常用的。</p><h4 id="基本准备"><a href="#基本准备" class="headerlink" title="基本准备"></a>基本准备</h4><h5 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了更好的完成视图的开发，一般会多引入一个依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是开发工具，能够实时的在网页上查看更改的效果，实现边改边看。</p><p><strong>配置</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">thymeleaf:</span></span><br><span class="line">    <span class="attr">cache:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>关闭缓存，实现实现边改边看。</p><h4 id="各个类的准备"><a href="#各个类的准备" class="headerlink" title="各个类的准备"></a>各个类的准备</h4><h5 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Alias</span>(<span class="string">"product"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3288311147760635602L</span>;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String productName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> version;</span><br><span class="line">    <span class="keyword">private</span> String note;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Dao层"><a href="#Dao层" class="headerlink" title="Dao层"></a>Dao层</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Alias</span>(<span class="string">"product"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3288311147760635602L</span>;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String productName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> version;</span><br><span class="line">    <span class="keyword">private</span> String note;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//展示全部</span></span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Product&gt; <span class="title">ShowAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除产品</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加产品</span></span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(Product product)</span></span>;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductServiceImpl</span> <span class="keyword">implements</span> <span class="title">ProductService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductDao productDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Product&gt; <span class="title">ShowAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> productDao.showProduct();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> productDao.deleteProduct(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(Product product)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> productDao.addProduct(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.example.thymeleaf.dao.ProductDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 展示产品 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"showProduct"</span> <span class="attr">resultType</span>=<span class="string">"product"</span>&gt;</span></span><br><span class="line">select * from t_product</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--增加产品--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addProduct"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span></span></span><br><span class="line"><span class="tag"><span class="attr">parameterType</span>=<span class="string">"product"</span>&gt;</span></span><br><span class="line">insert into t_product(product_name, stock,price,version,note)</span><br><span class="line">values(#&#123;productName&#125;,#&#123;stock&#125;,#&#123;price&#125;,#&#123;version&#125;,#&#123;note&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 减少产品 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteProduct"</span> <span class="attr">parameterType</span>=<span class="string">"long"</span>&gt;</span></span><br><span class="line">delete from t_product where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductService productService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">         model.addAttribute(<span class="string">"products"</span>, productService.ShowAll());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="开始测试"><a href="#开始测试" class="headerlink" title="开始测试"></a>开始测试</h4><p>首先要准备一个index页面，并且在顶部添上一句：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样HTML页面便能够识别我们的Thymeleaf语法。</p><h5 id="th-each"><a href="#th-each" class="headerlink" title="th:each"></a>th:each</h5><p>th:each 是一个经常被使用的语法，它能够不断地去读取从后端发出的队列，并且显示出来。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">th:each</span>=<span class="string">"product:$&#123;products&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;product.id&#125;"</span>&gt;</span>id<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;product.productName&#125;"</span>&gt;</span>产品名称<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;product.stock&#125;"</span>&gt;</span>库存<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;product.price&#125;"</span>&gt;</span>价格<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;product.version&#125;"</span>&gt;</span>版本<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;product.note&#125;"</span>&gt;</span>备注<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">"@&#123;deletelist/&#123;id&#125;(id=$&#123;product.getId()&#125;)&#125;"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">th:value</span>=<span class="string">"$&#123;product.getId()&#125;"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">onclick</span>=<span class="string">"return del()"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>它会将我们从数据库中读取到的数据量的多少，来显示我们的页面。</p><p><a href="https://gitee.com/antarctica/img_sotre/raw/img/img/thymeleaf/1.png" target="_blank" rel="noopener"><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/thymeleaf/1.png" alt="img"></a></p><p><a href="https://gitee.com/antarctica/img_sotre/raw/img/img/thymeleaf/2.png" target="_blank" rel="noopener"><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/thymeleaf/2.png" alt="img"></a></p><h5 id="使用form表单提交信息"><a href="#使用form表单提交信息" class="headerlink" title="使用form表单提交信息"></a>使用form表单提交信息</h5><p>我们在添加信息的时候，首先会在index页面添加一个：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"add"</span>&gt;</span>增加产品<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>它能够发起一个add请求到后端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/add"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    Product product=<span class="keyword">new</span> Product();</span><br><span class="line">    model.addAttribute(<span class="string">"product"</span>,product);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"add"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后端接收到了这个请求后，就会使用return到另一个页面，值得注意的是，我们这里又new了一个新的product，之所以这样做是为了能够add页面，使用product这个类。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"#"</span> <span class="attr">th:action</span>=<span class="string">"@&#123;/addproduct&#125;"</span> <span class="attr">th:object</span>=<span class="string">"$&#123;product&#125;"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">th:field</span>=<span class="string">"*&#123;id&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">th:field</span>=<span class="string">"*&#123;productName&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">th:field</span>=<span class="string">"*&#123;stock&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">th:field</span>=<span class="string">"*&#123;price&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">th:field</span>=<span class="string">"*&#123;version&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">th:field</span>=<span class="string">"*&#123;note&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个就是我们的提交表单的行为，这里的<strong>th:action</strong>表示这个表单将会提交到：/addproduct 这个链接的方法中。</p><p>这里使用<strong>th:object</strong>去定义要使用的实例，我们就能够再text框中输入实例的属性，以此决定我们实例的数据。</p><p>使用<strong>th:field</strong>去表示这是我们实例的哪个属性。</p><p><strong>java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/addproduct"</span>,method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addpro</span><span class="params">(@ModelAttribute Product product)</span></span>&#123;</span><br><span class="line">    productService.add(product);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:/add"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个请求就是表单提交的链接的方法，会使用服务的方法区增加信息。最后哪个redirect:/add ，表示需要重定向到链接add，重新执行add链接下的方法。</p><h5 id="删除信息"><a href="#删除信息" class="headerlink" title="删除信息"></a>删除信息</h5><p>写一个删除信息的页面，再添加：</p><p><strong>html</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"#"</span> <span class="attr">th:action</span>=<span class="string">"@&#123;/deleteproduct&#125;"</span> <span class="attr">th:object</span>=<span class="string">"$&#123;product&#125;"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">th:field</span>=<span class="string">"*&#123;id&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>会根据id去删除数据库的信息，这个也是一个表单，和add类似，使用表单的好处是以后更方便的用于修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/delete"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">delete</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    Product product=<span class="keyword">new</span> Product();</span><br><span class="line">    model.addAttribute(<span class="string">"product"</span>,product);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"delete"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/deleteproduct"</span>,method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">deletepro</span><span class="params">(@ModelAttribute Product product)</span></span>&#123;</span><br><span class="line">    productService.delete(product.getId());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:index"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里设置为重定向到index。</p><h5 id="使用按钮删除信息"><a href="#使用按钮删除信息" class="headerlink" title="使用按钮删除信息"></a>使用按钮删除信息</h5><p>实际在后端管理中，为了更方便的去增删改查。很多时候都是使用链接去完成的。回看index页面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">th:each</span>=<span class="string">"product:$&#123;products&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;product.id&#125;"</span>&gt;</span>id<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;product.productName&#125;"</span>&gt;</span>产品名称<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;product.stock&#125;"</span>&gt;</span>库存<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;product.price&#125;"</span>&gt;</span>价格<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;product.version&#125;"</span>&gt;</span>版本<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;product.note&#125;"</span>&gt;</span>备注<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">"@&#123;deletelist/&#123;id&#125;(id=$&#123;product.getId()&#125;)&#125;"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">th:value</span>=<span class="string">"$&#123;product.getId()&#125;"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">onclick</span>=<span class="string">"return del()"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里使用在最后的时候使用了一个 a 标签，表示这是一个链接。<strong>th:href</strong> 里面表示的是链接值，链接值的id，使用了REST风格的形式。</p><p><strong>onclick</strong>则是表达点击下去会发生什么。这里运用了js的知识，返回了一个函数del()，看一下这个del函数：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">src</span>=<span class="string">"https://code.jquery.com/jquery-3.2.1.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">del</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">if</span> (confirm(<span class="string">"您确定要删除吗？"</span>)) &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="actionscript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>它会显示：你是否确定点击这个链接，是则返回true，否则返回false。</p><p><a href="https://gitee.com/antarctica/img_sotre/raw/img/img/thymeleaf/3.png" target="_blank" rel="noopener"><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/thymeleaf/3.png" alt="img"></a></p><p><a href="https://gitee.com/antarctica/img_sotre/raw/img/img/thymeleaf/4.png" target="_blank" rel="noopener"><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/thymeleaf/4.png" alt="img"></a></p><h5 id="展示单个产品"><a href="#展示单个产品" class="headerlink" title="展示单个产品"></a>展示单个产品</h5><p>先添加xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getProduct"</span> <span class="attr">resultType</span>=<span class="string">"product"</span>&gt;</span></span><br><span class="line">select * from t_product where product_name=#&#123;name&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后添加dao层和服务层相应的操作，并再往控制层加上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/showpro/&#123;p&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">showpro</span><span class="params">(@PathVariable(<span class="string">"p"</span>)</span> String product,Model model)</span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">"product"</span>,productService.get(product));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"show"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会接收到从index页面传入的产品名称，并且访问数据库，读取出相应的数据</p><p>再更改html类型</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">"@&#123;showpro/&#123;p&#125;(p=$&#123;product.getProductName()&#125;)&#125;"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">th:value</span>=<span class="string">"$&#123;product.getProductName()&#125;"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">type</span>=<span class="string">"submit"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">th:text</span>=<span class="string">"$&#123;product.productName&#125;"</span>&gt;</span>产品名称<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>之后的改动都以此类推，多试几次，逻辑是很简单的。</p><h5 id="产品分页"><a href="#产品分页" class="headerlink" title="产品分页"></a>产品分页</h5><p>如果我们的产品有很多，想必就不能一口气全部展示出来，这个时候，就要实现分页功能。</p><p>首先要引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--分页插件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>主要引入的依赖最好为这样由springboot自动注入的形式，而不是直接就引入pagehelpe的jar包。</p><p>然后在Controller层增加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分页功能</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/page"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">page</span><span class="params">(Model model,</span></span></span><br><span class="line"><span class="function"><span class="params">                   @RequestParam(defaultValue = <span class="string">"1"</span>)</span> Integer pageNum,</span></span><br><span class="line"><span class="function">                   @<span class="title">RequestParam</span><span class="params">(defaultValue = <span class="string">"2"</span>)</span> Integer pageSize)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//引入分页查询，使用PageHelper分页功能在查询之前传入当前页，然后多少记录</span></span><br><span class="line">    PageHelper.startPage(pageNum, pageSize);</span><br><span class="line">    <span class="comment">//startPage后紧跟的这个查询就是分页查询</span></span><br><span class="line">    List&lt;Product&gt; products=productService.ShowAll();</span><br><span class="line">    <span class="comment">//使用PageInfo包装查询结果，只需要将pageInfo交给页面就可以</span></span><br><span class="line">    PageInfo pageInfo = <span class="keyword">new</span> PageInfo&lt;Product&gt;(products, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    model.addAttribute(<span class="string">"pageInfo"</span>, pageInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得当前页</span></span><br><span class="line">    model.addAttribute(<span class="string">"pageNum"</span>, pageInfo.getPageNum());</span><br><span class="line">    <span class="comment">//获得一页显示的条数</span></span><br><span class="line">    model.addAttribute(<span class="string">"pageSize"</span>, pageInfo.getPageSize());</span><br><span class="line">    <span class="comment">//是否是第一页</span></span><br><span class="line">    model.addAttribute(<span class="string">"isFirstPage"</span>, pageInfo.isIsFirstPage());</span><br><span class="line">    <span class="comment">//获得总页数</span></span><br><span class="line">    model.addAttribute(<span class="string">"totalPages"</span>, pageInfo.getPages());</span><br><span class="line">    <span class="comment">//是否是最后一页</span></span><br><span class="line">    model.addAttribute(<span class="string">"isLastPage"</span>, pageInfo.isIsLastPage());</span><br><span class="line"></span><br><span class="line">    model.addAttribute(<span class="string">"products"</span>, pageInfo.getList());</span><br><span class="line">    System.out.println(pageInfo.getList()+<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的做法比较浅显而且易读，首先由@RequestParam(defaultValue = “1”)去定义默认值，在默认的情况下先打开第一页，并且第一页有着两条信息。PageHelper.startPage则是指定，分页功能，使其在全局生效。而那些model的作用，是用来交接HTML页面的。</p><p>修改index.html页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">src</span>=<span class="string">"https://code.jquery.com/jquery-3.2.1.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">del</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (confirm(<span class="string">"您确定要删除吗？"</span>)) &#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="actionscript">            &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">th:each</span>=<span class="string">"product:$&#123;pageInfo.list&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;product.id&#125;"</span>&gt;</span>id<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">"@&#123;showpro/&#123;p&#125;(p=$&#123;product.getProductName()&#125;)&#125;"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">th:value</span>=<span class="string">"$&#123;product.getProductName()&#125;"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">type</span>=<span class="string">"submit"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">th:text</span>=<span class="string">"$&#123;product.productName&#125;"</span>&gt;</span>产品名称<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;product.stock&#125;"</span>&gt;</span>库存<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;product.price&#125;"</span>&gt;</span>价格<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;product.version&#125;"</span>&gt;</span>版本<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;product.note&#125;"</span>&gt;</span>备注<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">"@&#123;deletelist/&#123;id&#125;(id=$&#123;product.getId()&#125;)&#125;"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">th:value</span>=<span class="string">"$&#123;product.getId()&#125;"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">onclick</span>=<span class="string">"return del()"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"add"</span>&gt;</span>增加产品<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"delete"</span>&gt;</span>删除产品<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"pagination"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:if</span>=<span class="string">"$&#123;not isFirstPage&#125;"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;$&#123;'/page'&#125;(pageNum=$&#123;pageNum-1&#125;,pageSize=$&#123;pageSize&#125;)&#125;"</span> <span class="attr">aria-label</span>=<span class="string">"Previous"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="symbol">&amp;laquo;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:if</span>=<span class="string">"$&#123;isFirstPage&#125;"</span> <span class="attr">href</span>=<span class="string">"javascript:void(0);"</span> <span class="attr">aria-label</span>=<span class="string">"Previous"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="symbol">&amp;laquo;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">th:each</span>=<span class="string">"pageNo : $&#123;#numbers.sequence(1, totalPages)&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:if</span>=<span class="string">"$&#123;pageNum eq pageNo&#125;"</span> <span class="attr">href</span>=<span class="string">"javascript:void(0);"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;pageNo&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:if</span>=<span class="string">"$&#123;not (pageNum eq pageNo)&#125;"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;$&#123;'/page'&#125;(pageNum=$&#123;pageNo&#125;,pageSize=$&#123;pageSize&#125;)&#125;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;pageNo&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:if</span>=<span class="string">"$&#123;not isLastPage&#125;"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;$&#123;'/page'&#125;(pageNum=$&#123;pageNum+1&#125;,pageSize=$&#123;pageSize&#125;)&#125;"</span> <span class="attr">aria-label</span>=<span class="string">"Next"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="symbol">&amp;raquo;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:if</span>=<span class="string">"$&#123;isLastPage&#125;"</span> <span class="attr">href</span>=<span class="string">"javascript:void(0);"</span> <span class="attr">aria-label</span>=<span class="string">"Next"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="symbol">&amp;raquo;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在index页面添加了有关于分页的信息，这里是使用了thymeleaf语法来完成和实现的。</p><p>th:if=”${not isFirstPage} 表示着如果存在isFirstPage，或者说不存在isFirstPage的值为真，那么将不会显示上一页，否则则显示。可能有点绕，简而言之，就是如果不为真为真，则XXX…….</p><p>然后就是如果为真，则显示href=”javascript:void(0);”，这表示着仍然是本页，不进行任何更改。</p><p>而中间的这段：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">th:each</span>=<span class="string">"pageNo : $&#123;#numbers.sequence(1, totalPages)&#125;"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>则是表示中间还有多少页的意思。并且定位到相应的页面。</p><p>而之后的next，和previous差不多。它们所获取到的值，其实都是model里面的key-value值。</p><p><strong>测试：</strong></p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/thymeleaf/5.png" alt=""></p><h5 id="一些错误"><a href="#一些错误" class="headerlink" title="一些错误"></a>一些错误</h5><p>前面的实验都是没有引入css和js的，如果要引入这些资源的话，css和js必须放在static目录下。</p><p>如果还是无法获得静态资源，那么就在application.yml中加入：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/static/**</span></span><br></pre></td></tr></table></figure><p>强行扫描所有静态资源</p><h4 id="标准表达式语法"><a href="#标准表达式语法" class="headerlink" title="标准表达式语法"></a>标准表达式语法</h4><h5 id="变量表达式"><a href="#变量表达式" class="headerlink" title="变量表达式"></a>变量表达式</h5><p>我们使用${xxxxx}，就是一个变量表达式，它能够获取从控制层中传入的Model。</p><h5 id="选择表达式"><a href="#选择表达式" class="headerlink" title="选择表达式"></a>选择表达式</h5><p>*{xxxxxx}，使用预先选择的对象来表达，可理解为是能够获取实例中的属性。</p><h5 id="文字国际化表达式"><a href="#文字国际化表达式" class="headerlink" title="文字国际化表达式"></a>文字国际化表达式</h5><p>文字国际化表达式允许我们从一个外部文件获取区域文字信息(.properties)，用 Key 索引 Value，还可以提供一组参数(可选)：</p><p>#{main.title}<br>#{message.entrycreated(${entryId})}</p><p>这个主要的做法是用于整个网站的字体或者语言文字转化。</p><h5 id="URL表达式"><a href="#URL表达式" class="headerlink" title="URL表达式"></a>URL表达式</h5><p>@{XXXXX}，能够把一个有用的上下文或者是回话信息添加到URL</p><h5 id="表达式支持的语法"><a href="#表达式支持的语法" class="headerlink" title="表达式支持的语法"></a>表达式支持的语法</h5><p>字面（Literals）</p><ul><li>文本文字（Text literals）: ‘one text’, ‘Another one!’,…</li><li>数字文本（Number literals）: 0, 34, 3.0, 12.3,…</li><li>布尔文本（Boolean literals）:true, false</li><li>空（Null literal）:null</li><li>文字标记（Literal tokens）:one, sometext, main,…</li></ul><p>文本操作（Text operations）</p><ul><li>字符串连接(String concatenation):+</li><li>文本替换（Literal substitutions）:|The name is ${name}|</li></ul><p>算术运算（Arithmetic operations）</p><ul><li>二元运算符（Binary operators）:+, -, *, /, %</li><li>减号（单目运算符）Minus sign (unary operator):-</li></ul><p>布尔操作（Boolean operations）</p><ul><li>二元运算符（Binary operators）:and, or</li><li>布尔否定（一元运算符）Boolean negation (unary operator):!, not</li></ul><p>比较和等价(Comparisons and equality)</p><ul><li>比较（Comparators）:&gt;, &lt;, &gt;=, &lt;= (gt, lt, ge, le)</li><li>等值运算符（Equality operators）:==, != (eq, ne)</li></ul><p>条件运算符（Conditional operators）</p><ul><li>If-then:(if) ? (then)</li><li>If-then-else:(if) ? (then) : (else)</li><li>Default: (value) ?:(defaultvalue)</li></ul><h3 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h3><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/thymeleaf/q.jpg" alt=""></p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/thymeleaf/q.jpg" alt=""></p><p>源码地址：</p><p><a href="https://github.com/Antarctica000/SpringBoot/tree/master/thymeleaf">https://github.com/Antarctica000/SpringBoot/tree/master/thymeleaf</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 前端 </tag>
            
            <tag> Thymeleaf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识整合：抢购商品</title>
      <link href="/2020/01/20/spring5/"/>
      <url>/2020/01/20/spring5/</url>
      
        <content type="html"><![CDATA[<h2 id="高并发下抢购商品"><a href="#高并发下抢购商品" class="headerlink" title="高并发下抢购商品"></a>高并发下抢购商品</h2><p>这次做一个知识的总结，把之前所学习的mybatis、redis，rest、和并发编程相关的内容整合起来，模拟一个小型的场景。</p><p>这次场景叫做：抢购商品。我们在淘宝或者京东买东西的时候，偶尔某些商品会有一些打折期。这时候就有很多人去抢购商品，同时也是最考验我们数据库性能和后端设计的时候了。</p><h3 id="设计与开发"><a href="#设计与开发" class="headerlink" title="设计与开发"></a>设计与开发</h3><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>先建立两个表，分别为产品表和订单表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`springtest`</span>.<span class="string">`t_product`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">INT</span>(<span class="number">12</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'编号'</span>,</span><br><span class="line">  <span class="string">`product_name`</span> <span class="built_in">VARCHAR</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'产品名称'</span>,</span><br><span class="line">  <span class="string">`stock`</span> <span class="built_in">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'库存'</span>,</span><br><span class="line">  <span class="string">`price`</span> <span class="built_in">DECIMAL</span>(<span class="number">16</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'单价'</span>,</span><br><span class="line">  <span class="string">`version`</span> <span class="built_in">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'版本号'</span>,</span><br><span class="line">  <span class="string">`note`</span> <span class="built_in">VARCHAR</span>(<span class="number">256</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'备注'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>));</span><br></pre></td></tr></table></figure><p>订单表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`springtest`</span>.<span class="string">`t_purchase_record`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">INT</span>(<span class="number">12</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'编号'</span>,</span><br><span class="line">  <span class="string">`user_id`</span> <span class="built_in">INT</span>(<span class="number">12</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户编号'</span>,</span><br><span class="line">  <span class="string">`product_id`</span> <span class="built_in">INT</span>(<span class="number">12</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'产品编号'</span>,</span><br><span class="line">  <span class="string">`price`</span> <span class="built_in">DECIMAL</span>(<span class="number">16</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'价格'</span>,</span><br><span class="line">  <span class="string">`quantity`</span> <span class="built_in">INT</span>(<span class="number">12</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'数量'</span>,</span><br><span class="line">  <span class="string">`sum`</span> <span class="built_in">DECIMAL</span>(<span class="number">16</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'总价'</span>,</span><br><span class="line">  <span class="string">`purchase_date`</span> <span class="built_in">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">now</span>() <span class="keyword">COMMENT</span> <span class="string">'购买日期'</span>,</span><br><span class="line">  <span class="string">`note`</span> <span class="built_in">VARCHAR</span>(<span class="number">512</span>) <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'备注'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>));</span><br></pre></td></tr></table></figure><h4 id="持久层开发"><a href="#持久层开发" class="headerlink" title="持久层开发"></a>持久层开发</h4><h5 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Alias</span>(<span class="string">"product"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductPo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3288311147760635602L</span>;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String productName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> version;</span><br><span class="line">    <span class="keyword">private</span> String note;   </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Alias</span>(<span class="string">"purchaseRecord"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PurchaseRecordPo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">360816189433370174L</span>;</span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"><span class="keyword">private</span> Long userId;</span><br><span class="line"><span class="keyword">private</span> Long productId;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> quantity;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> sum;</span><br><span class="line"><span class="keyword">private</span> Timestamp purchaseTime;</span><br><span class="line"><span class="keyword">private</span> String note;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里接入了 Serializable，之所以要这么做，是为了<strong>序列化</strong>。</p><p>什么情况下需要序列化？</p><ul><li>a）当你想把的内存中的对象写入到硬盘的时候；</li><li>b）当你想用套接字在网络上传送对象的时候；</li><li>c）当你想通过RMI传输对象的时候</li></ul><p>总的就是说安全性问题，具体原因见解释：假如没有一个接口（即没有Serializable来标记是否可以序列化），让所有对象都可以序列化。那么所有对象通过序列化存储到硬盘上后，都可以在序列化得到的文件中看到属性对应的值（后面将会通过代码展示）。所以最后为了安全性（即不让一些对象中私有属性的值被外露），不能让所有对象都可以序列化。要让用户自己来选择是否可以序列化，因此需要一个接口来标记该类是否可序列化。。</p><p>最重要的两个原因是：<br>　　1、将对象的状态保存在存储媒体中以便可以在以后重新创建出完全相同的副本；<br>　　2、按值将对象从一个应用程序域发送至另一个应用程序域。<br>通俗的说：在分布式应用中，你就得实现序列化，如果你不需要分布式应用，那就没那个必要实现序列化。</p><h5 id="xml设计"><a href="#xml设计" class="headerlink" title="xml设计"></a>xml设计</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.example.designshop.dao.ProductDao"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 获取产品 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getProduct"</span> <span class="attr">parameterType</span>=<span class="string">"long"</span> <span class="attr">resultType</span>=<span class="string">"product"</span>&gt;</span></span><br><span class="line">select id, product_name as productName,</span><br><span class="line">stock, price, version, note from t_product</span><br><span class="line">where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 减库存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"decreaseProduct"</span>&gt;</span></span><br><span class="line">update t_product set stock = stock - #&#123;quantity&#125;,</span><br><span class="line">version = version +1</span><br><span class="line">where id = #&#123;id&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.example.designshop.dao.PurchaseRecordDao"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertPurchaseRecord"</span> <span class="attr">parameterType</span>=<span class="string">"purchaseRecord"</span>&gt;</span></span><br><span class="line">insert into t_purchase_record(</span><br><span class="line">user_id, product_id, price, quantity, sum, purchase_date, note)</span><br><span class="line">values(#&#123;userId&#125;, #&#123;productId&#125;, #&#123;price&#125;, #&#123;quantity&#125;,</span><br><span class="line">#&#123;sum&#125;, now(), #&#123;note&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="dao层"><a href="#dao层" class="headerlink" title="dao层"></a>dao层</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProductPo <span class="title">getProduct</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//减库存，而@Param标明MyBatis参数传递给后台</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">decreaseProduct</span><span class="params">(@Param(<span class="string">"id"</span>)</span> Long id, @<span class="title">Param</span><span class="params">(<span class="string">"quantity"</span>)</span> <span class="keyword">int</span> quantity)</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PurchaseRecordDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertPurchaseRecord</span><span class="params">(PurchaseRecordPo pr)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:&#x2F;mapper&#x2F;*.xml</span><br><span class="line">  type-aliases-package: com.example.designshop.pojo</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br><span class="line">    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;springtest?useSSL&#x3D;false&amp;serverTimezone&#x3D;GMT%2B8&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    tomcat:</span><br><span class="line">      max-idle: 10</span><br><span class="line">      max-wait: 10000</span><br><span class="line">      max-active: 50</span><br><span class="line">      initial-size: 5</span><br><span class="line">      # 隔离级别为读写提交</span><br><span class="line">      default-transaction-isolation: 2</span><br><span class="line">server:</span><br><span class="line">  port: 8888</span><br></pre></td></tr></table></figure><p>隔离级别涉及到数据库事务相关，譬如脏读可重复读等待，以后会讲。</p><h5 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PurchaseService</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理购买业务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userId 用户编号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> productId 产品编号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> quantity 购买数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 成功or失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">purchase</span><span class="params">(Long userId, Long productId, <span class="keyword">int</span> quantity)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PurchaseServiceImpl</span> <span class="keyword">implements</span> <span class="title">PurchaseService</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ProductDao productDao = <span class="keyword">null</span>;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PurchaseRecordDao purchaseRecordDao = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="comment">// 启动Spring数据库事务机制</span></span><br><span class="line"> <span class="meta">@Transactional</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">purchase</span><span class="params">(Long userId, Long productId, <span class="keyword">int</span> quantity)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 获取产品</span></span><br><span class="line"> ProductPo product = productDao.getProduct(productId);</span><br><span class="line"> <span class="comment">// 比较库存和购买数量</span></span><br><span class="line"> <span class="keyword">if</span> (product.getStock() &lt; quantity) &#123;</span><br><span class="line"> <span class="comment">// 库存不足</span></span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 扣减库存</span></span><br><span class="line"> productDao.decreaseProduct(productId, quantity);</span><br><span class="line"> <span class="comment">// 初始化购买记录</span></span><br><span class="line"> PurchaseRecordPo pr = <span class="keyword">this</span>.initPurchaseRecord(userId, product, quantity);</span><br><span class="line"> <span class="comment">// 插入购买记录</span></span><br><span class="line"> purchaseRecordDao.insertPurchaseRecord(pr);</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="comment">// 初始化购买信息</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> PurchaseRecordPo <span class="title">initPurchaseRecord</span><span class="params">(Long userId, ProductPo product, <span class="keyword">int</span> quantity)</span> </span>&#123;</span><br><span class="line">PurchaseRecordPo pr = <span class="keyword">new</span> PurchaseRecordPo();</span><br><span class="line">pr.setNote(<span class="string">"购买日志，时间："</span> + System.currentTimeMillis());</span><br><span class="line">pr.setPrice(product.getPrice());</span><br><span class="line">pr.setProductId(product.getId());</span><br><span class="line">pr.setQuantity(quantity);</span><br><span class="line"><span class="keyword">double</span> sum = product.getPrice() * quantity;</span><br><span class="line">pr.setSum(sum);</span><br><span class="line">pr.setUserId(userId);</span><br><span class="line"><span class="keyword">return</span> pr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里很明显的可以看到，我们从Dao层读取数据，看看是否还有库存，如果库存不足，则直接返回false，否则进行扣减库存，并且更新订单表。</p><h5 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// REST风格控制器</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PurchaseController</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">PurchaseService purchaseService = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">testPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ModelAndView mv = <span class="keyword">new</span> ModelAndView(<span class="string">"test"</span>);</span><br><span class="line"><span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/purchase"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">purchase</span><span class="params">(Long userId, Long productId, Integer quantity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> success = purchaseService.purchase(userId, productId, quantity);</span><br><span class="line">String message = success ? <span class="string">"抢购成功"</span> : <span class="string">"抢购失败"</span>;</span><br><span class="line">Result result = <span class="keyword">new</span> Result(success, message);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 响应结果</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">private</span> String message = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Result</span><span class="params">(<span class="keyword">boolean</span> success, String message)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.success = success;</span><br><span class="line"><span class="keyword">this</span>.message = message;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制层从从服务层调用方法，并且将数据装进响应结果里面。可以从控制层看到的是，我们是通过result传达信息到前端的。</p><h5 id="Html"><a href="#Html" class="headerlink" title="Html"></a>Html</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">src</span>=<span class="string">"https://code.jquery.com/jquery-3.2.1.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--后面需要改写这段JavaScript脚本进行测试--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">         <span class="keyword">var</span> params = &#123;</span></span><br><span class="line">             userId : 1,</span><br><span class="line">             productId : 1,</span><br><span class="line">             quantity : 3</span><br><span class="line">         &#125;;</span><br><span class="line"><span class="actionscript">         <span class="comment">// 通过POST请求后端</span></span></span><br><span class="line"><span class="javascript">         $.post(<span class="string">"./purchase"</span>, params, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span></span><br><span class="line">             alert(result.message);</span><br><span class="line">         &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>前端会使用post方法，去请求后端，执行方法。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>这是数据库库存：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/1.png" alt=""></p><p>在网页输入 <a href="http://localhost:8888/test" target="_blank" rel="noopener">http://localhost:8888/test</a></p><p>测试结果：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/3.png" alt=""></p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/2.png" alt=""></p><p>抢购成功！</p><p>回看数据库：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/4.png" alt=""></p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/5.png" alt=""></p><h3 id="高并发情况下"><a href="#高并发情况下" class="headerlink" title="高并发情况下"></a>高并发情况下</h3><h4 id="500次抢购"><a href="#500次抢购" class="headerlink" title="500次抢购"></a>500次抢购</h4><p>上面的例子仅仅是在一个单例进行的测试，那么，在高并发情况下，有着很多很多的请求呢？</p><p>我们假设有300的库存：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/6.png" alt=""></p><p>在html页面设置 500次抢购：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for (var i=1; i<span class="tag">&lt;<span class="name">=500;</span> <span class="attr">i</span>++) &#123;</span></span><br><span class="line"><span class="tag">    <span class="attr">var</span> <span class="attr">params</span> = <span class="string">&#123;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">userId</span> <span class="attr">:</span> <span class="attr">1</span>,</span></span><br><span class="line"><span class="tag">        <span class="attr">productId</span> <span class="attr">:</span> <span class="attr">1</span>,</span></span><br><span class="line"><span class="tag">        <span class="attr">quantity</span> <span class="attr">:</span> <span class="attr">1</span></span></span><br><span class="line"><span class="tag">    &#125;;</span></span><br><span class="line"><span class="tag">    // 通过<span class="attr">POST</span>请求后端,这里的<span class="attr">JavaScript</span>会采用异步请求</span></span><br><span class="line"><span class="tag">    $<span class="attr">.post</span>("<span class="attr">.</span>/<span class="attr">purchase</span>", <span class="attr">params</span>, <span class="attr">function</span>(<span class="attr">result</span>) &#123;</span></span><br><span class="line"><span class="tag">    &#125;);</span></span><br><span class="line"><span class="tag">&#125;</span></span><br></pre></td></tr></table></figure><p>再次输入  <a href="http://localhost:8888/test" target="_blank" rel="noopener">http://localhost:8888/test</a> 进行测试：</p><p>结果：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/7.png" alt=""></p><p>？？？？ -5？</p><p>为什么会有这样数据，我们再看看订单表：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/8.png" alt=""></p><p>确实有着305条订单，显然，数据库事务的读写级别虽然达到了一致性，却没有达到原子性。面对这种情况，根据我们所学的知识，在并发编程里，可以使用<strong>锁</strong>去完成。</p><h4 id="使用悲观锁"><a href="#使用悲观锁" class="headerlink" title="使用悲观锁"></a>使用悲观锁</h4><p>在这样的高并发情况下，最简单粗暴的解决方法就是加锁，下面我们为数据库加一条锁，在xml 加入 for update 。就使用了悲观锁，当前的SQL被执行时，不允许其他线程执行该SQL。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getProduct"</span> <span class="attr">parameterType</span>=<span class="string">"long"</span> <span class="attr">resultType</span>=<span class="string">"product"</span>&gt;</span></span><br><span class="line">select id, product_name as productName,</span><br><span class="line">stock, price, version, note from t_product</span><br><span class="line">where id=#&#123;id&#125; for update </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再打开 <a href="http://localhost:8888/test" target="_blank" rel="noopener">http://localhost:8888/test</a>  进行测试：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/9.png" alt=""></p><p>我们发现，成功保持了只有300条的订单。但是，在使用这样悲观锁的前提下，数据库的性能会变成很差，效率也就变的缓慢。所以，我们开始引入乐观锁。</p><h4 id="使用乐观锁"><a href="#使用乐观锁" class="headerlink" title="使用乐观锁"></a>使用乐观锁</h4><p>乐观锁是一种不使用数据库锁和不阻塞线程并发的方案。就是一个线程一开始先读取商品库存数据，保存起来，我们把这些旧数据称之为旧值，然后执行一定的业务逻辑，等到需要对共享数据做修改时，会事先将保存的旧值库存与当前数据库的库存进行比较，如果旧值与当前库存一致，它就认为数据没有被修改过，否则就认为数据已经被修改过，当前计算将不被信任，所以就不再修改任何数据。</p><p>这就是多线程的概念 :CAS</p><p>然而，这一种方案却会引发一种ABA问题。关于ABA问题，之前在讲AtomicInteger 的时候谈论过，这里再放一个例子：</p><p>AbA问题的产生：要了解什么是ABA问题，首先我们来通俗的看一下这个例子，一家火锅店为了生意推出了一个特别活动，凡是在五一期间的老用户凡是卡里余额小于20的，赠送10元，但是这种活动没人只可享受一次。然后火锅店的后台程序员小王开始工作了，很简单就用cas技术，先去用户卡里的余额，然后包装成AtomicInteger，写一个判断，开启10个线程，然后判断小于20的，一律加20，然后就很开心的交差了。可是过了一段时间，发现账面亏损的厉害，老板起先的预支是2000块，因为店里的会员总共也就100多个，就算每人都符合条件，最多也就2000啊，怎么预支了这么多。小王一下就懵逼了，赶紧debug，tail -f一下日志，这不看不知道，一看吓一跳，有个客户被充值了10次!</p><p>阐述：</p><p>假设有个线程A去判断账户里的钱此时是15，满足条件，直接+20，这时候卡里余额是35.但是此时不巧，正好在连锁店里，这个客人正在消费，又消费了20，此时卡里余额又为15，线程B去执行扫描账户的时候，发现它又小于20，又用过cas给它加了20，这样的话就相当于加了两次，这样循环往复肯定把老板的钱就坑没了！</p><p>本质：</p><p>ABA问题的根本在于cas在修改变量的时候，无法记录变量的状态，比如修改的次数，否修改过这个变量。这样就很容易在一个线程将A修改成B时，另一个线程又会把B修改成A,造成casd多次执行的问题。</p><p>为了解决这样的问题，我们在这个例子中引入了版本号。</p><h5 id="增加版本号判断"><a href="#增加版本号判断" class="headerlink" title="增加版本号判断"></a>增加版本号判断</h5><p>在xml中修改：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 减库存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"decreaseProduct"</span>&gt;</span></span><br><span class="line">update t_product set stock = stock - #&#123;quantity&#125;,</span><br><span class="line">version = version +1</span><br><span class="line">where id = #&#123;id&#125; and version =  #&#123;version&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在DAO层中修改定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">decreaseProduct</span><span class="params">(@Param(<span class="string">"id"</span>)</span> Long id,</span></span><br><span class="line"><span class="function">    @<span class="title">Param</span><span class="params">(<span class="string">"quantity"</span>)</span> <span class="keyword">int</span> quantity, @<span class="title">Param</span><span class="params">(<span class="string">"version"</span>)</span> <span class="keyword">int</span> version)</span>;</span><br></pre></td></tr></table></figure><p>修改服务层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">// 启动Spring数据库事务机制</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">purchase</span><span class="params">(Long userId, Long productId, <span class="keyword">int</span> quantity)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取产品（线程旧值）</span></span><br><span class="line">ProductPo product = productDao.getProduct(productId);</span><br><span class="line"><span class="comment">// 比较库存和购买数量</span></span><br><span class="line"><span class="keyword">if</span> (product.getStock() &lt; quantity) &#123;</span><br><span class="line"><span class="comment">// 库存不足</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取当前版本号</span></span><br><span class="line"><span class="keyword">int</span> version = product.getVersion();</span><br><span class="line"><span class="comment">// 扣减库存,同时将当前版本号发送给后台去比较</span></span><br><span class="line"><span class="keyword">int</span> result = productDao.decreaseProduct(productId, quantity, version);</span><br><span class="line"><span class="comment">// 如果更新数据失败，说明数据在多线程中被其他线程修改，导致失败返回</span></span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化购买记录</span></span><br><span class="line">PurchaseRecordPo pr = <span class="keyword">this</span>.initPurchaseRecord(userId, product, quantity);</span><br><span class="line"><span class="comment">// 插入购买记录</span></span><br><span class="line">purchaseRecordDao.insertPurchaseRecord(pr);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到，我们每次执行都会去数据库读取版本号，如果一致则版本号+1，并且修改，否则则返回false。</p><p>再次测试：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/10.png" alt=""></p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/11.png" alt=""></p><p>居然还有库存？？？</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/12.png" alt=""></p><p>显然，大量的请求得到了大量的失败，这就导致了我们500次的读取却只有84次是成功的。</p><p>为了解决这个问题，乐观锁还可以引入重入机制，就是一旦更新失败，就重新做一次，而不是结束请求。</p><h5 id="按时间戳重入"><a href="#按时间戳重入" class="headerlink" title="按时间戳重入"></a>按时间戳重入</h5><p>但是这样又引入了其他问题，比如，SQL被执行的次数总数恐怕达到了上千次。为了克服这个问题，我们引入时间戳的方法来试试重入机制。</p><p>修改服务层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动Spring数据库事务机制</span></span><br><span class="line"><span class="meta">@Transactional</span>(isolation = Isolation.READ_COMMITTED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">purchase</span><span class="params">(Long userId, Long productId, <span class="keyword">int</span> quantity)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 当前时间</span></span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="comment">// 循环尝试直至成功</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">// 循环时间</span></span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"><span class="comment">// 如果循环时间大于100毫秒返回终止循环</span></span><br><span class="line"><span class="keyword">if</span> (end - start &gt; <span class="number">100</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取产品</span></span><br><span class="line">ProductPo product = productDao.getProduct(productId);</span><br><span class="line"><span class="comment">// 获取当前版本号</span></span><br><span class="line"><span class="keyword">int</span> version = product.getVersion();</span><br><span class="line"><span class="comment">// 比较库存和购买数量</span></span><br><span class="line"><span class="keyword">if</span> (product.getStock() &lt; quantity) &#123;</span><br><span class="line"><span class="comment">// 库存不足</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扣减库存,同时将当前版本号发送给后台去比较</span></span><br><span class="line"><span class="keyword">int</span> result = productDao.decreaseProduct(productId, quantity, version);</span><br><span class="line"><span class="comment">// 如果更新数据失败，说明数据在多线程中被其他线程修改，</span></span><br><span class="line"><span class="comment">// 导致失败，则通过循环重入尝试购买商品</span></span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化购买记录</span></span><br><span class="line">PurchaseRecordPo pr = <span class="keyword">this</span>.initPurchaseRecord(userId, product, quantity);</span><br><span class="line"><span class="comment">// 插入购买记录</span></span><br><span class="line">purchaseRecordDao.insertPurchaseRecord(pr);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将一个请求限制为100ms的生存期，如果在100ms内发生版本号冲突而不能更新的，则重新尝试，否则请求失败。</p><p>开始测试：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/13.png" alt=""></p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/14.png" alt=""></p><p>可以看到，测试成功了。</p><p>但是按照时间戳重入也有一个弊端，那就是系统会随着自身的忙碌而大大减少重入次数，因此有时候也会采用按次数重入的机制。</p><h5 id="按次数重入"><a href="#按次数重入" class="headerlink" title="按次数重入"></a>按次数重入</h5><p>服务层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">// 启动Spring数据库事务机制，并将隔离级别设置为读写提交</span></span><br><span class="line"><span class="meta">@Transactional</span>(isolation = Isolation.READ_COMMITTED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">purchase</span><span class="params">(Long userId, Long productId, <span class="keyword">int</span> quantity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前时间</span></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 循环尝试直至成功</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 循环时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 如果循环时间大于100毫秒返回终止循环</span></span><br><span class="line">        <span class="keyword">if</span> (end - start &gt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取产品</span></span><br><span class="line">        ProductPo product = productDao.getProduct(productId);</span><br><span class="line">        <span class="comment">// 比较库存和购买数量</span></span><br><span class="line">        <span class="keyword">if</span> (product.getStock() &lt; quantity) &#123;</span><br><span class="line">            <span class="comment">// 库存不足</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取当前版本号</span></span><br><span class="line">        <span class="keyword">int</span> version = product.getVersion();</span><br><span class="line">        <span class="comment">// 扣减库存,同时将当前版本号发送给后台去比较</span></span><br><span class="line">        <span class="keyword">int</span> result = productDao.decreaseProduct(productId, quantity,version);</span><br><span class="line">        <span class="comment">// 如果更新数据失败，说明数据在多线程中被其他线程修改，</span></span><br><span class="line">        <span class="comment">// 导致失败，则通过循环重入尝试购买商品</span></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化购买记录</span></span><br><span class="line">        PurchaseRecordPo pr = <span class="keyword">this</span>.initPurchaseRecord(userId, product, quantity);</span><br><span class="line">        <span class="comment">// 插入购买记录</span></span><br><span class="line">        purchaseRecordDao.insertPurchaseRecord(pr);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里使用for的三重循环进行尝试。三次去尝试获取锁，如果都不能够成功获得，则请求失败。但是使用乐观锁，还是一个相对来说比较复杂的方式，因为在不同场景下势必要在后端中多次更改代码。现在，可以使用Redis缓存，去解决这个问题。</p><h4 id="使用Redis处理高并发"><a href="#使用Redis处理高并发" class="headerlink" title="使用Redis处理高并发"></a>使用Redis处理高并发</h4><p>在高并发的环境下，仅仅使用数据库去完成业务，是不够的。在前人的摸索中，开发出了一个叫Redis的缓存，去搭配数据库完成业务。</p><p>数据库是一个读写磁盘的过程，这个速度显然没有直接写入内存的Redis快。Redis的机制也能够帮助我们克服超发现象。但是，因为其命令方式的运算能力比较薄弱，所以往往采用Redis Luau去代替它原有的命令方式。</p><p>Redis Lua在Redis的执行中是具备原子性的，当它被执行时不会被其他客户端发送的命令所打断，通过这样一种机制可以在高并发环境下考虑使用Redis去代替数据库作为响应用户的数据载体。</p><p>设计主要分两部分：</p><ul><li>先使用Redis响应高并发用户的请求。</li><li>启动定时任务将Redis保存到数据库。</li></ul><h5 id="配置文件："><a href="#配置文件：" class="headerlink" title="配置文件："></a>配置文件：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis:</span><br><span class="line">  jedis:</span><br><span class="line">    pool:</span><br><span class="line">      min-idle: 5</span><br><span class="line">      max-active: 10</span><br><span class="line">      max-idle: 10</span><br><span class="line">      max-wait: 2000</span><br><span class="line">  port: 6379</span><br><span class="line">  host: localhost</span><br><span class="line">  timeout: 1000</span><br></pre></td></tr></table></figure><h5 id="服务层-1"><a href="#服务层-1" class="headerlink" title="服务层"></a>服务层</h5><p>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">purchaseRedis</span><span class="params">(Long userId, Long productId, <span class="keyword">int</span> quantity)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">dealRedisPurchase</span><span class="params">(List&lt;PurchaseRecordPo&gt; prpList)</span></span>;</span><br></pre></td></tr></table></figure><p>定制属于Redis的查找和删除</p><p>服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">StringRedisTemplate stringRedisTemplate = <span class="keyword">null</span>;</span><br><span class="line">String purchaseScript =</span><br><span class="line"><span class="comment">// 先将产品编号保存到集合中</span></span><br><span class="line"><span class="string">" redis.call('sadd', KEYS[1], ARGV[2]) \n"</span></span><br><span class="line"><span class="comment">// 购买列表</span></span><br><span class="line">+ <span class="string">"local productPurchaseList = KEYS[2]..ARGV[2] \n"</span></span><br><span class="line"><span class="comment">// 用户编号</span></span><br><span class="line">+ <span class="string">"local userId = ARGV[1] \n"</span></span><br><span class="line"><span class="comment">// 产品key</span></span><br><span class="line">+ <span class="string">"local product = 'product_'..ARGV[2] \n"</span></span><br><span class="line"><span class="comment">// 购买数量</span></span><br><span class="line">+ <span class="string">"local quantity = tonumber(ARGV[3]) \n"</span></span><br><span class="line"><span class="comment">// 当前库存</span></span><br><span class="line">+ <span class="string">"local stock = tonumber(redis.call('hget', product, 'stock')) \n"</span></span><br><span class="line"><span class="comment">// 价格</span></span><br><span class="line">+ <span class="string">"local price = tonumber(redis.call('hget', product, 'price')) \n"</span></span><br><span class="line"><span class="comment">// 购买时间</span></span><br><span class="line">+ <span class="string">"local purchase_date = ARGV[4] \n"</span></span><br><span class="line"><span class="comment">// 库存不足，返回0</span></span><br><span class="line">+ <span class="string">"if stock &lt; quantity then return 0 end \n"</span></span><br><span class="line"><span class="comment">// 减库存</span></span><br><span class="line">+ <span class="string">"stock = stock - quantity \n"</span></span><br><span class="line">+ <span class="string">"redis.call('hset', product, 'stock', tostring(stock)) \n"</span></span><br><span class="line"><span class="comment">// 计算价格</span></span><br><span class="line">+ <span class="string">"local sum = price * quantity \n"</span></span><br><span class="line"><span class="comment">// 合并购买记录数据</span></span><br><span class="line">+ <span class="string">"local purchaseRecord = userId..','..quantity..','"</span></span><br><span class="line">+ <span class="string">"..sum..','..price..','..purchase_date \n"</span></span><br><span class="line"><span class="comment">// 保存到将购买记录保存到list里</span></span><br><span class="line">+ <span class="string">"redis.call('rpush', productPurchaseList, purchaseRecord) \n"</span></span><br><span class="line"><span class="comment">// 返回成功</span></span><br><span class="line">+ <span class="string">"return 1 \n"</span>;</span><br><span class="line"><span class="comment">// Redis购买记录集合前缀</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PURCHASE_PRODUCT_LIST = <span class="string">"purchase_list_"</span>;</span><br><span class="line"><span class="comment">// 抢购商品集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PRODUCT_SCHEDULE_SET = <span class="string">"product_schedule_set"</span>;</span><br><span class="line"><span class="comment">// 32位SHA1编码，第一次执行的时候先让Redis进行缓存脚本返回</span></span><br><span class="line"><span class="keyword">private</span> String sha1 = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">purchaseRedis</span><span class="params">(Long userId, Long productId, <span class="keyword">int</span> quantity)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 购买时间</span></span><br><span class="line">Long purchaseDate = System.currentTimeMillis();</span><br><span class="line">Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 获取原始连接</span></span><br><span class="line">jedis = (Jedis) stringRedisTemplate</span><br><span class="line">.getConnectionFactory().getConnection().getNativeConnection();</span><br><span class="line"><span class="comment">// 如果没有加载过，则先将脚本加载到Redis服务器，让其返回sha1</span></span><br><span class="line"><span class="keyword">if</span> (sha1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">sha1 = jedis.scriptLoad(purchaseScript);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行脚本，返回结果</span></span><br><span class="line">Object res = jedis.evalsha(sha1, <span class="number">2</span>, PRODUCT_SCHEDULE_SET,</span><br><span class="line">PURCHASE_PRODUCT_LIST, userId + <span class="string">""</span>, productId + <span class="string">""</span>,</span><br><span class="line">quantity + <span class="string">""</span>, purchaseDate + <span class="string">""</span>);</span><br><span class="line">Long result = (Long) res;</span><br><span class="line"><span class="keyword">return</span> result == <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 关闭jedis连接</span></span><br><span class="line"><span class="keyword">if</span> (jedis != <span class="keyword">null</span> &amp;&amp; jedis.isConnected()) &#123;</span><br><span class="line">jedis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码中的StringRedisTemplate 是由SpringBoot机制自动生成的。</p><p>购买记录中使用了Lua语言，会在第一次执行时，把脚本缓存到Redis服务器中，然后Redis会返回一个 32位的SHA1编码，并缓存到变量sha1中，再通过它将程序需要的键和参数传递到后台去执行Lua脚本。Lua脚本会在减少库存后，将信息缓存起来。</p><p>注意这一段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行脚本，返回结果</span></span><br><span class="line">Object res = jedis.evalsha(sha1, <span class="number">2</span>, PRODUCT_SCHEDULE_SET,</span><br><span class="line">PURCHASE_PRODUCT_LIST, userId + <span class="string">""</span>, productId + <span class="string">""</span>,</span><br><span class="line">quantity + <span class="string">""</span>, purchaseDate + <span class="string">""</span>);</span><br></pre></td></tr></table></figure><p>局部变量sha1代表一个32位的SHA1编码，用来执行缓存在Redis的脚本中，所以PRODUCT_SCHEDULE_SET和PURCHASE_PRODUCT_LIST都只是键。它们在Lua脚本中以Key[index]表示。而index则是它的索引，以1开始。从第二个参数之后，则都是脚本的参数，在Lua脚本中会以ARGV[index]表示。</p><p>最后，保存记录的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">// 当运行方法启用新的独立事务运行</span></span><br><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.REQUIRES_NEW)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dealRedisPurchase</span><span class="params">(List&lt;PurchaseRecordPo&gt; prpList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (PurchaseRecordPo prp : prpList) &#123;</span><br><span class="line">        purchaseRecordDao.insertPurchaseRecord(prp);</span><br><span class="line">        productDao.decreaseProduct(prp.getProductId(), prp.getQuantity());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法将会把购买记录保存到数据库中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Transactional(propagation &#x3D; Propagation.REQUIRES_NEW)</span><br></pre></td></tr></table></figure><p>这个事务传播行为配置为 Propagation.REQUIRES_NEW 这意味这它会将当前事务挂起，开启新的事务，回滚时只会回滚这个方法的内部事务，而不会影响全局事务。</p><h5 id="开启定时任务"><a href="#开启定时任务" class="headerlink" title="开启定时任务"></a>开启定时任务</h5><p>启动器上添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableScheduling</span></span><br></pre></td></tr></table></figure><h5 id="增加定时任务接口"><a href="#增加定时任务接口" class="headerlink" title="增加定时任务接口"></a>增加定时任务接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TaskService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">purchaseTask</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="定时任务服务"><a href="#定时任务服务" class="headerlink" title="定时任务服务"></a>定时任务服务</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskServiceImpl</span> <span class="keyword">implements</span> <span class="title">TaskService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate = <span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PurchaseService purchaseService = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PRODUCT_SCHEDULE_SET = <span class="string">"product_schedule_set"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PURCHASE_PRODUCT_LIST = <span class="string">"purchase_list_"</span>;</span><br><span class="line">    <span class="comment">// 每次取出1000条，避免一次取出消耗太多内存，导致JVM内存溢出</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ONE_TIME_SIZE = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 每天半夜1点钟开始执行任务</span></span><br><span class="line"><span class="comment">//    @Scheduled(cron = "0 0 1 * * ?")</span></span><br><span class="line">    <span class="comment">// 下面是用于测试的配置，每分钟执行一次任务</span></span><br><span class="line">     <span class="meta">@Scheduled</span>(fixedRate = <span class="number">1000</span> * <span class="number">60</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">purchaseTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"定时任务开始......"</span>);</span><br><span class="line">        Set&lt;String&gt; productIdList</span><br><span class="line">    = stringRedisTemplate.opsForSet().members(PRODUCT_SCHEDULE_SET);</span><br><span class="line">        List&lt;PurchaseRecordPo&gt; prpList =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String productIdStr : productIdList) &#123;</span><br><span class="line">            Long productId = Long.parseLong(productIdStr);</span><br><span class="line">            String purchaseKey = PURCHASE_PRODUCT_LIST + productId;</span><br><span class="line">            BoundListOperations&lt;String, String&gt; ops</span><br><span class="line">        = stringRedisTemplate.boundListOps(purchaseKey);</span><br><span class="line">            <span class="comment">// 计算记录数</span></span><br><span class="line">            <span class="keyword">long</span> size = stringRedisTemplate.opsForList().size(purchaseKey);</span><br><span class="line">            Long times = size % ONE_TIME_SIZE == <span class="number">0</span> ? </span><br><span class="line">        size / ONE_TIME_SIZE : size / ONE_TIME_SIZE + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">                <span class="comment">// 获取至多TIME_SIZE个抢红包信息</span></span><br><span class="line">                List&lt;String&gt; prList = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    prList  = ops.range(i * ONE_TIME_SIZE, </span><br><span class="line">    (i + <span class="number">1</span>) * ONE_TIME_SIZE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    prList = ops.range(i * ONE_TIME_SIZE + <span class="number">1</span>, </span><br><span class="line">    (i + <span class="number">1</span>) * ONE_TIME_SIZE);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (String prStr : prList) &#123;</span><br><span class="line">                    PurchaseRecordPo prp </span><br><span class="line">    = <span class="keyword">this</span>.createPurchaseRecord(productId, prStr);</span><br><span class="line">                    prpList.add(prp);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 采用该方法采用新建事务的方式，这样不会导致全局事务回滚</span></span><br><span class="line">                    purchaseService.dealRedisPurchase(prpList);</span><br><span class="line">                &#125; <span class="keyword">catch</span>(Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 清除列表为空，等待重新写入数据</span></span><br><span class="line">                prpList.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 删除购买列表</span></span><br><span class="line">            stringRedisTemplate.delete(purchaseKey);</span><br><span class="line">            <span class="comment">// 从商品集合中删除商品</span></span><br><span class="line">            stringRedisTemplate.opsForSet()</span><br><span class="line">    .remove(PRODUCT_SCHEDULE_SET, productIdStr);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"定时任务结束......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> PurchaseRecordPo <span class="title">createPurchaseRecord</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Long productId, String prStr)</span> </span>&#123;</span><br><span class="line">        String[] arr = prStr.split(<span class="string">","</span>);</span><br><span class="line">        Long userId = Long.parseLong(arr[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> quantity = Integer.parseInt(arr[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">double</span> sum = Double.valueOf(arr[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">double</span> price = Double.valueOf(arr[<span class="number">3</span>]);</span><br><span class="line">        Long time = Long.parseLong(arr[<span class="number">4</span>]);</span><br><span class="line">        Timestamp purchaseTime = <span class="keyword">new</span> Timestamp(time);</span><br><span class="line">        PurchaseRecordPo pr = <span class="keyword">new</span> PurchaseRecordPo();</span><br><span class="line">        pr.setProductId(productId);</span><br><span class="line">        pr.setPurchaseTime(purchaseTime);</span><br><span class="line">        pr.setPrice(price);</span><br><span class="line">        pr.setQuantity(quantity);</span><br><span class="line">        pr.setSum(sum);</span><br><span class="line">        pr.setUserId(userId);</span><br><span class="line">        pr.setNote(<span class="string">"购买日志，时间："</span> + purchaseTime.getTime());</span><br><span class="line">        <span class="keyword">return</span> pr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用@Scheduled定义时间：上一篇文章有写具体该怎么写。</p><p>它会从产品列表中读取产品编号，然后根据产品编号找到购买列表。在读出数据后，会转换为POJO对象，通过PurchaseService的createPurchaseRecord方法进行保存。</p><h5 id="修改控制层"><a href="#修改控制层" class="headerlink" title="修改控制层"></a>修改控制层</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/purchase"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">purchase</span><span class="params">(Long userId, Long productId, Integer quantity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> success = purchaseService.purchaseRedis(userId, productId, quantity);</span><br><span class="line">String message = success ? <span class="string">"抢购成功"</span> : <span class="string">"抢购失败"</span>;</span><br><span class="line">Result result = <span class="keyword">new</span> Result(success, message);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后注意记得删除mapper中的version判定。</p><h5 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h5><p>在Redis输入：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/15.png" alt=""></p><p>打开 <a href="http://localhost:8888/test" target="_blank" rel="noopener">http://localhost:8888/test</a> 测试：</p><p>查看Redis:</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/16.png" alt=""></p><p>发现多了这些键，这正是我们在业务层定义的键，查看键里包含的值：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/17.png" alt=""></p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/19.png" alt=""></p><p>发现Redis存储了这次数据库执行的结果，但是还没有写入数据库。在实际应用中，我们可以让Redis在一个夜深人静的夜晚，再缓慢的写回数据库。时间使用@Scheduled定义。</p><p>等时间到了，IDEA会出现这段文字：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/18.png" alt=""></p><p>再去查看数据库，发现成功写回了：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/designshop/13.png" alt=""></p><p>项目地址：<a href="https://github.com/Antarctica000/SpringBoot/tree/master/designshop">https://github.com/Antarctica000/SpringBoot/tree/master/designshop</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Redis </tag>
            
            <tag> 项目 </tag>
            
            <tag> MyBtis </tag>
            
            <tag> 定时任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot整合RabbitMQ</title>
      <link href="/2020/01/19/spring4/"/>
      <url>/2020/01/19/spring4/</url>
      
        <content type="html"><![CDATA[<h2 id="中间件技术：RabbitMQ"><a href="#中间件技术：RabbitMQ" class="headerlink" title="中间件技术：RabbitMQ"></a>中间件技术：RabbitMQ</h2><p>有了中间件，就相当于以后上学不用走路，而是骑单车。:call_me_hand:</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>中间件（英语：Middleware），又译中间件、中介层，是一类提供系统软件和应用软件之间连接、便于软件各部件之间的沟通的软件，应用软件可以借助中间件在不同的技术架构之间共享信息与资源。中间件位于客户机服务器的操作系统之上，管理着计算资源和网络通信。</p><p>就好似下图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/rabbitmq/r1.png" alt=""></p><p>而RabbitMQ则是一个中间件。</p><p>RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用Erlang语言编写的，而聚类和故障转移是构建在开放电信平台框架上的。所有主要的编程语言均有与代理接口通讯的客户端库。</p><p>简而言之，RabbitMQ是一套开源（MPL）的消息队列服务软件，我们使用这个消息队列，去传输信息。</p><h3 id="RabbitMQ的特性"><a href="#RabbitMQ的特性" class="headerlink" title="RabbitMQ的特性"></a>RabbitMQ的特性</h3><p>RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。具体特点包括：</p><ul><li>可靠性（Reliability）</li></ul><p>RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布确认。</p><ul><li>灵活的路由（Flexible Routing）</li></ul><p>在消息进入队列之前，通过 Exchange 来路由消息的。对于典型的路由功能，RabbitMQ 已经提供了一些内置的 Exchange 来实现。针对更复杂的路由功能，可以将多个 Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。</p><ul><li>消息集群（Clustering）</li></ul><p>多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。</p><ul><li>高可用（Highly Available Queues）</li></ul><p>队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。</p><ul><li>多种协议（Multi-protocol）</li></ul><p>RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等等。</p><ul><li>多语言客户端（Many Clients）</li></ul><p>RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、Ruby 等等。</p><ul><li>管理界面（Management UI）</li></ul><p>RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方面。</p><ul><li>跟踪机制（Tracing）</li></ul><p>如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。</p><ul><li>插件机制（Plugin System）</li></ul><p>RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。</p><h3 id="RabbitMQ的基本组成"><a href="#RabbitMQ的基本组成" class="headerlink" title="RabbitMQ的基本组成"></a>RabbitMQ的基本组成</h3><ul><li>Message</li></ul><p>消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。</p><ul><li>Publisher</li></ul><p>消息的生产者，也是一个向交换器发布消息的客户端应用程序。</p><ul><li>Exchange</li></ul><p>交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。</p><ul><li>Routing Key</li></ul><p>路由关键字,exchange根据这个关键字进行消息投递。</p><ul><li>Binding</li></ul><p>绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</p><ul><li>Queue</li></ul><p>消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</p><ul><li>Connection</li></ul><p>网络连接，比如一个TCP连接。</p><ul><li>Channel</li></ul><p>信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内地虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。</p><ul><li>Consumer</li></ul><p>消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。</p><ul><li>Virtual Host</li></ul><p>虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。</p><ul><li>Broker</li></ul><p>表示消息队列服务器实体。它提供一种传输服务,它的角色就是维护一条从生产者到消费者的路线，保证数据能按照指定的方式进行传输。</p><h3 id="SpringBoot整合RabbitMQ"><a href="#SpringBoot整合RabbitMQ" class="headerlink" title="SpringBoot整合RabbitMQ"></a>SpringBoot整合RabbitMQ</h3><p>RabbitMQ需要提前在电脑中安装，这里不多赘述，先发个网址给大家安装：</p><p><a href="https://blog.csdn.net/weixin_39735923/article/details/79288578" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39735923/article/details/79288578</a></p><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>看清楚，RabbitMQ的依赖叫做<strong>AMQP</strong>。</p><h4 id="yml配置"><a href="#yml配置" class="headerlink" title="yml配置"></a>yml配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: localhost</span><br><span class="line">    port: 5672</span><br><span class="line">    username: guest</span><br><span class="line">    password: guest</span><br></pre></td></tr></table></figure><p>因为我们不进行web的测试，这里仅仅只需要配置rabbitmq就行了。下面就正式开始测试，并且介绍一下RabbitMQ的三个模式。</p><h4 id="Direct-Exchange（直接交换）"><a href="#Direct-Exchange（直接交换）" class="headerlink" title="Direct Exchange（直接交换）"></a>Direct Exchange（直接交换）</h4><p>直接交换：- 直接交换是一种基于消息路由密钥将消息路由到队列的交换。路由密钥是生产者添加的消息头中的消息属性。生产者在消息头中添加路由密钥，并将其发送到直接交换。收到消息后，交换  尝试匹配的路由键  与所有绑定到队列的结合键  它。如果找到匹配项，它将消息路由到绑定键  已匹配的队列，如果未找到匹配项，它将忽略该消息。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/rabbitmq/r2.png" alt=""></p><p>下面进行测试：</p><h5 id="一对一发送"><a href="#一对一发送" class="headerlink" title="一对一发送"></a>一对一发送</h5><p><strong>config包</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意这里导入的队列是：</span></span><br><span class="line">    <span class="comment">//org.springframework.amqp.core.Queue;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>rabbitmq包</strong></p><p>发送者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String context = <span class="string">"hello----"</span>+<span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(<span class="string">"send:"</span>+context);</span><br><span class="line">        <span class="comment">//往名称为 hello 的queue中发送消息</span></span><br><span class="line">        <span class="keyword">this</span>.amqpTemplate.convertAndSend(<span class="string">"hello"</span>,context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues=<span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消息处理器</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Receiver:"</span>+message);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试类</strong></p><p>我们这次就直接使用IDEA下的测试类，开始对队列进行测试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">RabbitmqApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Sender Sender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Sender.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">send:hello----Sun Jan 19 19:12:00 CST 2020</span><br><span class="line">Receiver:hello----Sun Jan 19 19:12:00 CST 2020</span><br></pre></td></tr></table></figure><p>可以看到，这是一个单对单的发送。</p><h5 id="一对多发送"><a href="#一对多发送" class="headerlink" title="一对多发送"></a>一对多发送</h5><p>在Sender继续添加方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给hello2发送消息,并接受一个计数参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send2</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    String context = i+<span class="string">""</span>;</span><br><span class="line">    System.out.println(context+<span class="string">"--send:"</span>);</span><br><span class="line">    <span class="keyword">this</span>.amqpTemplate.convertAndSend(<span class="string">"hello2"</span>,context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在建立两个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"hello2"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Receiver1:"</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"hello2"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Receiver2:"</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始下一轮测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manyReceiver</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        Sender.send2(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0--send:</span><br><span class="line">1--send:</span><br><span class="line">2--send:</span><br><span class="line">3--send:</span><br><span class="line">4--send:</span><br><span class="line">5--send:</span><br><span class="line">6--send:</span><br><span class="line">7--send:</span><br><span class="line">8--send:</span><br><span class="line">9--send:</span><br><span class="line">Receiver1:0</span><br><span class="line">Receiver2:1</span><br><span class="line">Receiver1:2</span><br><span class="line">Receiver2:3</span><br><span class="line">Receiver2:5</span><br><span class="line">Receiver1:4</span><br><span class="line">Receiver2:7</span><br><span class="line">Receiver1:6</span><br><span class="line">Receiver2:9</span><br><span class="line">Receiver1:8</span><br></pre></td></tr></table></figure><p>可以从结果看到，我们发送了10个消息，这些消息有两个接收者。而这两个接收者均匀的接收了这10个消息。</p><h5 id="多对多发送"><a href="#多对多发送" class="headerlink" title="多对多发送"></a>多对多发送</h5><p>有了前面两个案例，我们再来试试多对多发送是如何的：</p><p>再建立一个新的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sender2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send2</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        String context = i+<span class="string">""</span>;</span><br><span class="line">        System.out.println(context+<span class="string">"--send:"</span>);</span><br><span class="line">        <span class="keyword">this</span>.amqpTemplate.convertAndSend(<span class="string">"hello2"</span>,context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得同时也需要注入AutoWired，再添加测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">many2many</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        Sender.send2(i);</span><br><span class="line">        Sender2.send2(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">0--send:</span><br><span class="line">0--send:</span><br><span class="line">1--send:</span><br><span class="line">1--send:</span><br><span class="line">2--send:</span><br><span class="line">2--send:</span><br><span class="line">3--send:</span><br><span class="line">3--send:</span><br><span class="line">4--send:</span><br><span class="line">4--send:</span><br><span class="line">5--send:</span><br><span class="line">5--send:</span><br><span class="line">6--send:</span><br><span class="line">6--send:</span><br><span class="line">7--send:</span><br><span class="line">7--send:</span><br><span class="line">8--send:</span><br><span class="line">8--send:</span><br><span class="line">9--send:</span><br><span class="line">9--send:</span><br><span class="line">Receiver2:0</span><br><span class="line">Receiver1:0</span><br><span class="line">Receiver2:1</span><br><span class="line">Receiver1:1</span><br><span class="line">Receiver2:2</span><br><span class="line">Receiver1:2</span><br><span class="line">Receiver2:3</span><br><span class="line">Receiver1:3</span><br><span class="line">Receiver2:4</span><br><span class="line">Receiver2:5</span><br><span class="line">Receiver1:4</span><br><span class="line">Receiver2:6</span><br><span class="line">Receiver1:5</span><br><span class="line">Receiver2:7</span><br><span class="line">Receiver1:6</span><br><span class="line">Receiver2:8</span><br><span class="line">Receiver1:7</span><br><span class="line">Receiver2:9</span><br><span class="line">Receiver1:8</span><br><span class="line">Receiver1:9</span><br></pre></td></tr></table></figure><p>可见他们均匀的收到了消息，且不重复。</p><h5 id="发送对象"><a href="#发送对象" class="headerlink" title="发送对象"></a>发送对象</h5><p>先构建一个实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建新的队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Queue <span class="title">queue3</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"object_queue"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>发送者和接收者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Send object:"</span>+user.toString());</span><br><span class="line">        <span class="keyword">this</span>.amqpTemplate.convertAndSend(<span class="string">"object_queue"</span>,user);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"object_queue"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">objectReceiver</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Receiver object:"</span>+user.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">object</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user=<span class="keyword">new</span> User();</span><br><span class="line">    user.setUsername(<span class="string">"张三"</span>);</span><br><span class="line">    user.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">    objectSender.sendUser(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Send object:User(username&#x3D;张三, password&#x3D;123456)</span><br><span class="line">Receiver object:User(username&#x3D;张三, password&#x3D;123456)</span><br></pre></td></tr></table></figure><h4 id="Topic-Exchange（主题交换）"><a href="#Topic-Exchange（主题交换）" class="headerlink" title="Topic Exchange（主题交换）"></a>Topic Exchange（主题交换）</h4><p>主题交换： 主题交换是基于队列绑定期间指定的路由键和路由模式之间的通配符匹配，将消息路由到队列的交换。 生产者在消息头中添加路由密钥，并将其发送到主题交换。收到消息后，交换  尝试将路由密钥与与其绑定的所有队列的绑定路由模式进行匹配。如果找到匹配项，它将把消息路由到路由模式匹配的队列，如果找不到匹配项，它将忽略该消息。</p><p>路由关键字：-这是单词列表，以句点（。）分隔，例如“ asia.china.beijing”</p><p>路由模式：- 这是在绑定队列期间指定的模式，它是单词和通配符的列表，例如“ * ”和“ ＃ ”，以句点（。）分隔。通配符的使用如下：</p><ul><li>“ * ”：-用于匹配路由键中特定位置的单词，例如路由模式“ asia.china。*”将与第一个单词为“ asia”且第二个单词为第二个的路由键匹配单词是“ china”，如“ asia.china.beijing”和“ asia.china.nanjing”。</li><li>“ ＃ ”：-用于匹配零个或多个单词，例如“ asia.china。＃”的路由模式将与以“ asia.china”开头的路由键（例如“ asia.china”和“ asia.china.beijing”。</li></ul><p>可以说：topic 是RabbitMQ中最灵活的一种方式，可以根据routing_key自由的绑定不同的队列。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/rabbitmq/r3.png" alt=""></p><p>先配置新的configuration：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicRabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> String message = <span class="string">"topic.message"</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> String messages = <span class="string">"topic.messages"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建两个 Queue</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(TopicRabbitConfig.message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueMessages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(TopicRabbitConfig.messages);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置 TopicExchange,指定名称为 topicExchange</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TopicExchange <span class="title">exchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(<span class="string">"topicExchange"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给队列绑定 exchange 和 routing_key</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingExchangeMessage</span><span class="params">(Queue queueMessage, TopicExchange exchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueMessage).to(exchange).with(<span class="string">"topic.message"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bingingExchangeMessages</span><span class="params">(Queue queueMessages, TopicExchange exchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueMessages).to(exchange).with(<span class="string">"topic.#"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>topic发送者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String context = <span class="string">"hi, i am message 1"</span>;</span><br><span class="line">        System.out.println(<span class="string">"Sender : "</span> + context);</span><br><span class="line">        amqpTemplate.convertAndSend(<span class="string">"topicExchange"</span>,<span class="string">"topic.message"</span>,context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String context = <span class="string">"hi, i am messages 2"</span>;</span><br><span class="line">        System.out.println(<span class="string">"Sender : "</span> + context);</span><br><span class="line">        amqpTemplate.convertAndSend(<span class="string">"topicExchange"</span>, <span class="string">"topic.messages"</span>, context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个接收者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"topic.messages"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicReceiver2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Receiver topic.messages: "</span>+ message);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"topic.message"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicReceiver1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Receiver topic.message :"</span>+ message);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    topicSender.send1();</span><br><span class="line">    topicSender.send2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sender : hi, i am message 1</span><br><span class="line">Sender : hi, i am messages 2</span><br><span class="line">Receiver topic.message :hi, i am message 1</span><br><span class="line">Receiver topic.messages: hi, i am message 1</span><br><span class="line">Receiver topic.messages: hi, i am messages 2</span><br></pre></td></tr></table></figure><p>可以看到，绑定的队列头不一样的队列，收到的信息也是不一样的，但是这是一个包含关系。</p><p>发送send1会匹配到topic.#和topic.message 两个Receiver都可以收到消息，发送send2只有topic.#可以匹配的只有Receiver2，Receiver2收到了第二条监听到消息</p><h4 id="Fanout-Exchange（扇出交换）"><a href="#Fanout-Exchange（扇出交换）" class="headerlink" title="Fanout Exchange（扇出交换）"></a>Fanout Exchange（扇出交换）</h4><p>扇出交换：扇出交换是一种将接收到的消息路由到与其绑定的所有队列的交换。 当生产者将消息发送到扇出交换时，它将复制消息并将其路由到与其绑定的所有队列。它只是忽略路由键或生产者提供的任何模式匹配。当需要将同一消息存储在一个或多个队列中时，这种类型的交换非常有用。</p><p>简而言之，Fanout 就是我们熟悉的广播模式或者订阅模式，给Fanout交换机发送消息，绑定了这个交换机的所有队列都收到这个消息。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/rabbitmq/r4.png" alt=""></p><p>配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanOutRabbitMq</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建三个队列</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">AMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"fanout.1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">BMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"fanout.2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">CMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"fanout.3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建exchange,指定交换策略</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">fanoutExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(<span class="string">"fanoutExchange"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//分别给三个队列指定exchange,这里使用了1、2、3三个队列绑定到Fanout交换机上面，发送端的routing_key写任何字符都会被忽略：</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingExchangeA</span><span class="params">(Queue AMessage, FanoutExchange fanoutExchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(AMessage).to(fanoutExchange);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingExchangeB</span><span class="params">(Queue BMessage,FanoutExchange fanoutExchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(BMessage).to(fanoutExchange);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">bindingExchangeC</span><span class="params">(Queue CMessage, FanoutExchange fanoutExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(CMessage).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个广播：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutSender</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        String context = <span class="string">"hi, fanout msg "</span>;</span><br><span class="line">        System.out.println(<span class="string">"Sender : "</span> + context);</span><br><span class="line">        <span class="comment">//这里使用了1、2、3三个队列绑定到Fanout交换机上面，发送端的routing_key写任何字符都会被忽略：</span></span><br><span class="line">        amqpTemplate.convertAndSend(<span class="string">"fanoutExchange"</span>,<span class="string">""</span>, context);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个接收者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"fanout.1"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutReceiver1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Receiver form fanout.A: "</span>+message);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"fanout.2"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutReceiver2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Receiver form fanout_2: "</span>+message);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"fanout.3"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutReceiver3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Receiver form fanout_3: "</span>+message);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fanout</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fanoutSender.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sender : hi, fanout msg </span><br><span class="line">Receiver form fanout_3: hi, fanout msg </span><br><span class="line">Receiver form fanout_1: hi, fanout msg </span><br><span class="line">Receiver form fanout_2: hi, fanout msg</span><br></pre></td></tr></table></figure><p>放个更形象的比喻：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/rabbitmq/r5.png" alt=""></p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>本来是想单开一篇，但实在是觉得太简单，所以也连着一块说了吧。</p><p>异步这个词之前在学习多线程的时候有遇见过，但是可能很多人不太理解该如何结合到Spring当中运用，这次就来粗略的展示一下：</p><p>首先需要一个服务层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span><span class="comment">//告诉spring这是一个异步的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"数据处理中----"</span>+<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要在方法上面标明这是一个异步方法，这样后台就会为这个方法单开一个线程执行。</p><p>最后别忘了在启动器加上注解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@EnableAsync&#x2F;&#x2F;开启异步注解功能</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数据处理中----Sun Jan 19 22:30:13 CST 2020</span><br><span class="line">数据处理中----Sun Jan 19 22:30:14 CST 2020</span><br><span class="line">数据处理中----Sun Jan 19 22:30:15 CST 2020</span><br><span class="line">数据处理中----Sun Jan 19 22:30:15 CST 2020</span><br><span class="line">数据处理中----Sun Jan 19 22:30:16 CST 2020</span><br></pre></td></tr></table></figure><p>可以从时间上看到，时间之差似乎只有1秒，仿佛没有把3秒的线程睡眠给编译进去。但是你可以把这个注解取消，就会发现它每个动作都得延迟3秒进行，这就是异步控制。</p><h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><p>在实际运用中，有时候需要定一个时间去发消息，比如各个月末的报表，某些定时推送的新闻，年终的奖金等等，就需要一个定时器去完成。这个在Spring当中，当然也有内置的方法，由于比较简单，所以也一块说了。</p><p>这个定时器也需要在启动器中加入：@EnableScheduling   进行开启。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * second(秒), minute（分）, hour（时）, day of month（日）, month（月）, day of week（周几）.</span></span><br><span class="line"><span class="comment">     * 0 * * * * MON-FRI</span></span><br><span class="line"><span class="comment">     *  【0 0/5 14,18 * * ?】 每天14点整，和18点整，每隔5分钟执行一次</span></span><br><span class="line"><span class="comment">     *  【0 15 10 ? * 1-6】 每个月的周一至周六10:15分执行一次</span></span><br><span class="line"><span class="comment">     *  【0 0 2 ? * 6L】每个月的最后一个周六凌晨2点执行一次</span></span><br><span class="line"><span class="comment">     *  【0 0 2 LW * ?】每个月的最后一个工作日凌晨2点执行一次</span></span><br><span class="line"><span class="comment">     *  【0 0 2-4 ? * 1#1】每个月的第一个周一凌晨2点到4点期间，每个整点都执行一次；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"0/1 * * * * ?"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"scheduled----------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就代表了，每一秒都发一条信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scheduled----------</span><br><span class="line">scheduled----------</span><br><span class="line">scheduled----------</span><br></pre></td></tr></table></figure><p>项目地址：<a href="https://github.com/Antarctica000/SpringBoot/tree/master/rabbitmq">https://github.com/Antarctica000/SpringBoot/tree/master/rabbitmq</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 定时任务 </tag>
            
            <tag> 中间件 </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> 异步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>REST风格</title>
      <link href="/2020/01/18/spring3/"/>
      <url>/2020/01/18/spring3/</url>
      
        <content type="html"><![CDATA[<h2 id="REST风格"><a href="#REST风格" class="headerlink" title="REST风格"></a>REST风格</h2><h3 id="初识REST"><a href="#初识REST" class="headerlink" title="初识REST"></a>初识REST</h3><p>Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p><p>比如说，我们以前在进行开发的时候，通常一个请求是：<a href="http://localhost:8888/user/getUser?id=1" target="_blank" rel="noopener">http://localhost:8888/user/getUser?id=1</a></p><p>在这个请求中，getUser是方法名，一个动词，我们要根据这个动词去进行相应的操作，换句话说，这个为名id的用户，它的资料存在这个一个getUser方法中。从现实中来看，这是不科学的，一个用户怎么会存在一个动词当中，一个用户应该使用： <a href="http://localhost:8888/user/1" target="_blank" rel="noopener">http://localhost:8888/user/1</a> 来表达才比较对，user代表了这个群体是一个用户，1表示了这个用户的id。</p><p>基于这种思想，就诞生了一个名为：REST的风格。这种规范自2000年以来，开始流传于世间。</p><h3 id="构建REST风格网站"><a href="#构建REST风格网站" class="headerlink" title="构建REST风格网站"></a>构建REST风格网站</h3><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><p>在构建过程中，除了前面必要的依赖，如mysql、mybatis之外，还需要引入一个人依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有了这个依赖，才能实现对页面的处理，首先看一个例子：</p><h4 id="页面之间的跳转"><a href="#页面之间的跳转" class="headerlink" title="页面之间的跳转"></a>页面之间的跳转</h4><p>我们在controller中先写入这一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一段代码表示，接收一个index请求，并且会返回一个为名index的字符串。看起来是这样的，但实际上，它在引入了thymeleaf依赖之后，会自动在String后面拼串，返回的是一个名为 index.html的页面。</p><p>同时，也需要在 resource的templates包中，放入index的页面，它就能够识别，且自动跳转。</p><p>同时，你还要学习关于计算机网络和HTTP相关的知识，至少要知道一下几点：</p><p><strong>POST:一般是用于提交数据的</strong></p><p><strong>GET:一般是用于获取数据的</strong></p><p><strong>PUT:一般是用于更新一条数据的</strong></p><p><strong>DELETE:一般是用于删除数据的</strong></p><p><strong>PATCH:一般是用于更新一批数据的</strong></p><h4 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h4><p>为了使得出入的数据都能被完全的转移至数据库，通常需要以下几个实体类：</p><p>用于传入数据库的user：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Alias</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> SexEnum sex = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String note;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端传进来的user：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserVo</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"><span class="keyword">private</span> String userName;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> sexCode;</span><br><span class="line"><span class="keyword">private</span> String sexName;</span><br><span class="line"><span class="keyword">private</span> String note;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在controller层中，需要添加的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换Vo变为PO</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> User <span class="title">changeToPo</span><span class="params">(UserVo userVo)</span> </span>&#123;</span><br><span class="line">     User user = <span class="keyword">new</span> User();</span><br><span class="line">     user.setId(userVo.getId());</span><br><span class="line">     user.setUserName(userVo.getUserName());</span><br><span class="line">     user.setSex(SexEnum.getSexEnum(userVo.getSexCode()));</span><br><span class="line">     user.setNote(userVo.getNote());</span><br><span class="line">     <span class="keyword">return</span> user;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 转换PO变为VO</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> UserVo <span class="title">changeToVo</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">     UserVo userVo = <span class="keyword">new</span> UserVo();</span><br><span class="line">     userVo.setId(user.getId());</span><br><span class="line">     userVo.setUserName(user.getUserName());</span><br><span class="line">     userVo.setSexCode(user.getSex().getCode());</span><br><span class="line">     userVo.setSexName(user.getSex().getName());</span><br><span class="line">     userVo.setNote(user.getNote());</span><br><span class="line">     <span class="keyword">return</span> userVo;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 将PO列表转换为VO列表</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> List&lt;UserVo&gt; <span class="title">changeToVoes</span><span class="params">(List&lt;User&gt; poList)</span> </span>&#123;</span><br><span class="line">     List&lt;UserVo&gt; voList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     <span class="keyword">for</span> (User user : poList) &#123;</span><br><span class="line">         UserVo userVo = changeToVo(user);</span><br><span class="line">         voList.add(userVo);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> voList;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 结果VO</span></span><br><span class="line"> <span class="meta">@Data</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultVo</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">ResultVo</span><span class="params">(Boolean success, String message)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.success = success;</span><br><span class="line">         <span class="keyword">this</span>.message = message;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> Boolean success = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">private</span> String message = <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8888</span><br><span class="line"></span><br><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:&#x2F;mapper&#x2F;*Mapper.xml</span><br><span class="line">  type-aliases-package: com.example.rest.pojo</span><br><span class="line">  type-handlers-package: com.example.rest.typeHandler</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br><span class="line">    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;springtest?useSSL&#x3D;false&amp;serverTimezone&#x3D;GMT%2B8&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    tomcat:</span><br><span class="line">      max-idle: 10</span><br><span class="line">      max-wait: 10000</span><br><span class="line">      max-active: 50</span><br><span class="line">      initial-size: 5</span><br></pre></td></tr></table></figure><h4 id="MyBatis的xml配置"><a href="#MyBatis的xml配置" class="headerlink" title="MyBatis的xml配置"></a>MyBatis的xml配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.example.rest.dao.UserDao"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUser"</span> <span class="attr">parameterType</span>=<span class="string">"long"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">select * from t_user</span><br><span class="line">where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertUser"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">parameterType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">insert into t_user(user_name, note)</span><br><span class="line">values(#&#123;userName&#125;, #&#123;note&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateUser"</span>&gt;</span></span><br><span class="line">        update t_user</span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userName != null"</span>&gt;</span>user_name =#&#123;userName&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"note != null"</span>&gt;</span>note =#&#123;note&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUsers"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">        select id, user_name as userName, note from t_user</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userName != null"</span>&gt;</span></span><br><span class="line">                and user_name = #&#123;userName&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"note != null"</span>&gt;</span></span><br><span class="line">                and note = #&#123;note&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteUser"</span> <span class="attr">parameterType</span>=<span class="string">"long"</span>&gt;</span></span><br><span class="line">delete from t_user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>为了不多赘述，以下省略mybatis、mysql、typeHandler和enum的配置。</strong></p><h4 id="controller层"><a href="#controller层" class="headerlink" title="controller层"></a>controller层</h4><h5 id="添加json数据至数据库"><a href="#添加json数据至数据库" class="headerlink" title="添加json数据至数据库"></a>添加json数据至数据库</h5><p>先贴controller层的设计：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户服务接口</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">insertUser</span><span class="params">(@RequestBody UserVo userVo)</span></span>&#123;</span><br><span class="line">        User user=<span class="keyword">this</span>.changeToPo(userVo);</span><br><span class="line">        <span class="keyword">return</span> userService.insertUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用的是PostMaping，表示我们所接受到的是Post请求，这里在UserVO使用@RequestBody，目的是表示这里接受的必须是json型数据，也之后json型数据才会被绑定到UserVo当中。</p><p>然后在使用转换，在传入数据库当中，这里打开PostMan开始测试：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/rest/1.png" alt=""></p><p>传入的是json型数据，可以发现，这里在URL并没有使用任何的动词，而是直接传入json数据到后端。</p><p>看看数据库：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/rest/2.png" alt=""></p><p>这显然成功了。</p><h5 id="获得数据库信息"><a href="#获得数据库信息" class="headerlink" title="获得数据库信息"></a>获得数据库信息</h5><p>我们继续在controller中添加数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取用户</span></span><br><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserVo <span class="title">getUser</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id) </span>&#123;</span><br><span class="line">    User user = userService.getUser(id);</span><br><span class="line">    <span class="keyword">return</span> changeToVo(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们看到，使用的是@PathVariable，这是什么意思呢？这表示我们的id字段将会从url中获取，于是id变获得了，{id}，可能你会提问，我使用：？id=1，不是也可以吗？当然可以，但是当你传入多个参数的时候，就会变的很麻烦，别着急，往下看。</p><p>在看看是否从数据库获取成功：</p><p>输入： <a href="http://localhost:8888/user/1" target="_blank" rel="noopener">http://localhost:8888/user/1</a></p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/rest/3.png" alt=""></p><p>我们发现，这次没使用所谓的getUser，也获得了数据。但是你看，这里userName居然是空的？</p><p>我回去看看数据库，原来数据库设置用户名是user_name，而我们设计的类是userName，这不一样，但是没关系，我们可以在yml配置文件中的mybatis配置中加一句：configuration:  map-underscore-to-camel-case: true</p><p>这样它就会开启驼峰命名法，会自动将大写转化为 _ 加 小写 ，这样在映射数据库中，就成功把userName转化为user_name了。</p><h5 id="查询符合要求的用户"><a href="#查询符合要求的用户" class="headerlink" title="查询符合要求的用户"></a>查询符合要求的用户</h5><p>在查询符合要求的用户时，为了节省查询量，肯定需要传入多个关键词，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/users/&#123;userName&#125;/&#123;note&#125;/&#123;start&#125;/&#123;limit&#125;"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserVo&gt; <span class="title">findUsers</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @PathVariable(<span class="string">"userName"</span>)</span> String userName,</span></span><br><span class="line"><span class="function">        @<span class="title">PathVariable</span><span class="params">(<span class="string">"note"</span>)</span> String note,</span></span><br><span class="line"><span class="function">        @<span class="title">PathVariable</span><span class="params">(<span class="string">"start"</span>)</span> <span class="keyword">int</span> start,</span></span><br><span class="line"><span class="function">        @<span class="title">PathVariable</span><span class="params">(<span class="string">"limit"</span>)</span> <span class="keyword">int</span> limit) </span>&#123;</span><br><span class="line">    List&lt;User&gt; userList = userService.findUsers(userName, note, start, limit);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.changeToVoes(userList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到的是，我们传入了多个关键词就只用/分割开就行了，不需要传入id=1&amp;username=“xxx”,这么麻烦了，这就是 @PathVariable的作用。</p><h5 id="修改用户数据"><a href="#修改用户数据" class="headerlink" title="修改用户数据"></a>修改用户数据</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@PutMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">updateUser</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id, @RequestBody UserVo userVo) </span>&#123;</span><br><span class="line">    User user = <span class="keyword">this</span>.changeToPo(userVo);</span><br><span class="line">    user.setId(id);</span><br><span class="line">    userService.updateUser(user);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里将两个注解结合到了一起，使用在这个url中，修改所需要的修改的用户：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/rest/4.png" alt=""></p><p>看，这样就好了，即在url中选择了用户id，又在json中传达了需要的数据，并且又避免了动词的存在，一举三得。再看看数据库：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/rest/5.png" alt=""></p><h5 id="其他测试"><a href="#其他测试" class="headerlink" title="其他测试"></a>其他测试</h5><p>其他数据测试也是几乎一样的，这里仅提供代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@PatchMapping</span>(<span class="string">"/user/&#123;id&#125;/&#123;userName&#125;"</span>)</span><br><span class="line">   <span class="meta">@ResponseBody</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ResultVo <span class="title">changeUserName</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id,</span></span><br><span class="line"><span class="function">                                  @<span class="title">PathVariable</span><span class="params">(<span class="string">"userName"</span>)</span> String userName) </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> result = userService.updateUserName(id, userName);</span><br><span class="line">       ResultVo resultVo = <span class="keyword">new</span> ResultVo(result&gt;<span class="number">0</span>,result &gt; <span class="number">0</span> ? <span class="string">"更新成功"</span> : <span class="string">"更新用户【"</span> + id + <span class="string">"】失败。"</span>);</span><br><span class="line">       <span class="keyword">return</span> resultVo;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@DeleteMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultVo <span class="title">deleteUser</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id) </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = userService.deleteUser(id);</span><br><span class="line">    ResultVo resultVo = <span class="keyword">new</span> ResultVo(result&gt;<span class="number">0</span>, </span><br><span class="line">        result &gt; <span class="number">0</span> ? <span class="string">"更新成功"</span> : <span class="string">"更新用户【"</span> + id + <span class="string">"】失败。"</span>);</span><br><span class="line">    <span class="keyword">return</span> resultVo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PatchMapping</span>(<span class="string">"/user/name"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultVo <span class="title">changeUserName2</span><span class="params">(Long id, String userName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = userService.updateUserName(id, userName);</span><br><span class="line">    ResultVo resultVo = <span class="keyword">new</span> ResultVo(result&gt;<span class="number">0</span>, </span><br><span class="line">        result &gt; <span class="number">0</span> ? <span class="string">"更新成功"</span> : <span class="string">"更新用户名【"</span> + id + <span class="string">"】失败。"</span>);</span><br><span class="line">    <span class="keyword">return</span> resultVo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码补充"><a href="#代码补充" class="headerlink" title="代码补充"></a>代码补充</h4><p>性别的枚举：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SexEnum &#123;<span class="comment">/**/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">MALE(0, "男"),</span></span><br><span class="line"><span class="comment">FEMALE(1, "女");</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">private int code;</span></span><br><span class="line"><span class="comment">private String name;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">SexEnum(int code, String name) &#123;</span></span><br><span class="line"><span class="comment">this.code = code;</span></span><br><span class="line"><span class="comment">this.name = name;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public static SexEnum getSexEnum(int code) &#123;</span></span><br><span class="line"><span class="comment">for (SexEnum sex : SexEnum.values()) &#123;</span></span><br><span class="line"><span class="comment">if (sex.getCode() == code) &#123;</span></span><br><span class="line"><span class="comment">return sex;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">return null;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public int getCode() &#123;</span></span><br><span class="line"><span class="comment">return code;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public void setCode(int code) &#123;</span></span><br><span class="line"><span class="comment">this.code = code;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public String getName() &#123;</span></span><br><span class="line"><span class="comment">return name;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public void setName(String name) &#123;</span></span><br><span class="line"><span class="comment">this.name = name;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><p>其实并不长，之所以看起来长，是因为枚举类型不能使用@Data。</p><p>SexTypeHandler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MappedTypes</span>(SexEnum<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">MappedJdbcTypes</span>(<span class="title">JdbcType</span>.<span class="title">INTEGER</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SexTypeHandler</span> <span class="keyword">extends</span> <span class="title">BaseTypeHandler</span>&lt;<span class="title">SexEnum</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SexEnum <span class="title">getNullableResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="keyword">int</span> code = rs.getInt(columnName);</span><br><span class="line"><span class="keyword">return</span> SexEnum.getSexEnum(code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SexEnum <span class="title">getNullableResult</span><span class="params">(ResultSet rs, <span class="keyword">int</span> index)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="keyword">int</span> code = rs.getInt(index);</span><br><span class="line"><span class="keyword">return</span> SexEnum.getSexEnum(code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SexEnum <span class="title">getNullableResult</span><span class="params">(CallableStatement cs, <span class="keyword">int</span> index)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="keyword">int</span> code = cs.getInt(index);</span><br><span class="line"><span class="keyword">return</span> SexEnum.getSexEnum(code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> index, SexEnum sex, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">ps.setInt(index, sex.getCode());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="学点前端"><a href="#学点前端" class="headerlink" title="学点前端"></a>学点前端</h3><p>闭门造车，不是明智之选，看点前端知识：</p><p>为了在前端也能够识别且使用thymleaf语法，需要在页面顶部添加：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了能使用JQuery库，需要添加：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"https://code.jquery.com/jquery-3.2.1.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JavaScript和JQuery的区别就像，C++和STL类库的区别，int和Integer的区别，面粉和蛋糕的区别。</p><p>学一下JS：</p><p>在前面的使用post请求时，也可以在页面这么使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">     <span class="function"><span class="keyword">function</span> <span class="title">post</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript"> <span class="keyword">var</span> params = &#123;</span></span><br><span class="line"><span class="actionscript"> <span class="string">'userName'</span>: <span class="string">'user_name_new'</span>, </span></span><br><span class="line"><span class="actionscript"> <span class="string">'sexCode'</span> : <span class="number">1</span>,</span></span><br><span class="line"><span class="actionscript"> <span class="string">'note'</span> : <span class="string">"note_new"</span></span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="javascript"> $.post(&#123;</span></span><br><span class="line"><span class="actionscript"> url : <span class="string">"./user"</span>,</span></span><br><span class="line"><span class="actionscript"> <span class="comment">// 此处需要告知传递参数类型为JSON，不能缺少</span></span></span><br><span class="line"><span class="actionscript"> contentType : <span class="string">"application/json"</span>,</span></span><br><span class="line"><span class="actionscript"> <span class="comment">// 将JSON转化为字符串传递</span></span></span><br><span class="line"><span class="javascript"> data : <span class="built_in">JSON</span>.stringify(params),</span></span><br><span class="line"><span class="actionscript"> <span class="comment">// 成功后的方法</span></span></span><br><span class="line"><span class="actionscript"> success : <span class="function"><span class="keyword">function</span><span class="params">(result)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript"> <span class="keyword">if</span> (result == <span class="literal">null</span> || result.id == <span class="literal">null</span>) &#123;</span></span><br><span class="line"><span class="actionscript"> alert(<span class="string">"插入失败"</span>);</span></span><br><span class="line"><span class="actionscript"> <span class="keyword">return</span>;</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="actionscript"> alert(<span class="string">"插入成功"</span>);</span></span><br><span class="line"> &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"> post();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样便可以在前端执行JS代码。运行这个页面的时候，会触发post函数，post函数开头便定义了一个值，这个值是json类型，并且会执行$.post方法，它可以这么写是因为JQ的原因，从传达的url中获取要接收的json参数，成功则执行函数，并返回成功的消息框，否则会在页面返回插入失败的消息框。OK。</p><p>项目地址：<a href="https://github.com/Antarctica000/SpringBoot/tree/master/rest">https://github.com/Antarctica000/SpringBoot/tree/master/rest</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot整合Redis缓存</title>
      <link href="/2020/01/16/spirng2/"/>
      <url>/2020/01/16/spirng2/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot整合Redis缓存"><a href="#SpringBoot整合Redis缓存" class="headerlink" title="SpringBoot整合Redis缓存"></a>SpringBoot整合Redis缓存</h2><p>如果我们每次需要数据都要从数据库访问数据的话，会给数据库带来极大的压力，这时候，就需要一个地点暂时居住起来，这样就不会因为大量的IO导致效率低下。:happy:</p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。</p><p>Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p>它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p><p>简而言之就是一个高速的缓存器，我使用这个缓存器使在数据库中传入的数据，放入到一个缓存库中。这样，就不用每次需要数据，都连接一次数据库了。</p><h4 id="加入依赖"><a href="#加入依赖" class="headerlink" title="加入依赖"></a>加入依赖</h4><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis-reactive<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>redis默认使用lettuce去连接，使用exclusions去排除，再加入jedis连接。当然，只加redis依赖也可以，只不过jedis比较受欢迎而已。</p><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8888</span><br><span class="line"></span><br><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:&#x2F;mapper&#x2F;*Mapper.xml</span><br><span class="line">  type-aliases-package: com.example.redis.pojo</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br><span class="line">    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;springtest?useSSL&#x3D;false&amp;serverTimezone&#x3D;GMT%2B8&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    tomcat:</span><br><span class="line">      max-idle: 10</span><br><span class="line">      max-wait: 10000</span><br><span class="line">      max-active: 50</span><br><span class="line">      initial-size: 5</span><br><span class="line"></span><br><span class="line">  cache:</span><br><span class="line">    type: redis</span><br><span class="line">  redis:</span><br><span class="line">    database: 0</span><br><span class="line">    host: localhost</span><br><span class="line">    port: 6379</span><br><span class="line">      # 有密码填密码，没有密码不填</span><br><span class="line">    password:</span><br><span class="line">      # 连接超时时间（ms)</span><br><span class="line">    timeout: 1000ms</span><br><span class="line">      # 高版本springboot中使用jedis或者lettuce</span><br><span class="line">    jedis:</span><br><span class="line">      pool:</span><br><span class="line">          # 连接池最大连接数（负值表示无限制）</span><br><span class="line">        max-active: 8</span><br><span class="line">          # 连接池最大阻塞等待时间（负值无限制)</span><br><span class="line">        max-wait: 5000ms</span><br><span class="line">          # 最大空闲链接数</span><br><span class="line">        max-idle: 8</span><br><span class="line">          # 最小空闲链接数</span><br><span class="line">        min-idle: 0</span><br></pre></td></tr></table></figure><h4 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Alias</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7760614561073458247L</span>;</span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"><span class="keyword">private</span> String userName;</span><br><span class="line"><span class="keyword">private</span> String note;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Dao层"><a href="#Dao层" class="headerlink" title="Dao层"></a>Dao层</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">User <span class="title">getUser</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findUsers</span><span class="params">(@Param(<span class="string">"userName"</span>)</span> String userName,@<span class="title">Param</span><span class="params">(<span class="string">"note"</span>)</span> String note)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XML:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.example.redis.dao.UserDao"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUser"</span> <span class="attr">parameterType</span>=<span class="string">"long"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">select id, user_name as userName, note from t_user</span><br><span class="line">where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertUser"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">parameterType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">insert into t_user(user_name, note)</span><br><span class="line">values(#&#123;userName&#125;, #&#123;note&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateUser"</span>&gt;</span></span><br><span class="line">        update t_user</span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userName != null"</span>&gt;</span>user_name =#&#123;userName&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"note != null"</span>&gt;</span>note =#&#123;note&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUsers"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">        select id, user_name as userName, note from t_user</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userName != null"</span>&gt;</span></span><br><span class="line">                and user_name = #&#123;userName&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"note != null"</span>&gt;</span></span><br><span class="line">                and note = #&#123;note&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteUser"</span> <span class="attr">parameterType</span>=<span class="string">"long"</span>&gt;</span></span><br><span class="line">delete from t_user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>熟练的定义一个接口，同时也记得要在启动器中加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@EnableCaching</span><br><span class="line">@MapperScan(&quot;com.example.redis.dao&quot;)</span><br></pre></td></tr></table></figure><p>@EnableCaching 记得一定要加，表示开启缓存。</p><h4 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取单个用户</span></span><br><span class="line">    <span class="function">User <span class="title">getUser</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存用户</span></span><br><span class="line">    <span class="function">User <span class="title">insertUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改用户，指定MyBatis的参数名称</span></span><br><span class="line">    <span class="function">User <span class="title">updateUserName</span><span class="params">(Long id, String userName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询用户，指定MyBatis的参数名称</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findUsers</span><span class="params">(String userName, String note)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除用户</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入用户，最后MyBatis会回填id，取结果id缓存用户</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@CachePut</span>(value = <span class="string">"redisCache"</span>, key = <span class="string">"'redis_user_'+#result.id"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">insertUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        userDao.insertUser(user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取id，取参数id缓存用户</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Cacheable</span>(value = <span class="string">"redisCache"</span>, key = <span class="string">"'redis_user_'+#id"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"service"</span>);</span><br><span class="line">        <span class="keyword">return</span> userDao.getUser(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新数据后，充值缓存，使用condition配置项使得结果返回为null，不缓存</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@CachePut</span>(value = <span class="string">"redisCache"</span>, condition = <span class="string">"#result != 'null'"</span>, key = <span class="string">"'redis_user_'+#id"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">updateUserName</span><span class="params">(Long id, String userName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此处调用getUser方法，该方法缓存注解失效，</span></span><br><span class="line">        <span class="comment">// 所以这里还会执行SQL，将查询到数据库最新数据</span></span><br><span class="line">        User user = <span class="keyword">this</span>.getUser(id);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        user.setUserName(userName);</span><br><span class="line">        userDao.updateUser(user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 命中率低，所以不采用缓存机制</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUsers</span><span class="params">(String userName, String note)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.findUsers(userName, note);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除缓存</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@CacheEvict</span>(value = <span class="string">"redisCache"</span>, key = <span class="string">"'redis_user_'+#id"</span>, beforeInvocation = <span class="keyword">false</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.deleteUser(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Transactional表示是一个关于数据库的事务，能够控制数据库隔离级别和事务类型，这里先不详谈。</p><p>@CachePut表示将方法的结果放入缓存，比如你插入了一条数据后，就会返回一个布尔值，表示成功或是失败，如果成功，则放这条数据放入redis中。</p><p>value表示缓存库的名字是什么，要放入到哪个缓存区域去，key表示缓存的值，类似hashmap的形式，# 表示传入的参数。</p><p>@Cacheable能从缓存中通过定义的键进行查询，如果查询到数据，则返回，否则执行该方法，返回数据，并且将返回结果保持到缓存中，是使用最多的方法。</p><p>@CacheEvic 言简意赅，移除缓存。</p><h4 id="Controller层"><a href="#Controller层" class="headerlink" title="Controller层"></a>Controller层</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/getUser"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"controller"</span>);</span><br><span class="line">        <span class="keyword">return</span> userService.getUser(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/insertUser"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">insertUser</span><span class="params">(String userName, String note)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUserName(userName);</span><br><span class="line">        user.setNote(note);</span><br><span class="line">        userService.insertUser(user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/findUsers"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUsers</span><span class="params">(String userName, String note)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.findUsers(userName, note);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/updateUserName"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">updateUserName</span><span class="params">(Long id, String userName)</span> </span>&#123;</span><br><span class="line">        User user = userService.updateUserName(id, userName);</span><br><span class="line">        <span class="keyword">boolean</span> flag = user != <span class="keyword">null</span>;</span><br><span class="line">        String message = flag? <span class="string">"更新成功"</span> : <span class="string">"更新失败"</span>;</span><br><span class="line">        <span class="keyword">return</span> resultMap(flag, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/deleteUser"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">deleteUser</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = userService.deleteUser(id);</span><br><span class="line">        <span class="keyword">boolean</span> flag = result == <span class="number">1</span>;</span><br><span class="line">        String message = flag? <span class="string">"删除成功"</span> : <span class="string">"删除失败"</span>;</span><br><span class="line">        <span class="keyword">return</span> resultMap(flag, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title">resultMap</span><span class="params">(<span class="keyword">boolean</span> success, String message)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; result = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        result.put(<span class="string">"success"</span>, success);</span><br><span class="line">        result.put(<span class="string">"message"</span>, message);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，来测试一下吧。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>输入地址：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/1.png" alt=""></p><p>回去查看idea：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/2.png" alt=""></p><p>我们可以看到的是，在Controller层进行了访问，然后在Service层进行了访问，这表示是第一次读取这个值，需要访问数据库，并且在放入缓存中。</p><p>那么再多访问几次看看吧。</p><p>连续的页面刷新后，再去idea</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/3.png" alt=""></p><p>我们发现，这只执行到Controller层，而不进行Service层，这表示了我们读取到的是缓存，而不是数据库，因为只执行Controller层便结束了。</p><h3 id="Redis拓展"><a href="#Redis拓展" class="headerlink" title="Redis拓展"></a>Redis拓展</h3><p>我们放入Redis的缓存，在不设置之前，是永久存在的。，如果缓存只会被放入，而不设置过期时间的话，就算有办法取消掉一些缓存，但随着时间的推移，总会有些缓存会被遗忘，一直作为内存的存在Redis当中。这时，就需要深入的配置Redis，让其能够主动的销毁。</p><h4 id="设置缓存过期时间"><a href="#设置缓存过期时间" class="headerlink" title="设置缓存过期时间"></a>设置缓存过期时间</h4><p>加入configuration：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisConnectionFactory redisConnectionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义Redis缓存管理器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisCacheManager <span class="title">redisCacheManager</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//Redis加锁的写入器</span></span><br><span class="line">        RedisCacheWriter writer=RedisCacheWriter.lockingRedisCacheWriter(redisConnectionFactory);</span><br><span class="line">        <span class="comment">//这里注入了Redis连接工厂</span></span><br><span class="line">        <span class="comment">//启动Redis缓存默认设置</span></span><br><span class="line">        RedisCacheConfiguration config=RedisCacheConfiguration.defaultCacheConfig();</span><br><span class="line">        <span class="comment">//设置JDK序列化器</span></span><br><span class="line">        <span class="comment">//设置10秒超时</span></span><br><span class="line">        config = config.serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> JdkSerializationRedisSerializer()));</span><br><span class="line">        <span class="comment">//禁用前缀</span></span><br><span class="line">        config=config.disableKeyPrefix();</span><br><span class="line">        <span class="comment">//设置10秒超时</span></span><br><span class="line">        config=config.entryTtl(Duration.ofSeconds(<span class="number">10</span>));</span><br><span class="line">        <span class="comment">//创建缓存管理器</span></span><br><span class="line">        RedisCacheManager redisCacheManager=<span class="keyword">new</span> RedisCacheManager( writer,config);</span><br><span class="line">        <span class="keyword">return</span> redisCacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>configuration会全局识别为SpringBoot的配置文件，使用@Bean注解，去把这个容器注入到SpringBoot中。</p><p>再去测试一下：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/5.png" alt=""></p><p>我这里是每15秒进行一次访问，可以发现，缓存都在10后会自动过期，都需要重新从数据库读取。</p><p>我们可以使用RedisDesktop去查看Redis到底存放了些什么：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/redis/4.png" alt=""></p><p>项目地址：<a href="https://github.com/Antarctica000/SpringBoot/tree/master/redis">https://github.com/Antarctica000/SpringBoot/tree/master/redis</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot整合MyBatis框架</title>
      <link href="/2020/01/14/spring1/"/>
      <url>/2020/01/14/spring1/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot整合MyBatis框架"><a href="#SpringBoot整合MyBatis框架" class="headerlink" title="SpringBoot整合MyBatis框架"></a>SpringBoot整合MyBatis框架</h2><p>我们很多应用，访问数据库的方式都是JDBC等等，这些非常麻烦而又繁琐的操作，为了使得这个方式得到更好的优化，人们便开始对上帝有所诉求，上帝感到了程序猿的不幸，为了平衡各个物种的差别，同时也得给达尔文一个面子，于是诞生了MyBatis（瞎说）。</p><h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h3><p>讲到MyBatis，就先讲明这是什么吧。它是一个主流的ORM框架。那ORM又是什么呢？</p><p>对象-关系映射（Object-Relational Mapping，简称ORM），面向对象的开发方法是当今企业级应用开发环境中的主流开发方法，关系数据库是企业级应用环境中永久存放数据的主流数据存储系统。对象和关系数据是业务实体的两种表现形式，业务实体在内存中表现为对象，在数据库中表现为关系数据。内存中的对象之间存在关联和继承关系，而在数据库中，关系数据无法直接表达多对多关联和继承关系。因此，对象-关系映射(ORM)系统一般以中间件的形式存在，主要实现程序对象到关系数据库数据的映射。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mybatis/orm.jpg" alt=""></p><p><strong>简而言之，可以通过ORM框架去更方便的操控数据库。</strong></p><p>MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mybatis/mybatis.jpg" alt=""></p><p>Hibernate是全自动ORM框架，而Mybatis是半自动的。 hibernate完全可以通过对象关系模型实现对数据库的操作，拥有完整的JavaBean对象与数据库的映射结构来自动生成sql。 而mybatis仅有基本的字段映射，对象数据以及对象实际关系仍然需要通过手写sql来实现和管理。</p><p>无论是Mybatis、Hibernate都是ORM的一种实现框架，都是对JDBC的一种封装。</p><h4 id="最原始的MyBatis"><a href="#最原始的MyBatis" class="headerlink" title="最原始的MyBatis"></a>最原始的MyBatis</h4><h5 id="先加入pom依赖"><a href="#先加入pom依赖" class="headerlink" title="先加入pom依赖"></a>先加入pom依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/springdatajpa?useSSL=false&amp;serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">qwe123456</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure><p>定义好要连接的数据库属性，这里涉及到Spring的AOP，这些都是基础配置了。</p><h5 id="实体类："><a href="#实体类：" class="headerlink" title="实体类："></a>实体类：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id ;</span><br><span class="line"><span class="keyword">private</span> String loginName ;</span><br><span class="line"><span class="keyword">private</span> String username ;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getLoginName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> loginName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoginName</span><span class="params">(String loginName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.loginName = loginName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> username;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.username = username;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.password = password;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以用插件，省略掉写这些get和set哦，后面会讲。</p><h5 id="SQL的实现"><a href="#SQL的实现" class="headerlink" title="SQL的实现"></a>SQL的实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Insert</span>(<span class="string">"insert into tb_user(login_name ,username ,password) "</span></span><br><span class="line">+ <span class="string">"values (#&#123;loginName&#125;,#&#123;username&#125;,#&#123;password&#125;)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入数据获取主键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Insert</span>(<span class="string">"insert into tb_user(login_name ,username ,password) "</span></span><br><span class="line">+ <span class="string">"values (#&#123;loginName&#125;,#&#123;username&#125;,#&#123;password&#125;)"</span>)</span><br><span class="line"><span class="meta">@Options</span>(useGeneratedKeys=<span class="keyword">true</span>,keyProperty=<span class="string">"id"</span>,keyColumn=<span class="string">"id"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertGetKey</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Select</span>(<span class="string">"select * from tb_user where username = #&#123;username&#125;"</span>)</span><br><span class="line"><span class="comment">// 引用id="userResult"的@Results</span></span><br><span class="line"><span class="meta">@ResultMap</span>(<span class="string">"userResult"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">selectByUsername</span><span class="params">(@Param(<span class="string">"username"</span>)</span> String username)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Select</span>(<span class="string">"select * from tb_user"</span>)</span><br><span class="line"><span class="comment">// @Results用于映射对象属性和数据库列，常用于对象属性和数据库列不同名情况</span></span><br><span class="line"><span class="meta">@Results</span>(id=<span class="string">"userResult"</span>,value=&#123;</span><br><span class="line"><span class="meta">@Result</span>(id=<span class="keyword">true</span>,column=<span class="string">"id"</span>,property=<span class="string">"id"</span>),</span><br><span class="line"><span class="meta">@Result</span>(column=<span class="string">"login_name"</span>,property=<span class="string">"loginName"</span>),</span><br><span class="line"><span class="meta">@Result</span>(column=<span class="string">"password"</span>,property=<span class="string">"password"</span>),</span><br><span class="line"><span class="meta">@Result</span>(column=<span class="string">"username"</span>,property=<span class="string">"username"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Delete</span>(<span class="string">"delete from tb_user where id=#&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">final</span> Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Select</span>(<span class="string">"select * from tb_user where id=#&#123;id&#125;"</span>)</span><br><span class="line"><span class="comment">// 引用id="userResult"的@Results</span></span><br><span class="line"><span class="meta">@ResultMap</span>(<span class="string">"userResult"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Update</span>(<span class="string">"update tb_user set username=#&#123;username&#125;, login_name=#&#123;loginName&#125; where id=#&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">final</span> User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是一个接口，所有的SQL实现通过注解写在函数前面，就拥有了这些功能。</p><h5 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注入UserRepository</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> userRepository.insertUser(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">selectByUsername</span><span class="params">(String username)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> userRepository.selectByUsername(username);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> userRepository.findAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertGetKey</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 数据插入成功以后，Mybatis框架会将插入成功的数据主键存入到user对象中去</span></span><br><span class="line">userRepository.insertGetKey(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">userRepository.update(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">userRepository.delete(id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务层并不需要做些什么，仅仅是注入持久层便可。持久层会使用它的方法，再结合注解去完成查找或查询操作。</p><h5 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注入UserService</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/insertUser"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">insertUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"插入数据["</span>+userService.insertUser(user)+<span class="string">"]条"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/insertGetKey"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">insertGetKey</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">userService.insertGetKey(user);</span><br><span class="line"><span class="keyword">return</span> user ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/selectByUsername"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">selectByUsername</span><span class="params">(String username)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> userService.selectByUsername(username);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/findAll"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> userService.findAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/update"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">userService.update(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/delete"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">userService.delete(id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用的@Resource可以寻找服务层的类去注入，从结构来看，一般都是从控制层往下直到持久层。</p><h5 id="启动器"><a href="#启动器" class="headerlink" title="启动器"></a>启动器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.my.data07mybatis.repository"</span>)</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Data07mybatisApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Data07mybatisApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后别忘了在启动器前面加入@MapperScan，它会扫描在这个包下的所有类，并将其识别为MyBatis的Mapper类，这也是MyBatis独有的注解。</p><h4 id="XML型MyBatis"><a href="#XML型MyBatis" class="headerlink" title="XML型MyBatis"></a>XML型MyBatis</h4><p>使用xml文件去完成mybatis的各种SQL，有利于集中的SQL编写和控制，使我们能够更好的完成业务，大部分公司都在用这个写法。</p><h5 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Alias</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String user_name;</span><br><span class="line">    <span class="keyword">int</span> sex;</span><br><span class="line">    String note;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在引入了Lombok之后，写一个类只需要在上面加一个@Data注解便可以了，会自动生成get和set方法。</p><h5 id="mapper类"><a href="#mapper类" class="headerlink" title="mapper类"></a>mapper类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">userMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">User <span class="title">find</span><span class="params">(<span class="keyword">int</span> id )</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要做个接口就可以了，写好要做的事件的函数头便可，其他都不用。</p><p>不过同样的，也需要在启动器中加入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.example.mybatis2.mapper"</span>)</span><br></pre></td></tr></table></figure><p>和之前的比起来，少了个SQL语句的编写，那么SQL不用写怎么知道要干什么呢？当然不是不用，而是使用XML文件去代替：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.example.mybatis2.mapper.userMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"find"</span>  <span class="attr">resultType</span>=<span class="string">"user"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">        select * from t_user where id=#&#123;id&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这便是一个SQL语句，由namespace定位mapper类，由id确定方法头，由parametertype确定传入参数类型，而resulttype则是返回值类型啦。</p><p>记得要放在resource文件的mapper文件下哦，不然扫描不到的，具体可以根据自己的需求，在application.yml里面改。</p><h5 id="业务层和控制层"><a href="#业务层和控制层" class="headerlink" title="业务层和控制层"></a>业务层和控制层</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">userService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> userMapper user;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user.find(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">userController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> userService user;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/find"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(<span class="keyword">int</span> id )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> user.find(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和上面差不多，这里省略了其他方法。</p><p>同样的，也需要在启动器中加入MapperScan（），去扫描dao层(持久层)的数据哦。</p><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>在浏览器输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8888&#x2F;user&#x2F;find?id&#x3D;1</span><br></pre></td></tr></table></figure><p>便看到结果了:</p><p><img src="https://s2.ax1x.com/2020/01/15/lXYEse.png" alt=""></p><p>。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>但，这样还是太麻烦了，咱们还是用更偷懒的办法吧。</p><h3 id="高级偷懒法：MyBatis-Puls"><a href="#高级偷懒法：MyBatis-Puls" class="headerlink" title="高级偷懒法：MyBatis-Puls"></a>高级偷懒法：MyBatis-Puls</h3><p>MyBatis-Puls，可以让你不写SQL哦。。。</p><p>请看：</p><h5 id="在pom文件中加入MyBatis-Puls依赖：："><a href="#在pom文件中加入MyBatis-Puls依赖：：" class="headerlink" title="在pom文件中加入MyBatis-Puls依赖：："></a>在pom文件中加入MyBatis-Puls依赖：：</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p> <strong>MyBatis-Plus</strong>（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p><p>建议在编程的时候有个好习惯，多加点插件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>lombok是个好东西，谁用谁知道。</p><h5 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml:"></a>application.yml:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus:</span><br><span class="line">  mapper-locations: classpath:&#x2F;mapper&#x2F;*Mapper.xml</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br><span class="line">    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;springtest?useSSL&#x3D;false&amp;serverTimezone&#x3D;GMT%2B8&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    tomcat:</span><br><span class="line">      max-idle: 10</span><br><span class="line">      max-wait: 10000</span><br><span class="line">      max-active: 50</span><br><span class="line">      initial-size: 5</span><br><span class="line">server:</span><br><span class="line">  port: 8888</span><br></pre></td></tr></table></figure><h5 id="config的配置："><a href="#config的配置：" class="headerlink" title="config的配置："></a>config的配置：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.example.mybatis.mapper"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisConfig</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h5 id="UserMapper"><a href="#UserMapper" class="headerlink" title="UserMapper"></a>UserMapper</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.example.mybatis.mapper.UserMapper"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其实不加入这个也可以，没有影响。</p><h5 id="建立数据库"><a href="#建立数据库" class="headerlink" title="建立数据库"></a>建立数据库</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tbl_user&#96;</span><br><span class="line">(</span><br><span class="line">   user_id BIGINT(20) NOT NULL COMMENT &#39;主键ID&#39;,&#96;</span><br><span class="line">   user_name VARCHAR(30) NULL DEFAULT NULL COMMENT &#39;姓名&#39;,&#96;</span><br><span class="line">   user_age INT(11) NULL DEFAULT NULL COMMENT &#39;年龄&#39;,&#96;</span><br><span class="line">   PRIMARY KEY (user_id)&#96;</span><br><span class="line">) charset &#x3D; utf8;&#96;</span><br></pre></td></tr></table></figure><h4 id="业务编写"><a href="#业务编写" class="headerlink" title="业务编写"></a>业务编写</h4><h5 id="实体类-1"><a href="#实体类-1" class="headerlink" title="实体类"></a>实体类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName</span>(<span class="string">"tbl_user"</span>)</span><br><span class="line"><span class="comment">//@Alias("name")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@TableId</span>(value = <span class="string">"user_id"</span>)</span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> Integer userAge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Data能够自动构造get和set方法。</p><p>@TableName进行绑定操作</p><p>同时也可以使用@Alias去指定别名</p><h5 id="Mapper类"><a href="#Mapper类" class="headerlink" title="Mapper类"></a>Mapper类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>接口什么都不需要不用写。</p><h5 id="Service接口"><a href="#Service接口" class="headerlink" title="Service接口"></a>Service接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> <span class="keyword">extends</span> <span class="title">IService</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertUser</span><span class="params">( User user )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateUser</span><span class="params">( User user )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">( User user )</span></span>;</span><br><span class="line">    <span class="function">User <span class="title">findUserByName</span><span class="params">( String userName )</span></span>;</span><br><span class="line">    <span class="function">IPage <span class="title">getUserPage</span><span class="params">(Page page, User user )</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在服务层接口定义好要进行的操作。</p><h5 id="实现Service层"><a href="#实现Service层" class="headerlink" title="实现Service层"></a>实现Service层</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">UserMapper</span>, <span class="title">User</span>&gt; <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 增</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baseMapper.insert( user );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baseMapper.updateById( user );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baseMapper.deleteById( user.getUserId() );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUserByName</span><span class="params">( String userName )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IPage <span class="title">getUserPage</span><span class="params">(Page page, User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，这里的增删改查，通通都不用写SQL，简直人类福音啊。因为大部分繁琐的SQL语句，都被封装在baseMapper里面了。</p><h5 id="Controller层"><a href="#Controller层" class="headerlink" title="Controller层"></a>Controller层</h5><p>最后的就是控制层了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserContorller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增</span></span><br><span class="line">    <span class="meta">@PostMapping</span>( value = <span class="string">"/insert"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">insert</span><span class="params">( @RequestBody User user )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.insertUser( user );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改</span></span><br><span class="line">    <span class="meta">@PostMapping</span>( value = <span class="string">"/update"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">update</span><span class="params">( @RequestBody User user )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.updateUser( user );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删</span></span><br><span class="line">    <span class="meta">@PostMapping</span>( value = <span class="string">"/delete"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">delete</span><span class="params">( @RequestBody User user )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.deleteUser( user );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查</span></span><br><span class="line">    <span class="meta">@GetMapping</span>( value = <span class="string">"/getUserByName"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getUserByName</span><span class="params">( @RequestParam String userName )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.findUserByName( userName );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就好了，开始尝试一下把。</p><p>先打开postman，在输入：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mybatis/1.png" alt=""></p><p>多输入几条，最后再去数据库查看一下。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mybatis/2.png" alt=""></p><p>果然都输入进去了，那么再试试更改：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mybatis/3.png" alt=""></p><p>看看数据库：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/mybatis/4.png" alt=""></p><p>发现也成功了，删除就不演示了。这样的方式，省略了大量的SQL语句，同样将数据传入了数据库。</p><p>是不是一点SQL都不用写，只用写实体类，再调用方法就行了。很棒吧。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>还是太麻烦了，我懒，我实体类都不想写，我想让实体类都自己生成。</p><p>。</p><p>。</p><p>行吧，我告诉你一个更好的办法，自动生成代码！</p><h3 id="究极偷懒法：Mybatis-Generator"><a href="#究极偷懒法：Mybatis-Generator" class="headerlink" title="究极偷懒法：Mybatis-Generator"></a>究极偷懒法：Mybatis-Generator</h3><p>这个能够让你自动生成代码，连实体类都不用写哦。</p><p>方法如下：</p><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>插件:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configurationFile</span>&gt;</span>src/main/resources/mybatis-generator.xml<span class="tag">&lt;/<span class="name">configurationFile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">overwrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overwrite</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>MyBatis Generator 也需要一个 xml格式的配置文件，该文件的位置配在了上文 引入 MyBatis Generator Maven 插件的 xml配置里，即 src/main/resources/mybatis-generator.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">"MySql"</span> <span class="attr">defaultModelType</span>=<span class="string">"flat"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">type</span>=<span class="string">"org.mybatis.generator.plugins.SerializablePlugin"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span></span></span><br><span class="line"><span class="tag">                <span class="attr">driverClass</span>=<span class="string">"com.mysql.jdbc.Driver"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">connectionURL</span>=<span class="string">"jdbc:mysql://localhost:3306/springtest?serverTimezone=UTC"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">userId</span>=<span class="string">"root"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">password</span>=<span class="string">"123456"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"com.example.mybatis4.entity"</span> <span class="attr">targetProject</span>=<span class="string">"src/main/java"</span>&gt;</span><span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"mapper"</span>  <span class="attr">targetProject</span>=<span class="string">"src/main/resources"</span>&gt;</span><span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"com.example.mybatis4.mapper"</span> <span class="attr">targetProject</span>=<span class="string">"src/main/java"</span> <span class="attr">type</span>=<span class="string">"XMLMAPPER"</span>&gt;</span><span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"tbl_user"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"modelOnly"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面 xml中几个关键的配置简介如下：</p><ul><li>jdbcConnection：数据库连接配置</li><li>javaModelGenerator：指定自动生成的 POJO置于哪个包下 </li><li>sqlMapGenerator：指定自动生成的 mapper.xml置于哪个包下</li><li>javaClientGenerator：指定自动生成的 DAO接口置于哪个包下</li><li>table tableName：指定数据表名，可以使用_和%通配符</li></ul><p>记得一定要配置好，具体可以对照着配置。</p><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>双击右边的MyBatis Generator：</p><p><img src="https://s2.ax1x.com/2020/01/15/lXtUne.png" alt=""></p><p>看看效果吧：</p><p><img src="https://s2.ax1x.com/2020/01/15/lXtW7j.png" alt=""></p><p>这样，就连实体类都自动生成了。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>。</p><p>我还想。。。让数据库自己跑到后端，自己动，可以吗？</p><p>。</p><p>。</p><p><img src="https://imgsa.baidu.com/forum/w%3D580/sign=0c4373343ad12f2ece05ae687fc3d5ff/44130ae93901213fcfa15c3f58e736d12e2e9542.jpg" alt=""></p><p>项目地址：</p><p><a href="https://github.com/Antarctica000/SpringBoot/tree/master/mybatis">https://github.com/Antarctica000/SpringBoot/tree/master/mybatis</a></p><p><a href="https://github.com/Antarctica000/SpringBoot/tree/master/mybatis2">https://github.com/Antarctica000/SpringBoot/tree/master/mybatis2</a></p><p><a href="https://github.com/Antarctica000/SpringBoot/tree/master/mybatis3">https://github.com/Antarctica000/SpringBoot/tree/master/mybatis3</a></p><p><a href="https://github.com/Antarctica000/SpringBoot/tree/master/mybatis4">https://github.com/Antarctica000/SpringBoot/tree/master/mybatis4</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机（七）虚拟机性能监控、故障处理工具</title>
      <link href="/2020/01/13/Java%E8%99%9A%E6%8B%9F%E6%9C%BA7/"/>
      <url>/2020/01/13/Java%E8%99%9A%E6%8B%9F%E6%9C%BA7/</url>
      
        <content type="html"><![CDATA[<h3 id="基础故障工具"><a href="#基础故障工具" class="headerlink" title="基础故障工具"></a>基础故障工具</h3><p>在JDK中，有很多工具可以进行对虚拟机的性能监控，或者是故障处理。</p><h4 id="jps：虚拟机进程状况工具"><a href="#jps：虚拟机进程状况工具" class="headerlink" title="jps：虚拟机进程状况工具"></a>jps：虚拟机进程状况工具</h4><p>之前在讲多线程的时候也有用到了，在检查死锁问题的时候，使用jps查看是哪个线程。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jps.png" alt="jps"></p><h4 id="jstat：虚拟机统计信息工具"><a href="#jstat：虚拟机统计信息工具" class="headerlink" title="jstat：虚拟机统计信息工具"></a>jstat：虚拟机统计信息工具</h4><p>jstat可以用于对线程的监控和统计，如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvmtools/1.png" alt=""></p><p>对 15192线程查询GC的情况，一共查询20次，每250ms一次。</p><h4 id="jinfo：Java配置工具"><a href="#jinfo：Java配置工具" class="headerlink" title="jinfo：Java配置工具"></a>jinfo：Java配置工具</h4><p>jinfo可以用于查询和配置Java虚拟机的配置信息，但在Windows平台限制较大，只能使用-flag指令。</p><h4 id="jmap：Java内存映像工具"><a href="#jmap：Java内存映像工具" class="headerlink" title="jmap：Java内存映像工具"></a>jmap：Java内存映像工具</h4><p>能进行对内存的信息进行快照存储，如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvmtools/2.png" alt=""></p><p>让虚拟机生成堆转储快照文件，一个生成的文件名为eclipse.bin ，去进程15192获取。</p><h4 id="jhat：虚拟机堆转储快照分析工具"><a href="#jhat：虚拟机堆转储快照分析工具" class="headerlink" title="jhat：虚拟机堆转储快照分析工具"></a>jhat：虚拟机堆转储快照分析工具</h4><p>jhat命令可以和jmap搭配使用。如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvmtools/3.png" alt=""></p><p>能够分析出这个eclipse文件，看到分析结果。</p><h4 id="jstack：Java堆栈跟踪工具"><a href="#jstack：Java堆栈跟踪工具" class="headerlink" title="jstack：Java堆栈跟踪工具"></a>jstack：Java堆栈跟踪工具</h4><p>能够追踪到Java堆栈的运行状况，如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvmtools/4.png" alt=""></p><p>拿出之前发生过死锁的程序来进行判断，寻找死锁的原因。</p><h3 id="可视化故障工具"><a href="#可视化故障工具" class="headerlink" title="可视化故障工具"></a>可视化故障工具</h3><p>JDK除了大量的命令行工具之外，也有一些好用的可视化工具去对故障进行处理。</p><h4 id="JHSDB：基于服务性代理的调试工具"><a href="#JHSDB：基于服务性代理的调试工具" class="headerlink" title="JHSDB：基于服务性代理的调试工具"></a>JHSDB：基于服务性代理的调试工具</h4><p>JHSDB是一款基于服务性代理实现的进程外调试工具。它可以在一个独立的JAVA虚拟机进程里分析其他的HotSpot虚拟机的内部数据。我们这次就是JHSDB分析一下以下代码，看看staticObj、instanceObj、localObj存放在哪里？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * staticObj、instanceObj、localObj存放在哪里？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//-Xmx10m -XX:+UseSerialGC -XX:-UseCompressedOops</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> ObjectHolder staticObj = <span class="keyword">new</span> ObjectHolder();</span><br><span class="line">        ObjectHolder instanceObj = <span class="keyword">new</span> ObjectHolder();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ObjectHolder localObj = <span class="keyword">new</span> ObjectHolder();</span><br><span class="line">            System.out.println(<span class="string">"done"</span>);    <span class="comment">// 这里设一个断点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectHolder</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过jps查询进程，再通过Jhsdb打开图形化模式。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvmtools/5.png" alt=""></p><p>打开后如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvmtools/6.png" alt=""></p><p>运行到断点处，一共会创建三个ObjectHolder对象的实例。只要是对象实例，就必然会在Java堆中分配。</p><p>先点击菜单的Tools-&gt; Heap Parameters</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvmtools/7.png" alt=""></p><p>接着在Windows的</p><p>scanoops 0x0000020717600000 0x0000020717950000 test$ObjectHolder</p><p>注意要使用相应的内存地址，在寻找的时候你也可以看到cmd同时也进行的寻址：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvmtools/8.png" alt=""></p><p>最后我们运行完，可以看到这三行内容：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvmtools/9.png" alt=""></p><p>找出了这三个实例的地址。然后继续使用tools的Inspector，去查找：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvmtools/10.png" alt=""></p><p>发现查找到的正是我们所在的类的内存，接下来要根据堆中对象实例地址找出引用它们的指针。使用如下命令：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvmtools/11.png" alt=""></p><p>那么在根据得到的指针去寻找是否就是对应的对象。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvmtools/12.png" alt=""></p><p>可以看到，正是指向了我们所引用的对象实例，可见这是正确的行为。接下来试试第二个：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvmtools/13.png" alt=""></p><p>再查找：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvmtools/14.png" alt=""></p><p>第三个：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvmtools/15.png" alt=""></p><p>发现第三个居然不行了，直接显示为null，表示查找不到这个指针。看来revptrs命令并不支持查找栈上的指针，但这并不妨碍我们。我们还可以用Java Thread窗口的main线程，点击Stack Memory，手动去寻找栈内存。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvmtools/16.png" alt=""></p><p>如此一来，三个对象都找到了，还追溯到了引用它们的地方。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机（六）内存分配与回收策略</title>
      <link href="/2020/01/13/Java%E8%99%9A%E6%8B%9F%E6%9C%BA6/"/>
      <url>/2020/01/13/Java%E8%99%9A%E6%8B%9F%E6%9C%BA6/</url>
      
        <content type="html"><![CDATA[<h3 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h3><p>这次，我们就是用最基本的收集器 Serial来查看内存是怎么分配和回收的吧。首先看Java堆的分区：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/jvm14.jpg" alt=""></p><p><strong>1.Eden区</strong></p><p>  Eden区位于Java堆的年轻代，是<strong>新对象</strong>分配内存的地方，由于堆是所有线程共享的，因此在堆上分配内存需要加锁。而Sun JDK为提升效率，会为每个新建的线程在Eden上分配一块独立的空间由该线程独享，这块空间称为TLAB（Thread Local Allocation Buffer）。在TLAB上分配内存不需要加锁，因此JVM在给线程中的对象分配内存时会尽量在TLAB上分配。如果对象过大或TLAB用完，则仍然在堆上进行分配。如果Eden区内存也用完了，则会进行一次Minor GC（young GC）。</p><p><strong>2.Survival from to</strong></p><p>  Survival区与Eden区相同都在Java堆的年轻代。Survival区有两块，一块称为from区，另一块为to区，这两个区是相对的，在发生一次Minor GC后，from区就会和to区互换。在发生Minor GC时，Eden区和Survivalfrom区会把一些仍然存活的对象复制进Survival to区，并清除内存。Survival to区会把一些存活得足够旧的对象移至年老代。</p><p><strong>3.年老代</strong></p><p>  年老代里存放的都是存活时间较久的，大小较大的对象，因此年老代使用标记整理算法。当年老代容量满的时候，会触发一次Major GC（full GC），回收年老代和年轻代中不再被使用的对象资源。</p><p>注:本节使用JDK均为JDK6。</p><h4 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h4><p>大多数情况下，对象在新生代Eden区分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次MinorGC。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Jdk6</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];  <span class="comment">// 出现一次Minor GC</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[GC [DefNew: 6825K-&gt;172K(9216K), 0.0045184 secs] 6825K-&gt;6316K(19456K), 0.0045424 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span><br><span class="line"><span class="comment">Heap</span></span><br><span class="line"><span class="comment"> def new generation   total 9216K, used 4598K [0x33050000, 0x33a50000, 0x33a50000)</span></span><br><span class="line"><span class="comment">  eden space 8192K,  54% used [0x33050000, 0x334a27a0, 0x33850000)</span></span><br><span class="line"><span class="comment">  from space 1024K,  16% used [0x33950000, 0x3397b060, 0x33a50000)</span></span><br><span class="line"><span class="comment">  to   space 1024K,   0% used [0x33850000, 0x33850000, 0x33950000)</span></span><br><span class="line"><span class="comment"> tenured generation   total 10240K, used 6144K [0x33a50000, 0x34450000, 0x34450000)</span></span><br><span class="line"><span class="comment">   the space 10240K,  60% used [0x33a50000, 0x34050030, 0x34050200, 0x34450000)</span></span><br><span class="line"><span class="comment"> compacting perm gen  total 12288K, used 424K [0x34450000, 0x35050000, 0x38450000)</span></span><br><span class="line"><span class="comment">   the space 12288K,   3% used [0x34450000, 0x344ba2f8, 0x344ba400, 0x35050000)</span></span><br><span class="line"><span class="comment">    ro space 10240K,  55% used [0x38450000, 0x389d3320, 0x389d3400, 0x38e50000)</span></span><br><span class="line"><span class="comment">    rw space 12288K,  55% used [0x38e50000, 0x394f6128, 0x394f6200, 0x39a50000)</span></span><br></pre></td></tr></table></figure><p>-XX:SurvivorRatio=8</p><p>这个程序分配了三个2MB大小和一个4MB大小的对象，执行分配allocation4时会发生一次MinorGC，这次回收的结果是新生代6825K-&gt;172K，总内存占用量几乎没有减少。产生垃圾回收的原因是allocation4不足以在新生代中存放了，而三个2MB的对象又无法放入Survivor空间（1MB），所以只能通过分配担保机制提前转移到老年代去。</p><p>所以收集结束后，allocation4被分配到了Eden中，Survivor空闲，老年代被占用6MB。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def new generation   total 9216K, used 4598K</span><br><span class="line"> tenured generation   total 10240K, used 6144K</span><br></pre></td></tr></table></figure><h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p>使得大对象直接进入老年代，就可以避免在Eden区和两个Survivor区之间来回复制，产生大量的内存复制操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment"> * -XX:PretenureSizeThreshold=3145728</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] allocation;</span><br><span class="line">        allocation = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];  <span class="comment">//直接分配在老年代中C</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Heap</span></span><br><span class="line"><span class="comment"> def new generation   total 9216K, used 845K [0x33050000, 0x33a50000, 0x33a50000)</span></span><br><span class="line"><span class="comment">  eden space 8192K,  10% used [0x33050000, 0x331234d0, 0x33850000)</span></span><br><span class="line"><span class="comment">  from space 1024K,   0% used [0x33850000, 0x33850000, 0x33950000)</span></span><br><span class="line"><span class="comment">  to   space 1024K,   0% used [0x33950000, 0x33950000, 0x33a50000)</span></span><br><span class="line"><span class="comment"> tenured generation   total 10240K, used 4096K [0x33a50000, 0x34450000, 0x34450000)</span></span><br><span class="line"><span class="comment">   the space 10240K,  40% used [0x33a50000, 0x33e50010, 0x33e50200, 0x34450000)</span></span><br><span class="line"><span class="comment"> compacting perm gen  total 12288K, used 424K [0x34450000, 0x35050000, 0x38450000)</span></span><br><span class="line"><span class="comment">   the space 12288K,   3% used [0x34450000, 0x344ba260, 0x344ba400, 0x35050000)</span></span><br><span class="line"><span class="comment">    ro space 10240K,  55% used [0x38450000, 0x389d3320, 0x389d3400, 0x38e50000)</span></span><br><span class="line"><span class="comment">    rw space 12288K,  55% used [0x38e50000, 0x394f6128, 0x394f6200, 0x39a50000)</span></span><br></pre></td></tr></table></figure><p>可以从 <strong>total 10240K, used 4096K</strong> ，这一条得出，大对象直接进入到了老年代，不过不是默认进行的，需要使用：-XX:+PrintTenuringDistribution。进行设置。</p><h4 id="长期存活的对象直接进入老年代"><a href="#长期存活的对象直接进入老年代" class="headerlink" title="长期存活的对象直接进入老年代"></a>长期存活的对象直接进入老年代</h4><p>在进行内存回收时，为了能够判断哪些存活对象是放在新生代还是老年代。有一个默认的评判机制，当<strong>在新生代经过了N次MinorGC后</strong>，仍然存活，便将其放入老年代。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=1</span></span><br><span class="line"><span class="comment"> * -XX:+PrintTenuringDistribution</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] allocation1, allocation2, allocation3;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>];  <span class="comment">// 什么时候进入老年代决定于XX:MaxTenuringThreshold设置</span></span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">        allocation3 = <span class="keyword">null</span>;</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过将XX:MaxTenuringThreshold=1设置后，仅仅经过一次MinorGC，便放入老年代。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[GC [DefNew</span><br><span class="line">Desired survivor size <span class="number">524288</span> bytes, <span class="keyword">new</span> threshold <span class="number">1</span> (max <span class="number">1</span>)</span><br><span class="line">- age   <span class="number">1</span>:     <span class="number">438384</span> bytes,     <span class="number">438384</span> total</span><br><span class="line">: <span class="number">5033</span>K-&gt;<span class="number">428</span>K(<span class="number">9216</span>K), <span class="number">0.0044237</span> secs] <span class="number">5033</span>K-&gt;<span class="number">4524</span>K(<span class="number">19456</span>K), <span class="number">0.0044527</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC [DefNew</span><br><span class="line">Desired survivor size <span class="number">524288</span> bytes, <span class="keyword">new</span> threshold <span class="number">1</span> (max <span class="number">1</span>)</span><br><span class="line">- age   <span class="number">1</span>:        <span class="number">224</span> bytes,        <span class="number">224</span> total</span><br><span class="line">: <span class="number">4772</span>K-&gt;<span class="number">0</span>K(<span class="number">9216</span>K), <span class="number">0.0009550</span> secs] <span class="number">8868</span>K-&gt;<span class="number">4524</span>K(<span class="number">19456</span>K), <span class="number">0.0009794</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> def <span class="keyword">new</span> generation   total <span class="number">9216</span>K, used <span class="number">4234</span>K [<span class="number">0x33050000</span>, <span class="number">0x33a50000</span>, <span class="number">0x33a50000</span>)</span><br><span class="line">  eden space <span class="number">8192</span>K,  <span class="number">51</span>% used [<span class="number">0x33050000</span>, <span class="number">0x334728b0</span>, <span class="number">0x33850000</span>)</span><br><span class="line">  from space <span class="number">1024</span>K,   <span class="number">0</span>% used [<span class="number">0x33850000</span>, <span class="number">0x338500e0</span>, <span class="number">0x33950000</span>)</span><br><span class="line">  to   space <span class="number">1024</span>K,   <span class="number">0</span>% used [<span class="number">0x33950000</span>, <span class="number">0x33950000</span>, <span class="number">0x33a50000</span>)</span><br><span class="line"> tenured generation   total <span class="number">10240</span>K, used <span class="number">4523</span>K [<span class="number">0x33a50000</span>, <span class="number">0x34450000</span>, <span class="number">0x34450000</span>)</span><br><span class="line">   the space <span class="number">10240</span>K,  <span class="number">44</span>% used [<span class="number">0x33a50000</span>, <span class="number">0x33ebafb0</span>, <span class="number">0x33ebb000</span>, <span class="number">0x34450000</span>)</span><br><span class="line"> compacting perm gen  total <span class="number">12288</span>K, used <span class="number">428</span>K [<span class="number">0x34450000</span>, <span class="number">0x35050000</span>, <span class="number">0x38450000</span>)</span><br><span class="line">   the space <span class="number">12288</span>K,   <span class="number">3</span>% used [<span class="number">0x34450000</span>, <span class="number">0x344bb298</span>, <span class="number">0x344bb400</span>, <span class="number">0x35050000</span>)</span><br><span class="line">    ro space <span class="number">10240</span>K,  <span class="number">55</span>% used [<span class="number">0x38450000</span>, <span class="number">0x389d3320</span>, <span class="number">0x389d3400</span>, <span class="number">0x38e50000</span>)</span><br><span class="line">    rw space <span class="number">12288</span>K,  <span class="number">55</span>% used [<span class="number">0x38e50000</span>, <span class="number">0x394f6128</span>, <span class="number">0x394f6200</span>, <span class="number">0x39a50000</span>)</span><br></pre></td></tr></table></figure><p>那么如果设置为默认值15呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[GC [DefNew</span><br><span class="line">Desired survivor size <span class="number">524288</span> bytes, <span class="keyword">new</span> threshold <span class="number">15</span> (max <span class="number">15</span>)</span><br><span class="line">- age   <span class="number">1</span>:     <span class="number">438384</span> bytes,     <span class="number">438384</span> total</span><br><span class="line">: <span class="number">5033</span>K-&gt;<span class="number">428</span>K(<span class="number">9216</span>K), <span class="number">0.0040562</span> secs] <span class="number">5033</span>K-&gt;<span class="number">4524</span>K(<span class="number">19456</span>K), <span class="number">0.0040857</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC [DefNew</span><br><span class="line">Desired survivor size <span class="number">524288</span> bytes, <span class="keyword">new</span> threshold <span class="number">15</span> (max <span class="number">15</span>)</span><br><span class="line">- age   <span class="number">1</span>:        <span class="number">224</span> bytes,        <span class="number">224</span> total</span><br><span class="line">- age   <span class="number">2</span>:     <span class="number">438176</span> bytes,     <span class="number">438400</span> total</span><br><span class="line">: <span class="number">4772</span>K-&gt;<span class="number">428</span>K(<span class="number">9216</span>K), <span class="number">0.0008210</span> secs] <span class="number">8868</span>K-&gt;<span class="number">4524</span>K(<span class="number">19456</span>K), <span class="number">0.0008423</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> def <span class="keyword">new</span> generation   total <span class="number">9216</span>K, used <span class="number">4662</span>K [<span class="number">0x33050000</span>, <span class="number">0x33a50000</span>, <span class="number">0x33a50000</span>)</span><br><span class="line">  eden space <span class="number">8192</span>K,  <span class="number">51</span>% used [<span class="number">0x33050000</span>, <span class="number">0x334728b0</span>, <span class="number">0x33850000</span>)</span><br><span class="line">  from space <span class="number">1024</span>K,  <span class="number">41</span>% used [<span class="number">0x33850000</span>, <span class="number">0x338bb080</span>, <span class="number">0x33950000</span>)</span><br><span class="line">  to   space <span class="number">1024</span>K,   <span class="number">0</span>% used [<span class="number">0x33950000</span>, <span class="number">0x33950000</span>, <span class="number">0x33a50000</span>)</span><br><span class="line"> tenured generation   total <span class="number">10240</span>K, used <span class="number">4096</span>K [<span class="number">0x33a50000</span>, <span class="number">0x34450000</span>, <span class="number">0x34450000</span>)</span><br><span class="line">   the space <span class="number">10240</span>K,  <span class="number">40</span>% used [<span class="number">0x33a50000</span>, <span class="number">0x33e50010</span>, <span class="number">0x33e50200</span>, <span class="number">0x34450000</span>)</span><br><span class="line"> compacting perm gen  total <span class="number">12288</span>K, used <span class="number">426</span>K [<span class="number">0x34450000</span>, <span class="number">0x35050000</span>, <span class="number">0x38450000</span>)</span><br><span class="line">   the space <span class="number">12288</span>K,   <span class="number">3</span>% used [<span class="number">0x34450000</span>, <span class="number">0x344bb108</span>, <span class="number">0x344bb200</span>, <span class="number">0x35050000</span>)</span><br><span class="line">    ro space <span class="number">10240</span>K,  <span class="number">55</span>% used [<span class="number">0x38450000</span>, <span class="number">0x389d3320</span>, <span class="number">0x389d3400</span>, <span class="number">0x38e50000</span>)</span><br><span class="line">    rw space <span class="number">12288</span>K,  <span class="number">55</span>% used [<span class="number">0x38e50000</span>, <span class="number">0x394f6128</span>, <span class="number">0x394f6200</span>, <span class="number">0x39a50000</span>)</span><br></pre></td></tr></table></figure><h4 id="动态对象年龄判断"><a href="#动态对象年龄判断" class="headerlink" title="动态对象年龄判断"></a>动态对象年龄判断</h4><p>HotSpot虚拟机并不是永远要求对象的年龄必须达到指定值才能够晋升老年代，如果在Survivor空间中，相同年龄所有对象大小的综合大于Survivor空间的一半，年龄大于或等于该年龄的对象，也可以直接进入老年代。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=15</span></span><br><span class="line"><span class="comment"> * -XX:+PrintTenuringDistribution</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>];   <span class="comment">// allocation1+allocation2大于survivo空间一半</span></span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">        allocation4 = <span class="keyword">null</span>;</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[GC [DefNew</span></span><br><span class="line"><span class="comment">Desired survivor size 524288 bytes, new threshold 1 (max 15)</span></span><br><span class="line"><span class="comment">- age   1:     700544 bytes,     700544 total</span></span><br><span class="line"><span class="comment">: 5289K-&gt;684K(9216K), 0.0044213 secs] 5289K-&gt;4780K(19456K), 0.0044653 secs] [Times: user=0.02 sys=0.02, real=0.00 secs] </span></span><br><span class="line"><span class="comment">[GC [DefNew</span></span><br><span class="line"><span class="comment">Desired survivor size 524288 bytes, new threshold 15 (max 15)</span></span><br><span class="line"><span class="comment">- age   1:        224 bytes,        224 total</span></span><br><span class="line"><span class="comment">: 5028K-&gt;0K(9216K), 0.0013033 secs] 9124K-&gt;4780K(19456K), 0.0013299 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span><br><span class="line"><span class="comment">Heap</span></span><br><span class="line"><span class="comment"> def new generation   total 9216K, used 4234K [0x33050000, 0x33a50000, 0x33a50000)</span></span><br><span class="line"><span class="comment">  eden space 8192K,  51% used [0x33050000, 0x33472858, 0x33850000)</span></span><br><span class="line"><span class="comment">  from space 1024K,   0% used [0x33850000, 0x338500e0, 0x33950000)</span></span><br><span class="line"><span class="comment">  to   space 1024K,   0% used [0x33950000, 0x33950000, 0x33a50000)</span></span><br><span class="line"><span class="comment"> tenured generation   total 10240K, used 4779K [0x33a50000, 0x34450000, 0x34450000)</span></span><br><span class="line"><span class="comment">   the space 10240K,  46% used [0x33a50000, 0x33efafc0, 0x33efb000, 0x34450000)</span></span><br><span class="line"><span class="comment"> compacting perm gen  total 12288K, used 428K [0x34450000, 0x35050000, 0x38450000)</span></span><br><span class="line"><span class="comment">   the space 12288K,   3% used [0x34450000, 0x344bb2c8, 0x344bb400, 0x35050000)</span></span><br><span class="line"><span class="comment">    ro space 10240K,  55% used [0x38450000, 0x389d3320, 0x389d3400, 0x38e50000)</span></span><br><span class="line"><span class="comment">    rw space 12288K,  55% used [0x38e50000, 0x394f6128, 0x394f6200, 0x39a50000)</span></span><br></pre></td></tr></table></figure><h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>前面说到，当大量对象在经过MinorGC之后，仍然存活，但Survivor已经放不下这么多的对象了，那么便直接将对象送入到老年代。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数：-Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] allocation1, allocation2, allocation3, allocation4, allocation5, allocation6, allocation7;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation1 = <span class="keyword">null</span>;</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation5 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation6 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation4 = <span class="keyword">null</span>;</span><br><span class="line">        allocation5 = <span class="keyword">null</span>;</span><br><span class="line">        allocation6 = <span class="keyword">null</span>;</span><br><span class="line">        allocation7 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[GC [DefNew: 6825K-&gt;172K(9216K), 0.0040796 secs] 6825K-&gt;4268K(19456K), 0.0041041 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span><br><span class="line"><span class="comment">[GC [DefNew: 6651K-&gt;172K(9216K), 0.0009841 secs] 10747K-&gt;4268K(19456K), 0.0010203 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span><br><span class="line"><span class="comment">Heap</span></span><br><span class="line"><span class="comment"> def new generation   total 9216K, used 2357K [0x33050000, 0x33a50000, 0x33a50000)</span></span><br><span class="line"><span class="comment">  eden space 8192K,  26% used [0x33050000, 0x33272560, 0x33850000)</span></span><br><span class="line"><span class="comment">  from space 1024K,  16% used [0x33850000, 0x3387b070, 0x33950000)</span></span><br><span class="line"><span class="comment">  to   space 1024K,   0% used [0x33950000, 0x33950000, 0x33a50000)</span></span><br><span class="line"><span class="comment"> tenured generation   total 10240K, used 4096K [0x33a50000, 0x34450000, 0x34450000)</span></span><br><span class="line"><span class="comment">   the space 10240K,  40% used [0x33a50000, 0x33e50020, 0x33e50200, 0x34450000)</span></span><br><span class="line"><span class="comment"> compacting perm gen  total 12288K, used 428K [0x34450000, 0x35050000, 0x38450000)</span></span><br><span class="line"><span class="comment">   the space 12288K,   3% used [0x34450000, 0x344bb358, 0x344bb400, 0x35050000)</span></span><br><span class="line"><span class="comment">    ro space 10240K,  55% used [0x38450000, 0x389d3320, 0x389d3400, 0x38e50000)</span></span><br><span class="line"><span class="comment">    rw space 12288K,  55% used [0x38e50000, 0x394f6128, 0x394f6200, 0x39a50000)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机（五）经典的垃圾收集器</title>
      <link href="/2020/01/12/Java%E8%99%9A%E6%8B%9F%E6%9C%BA5/"/>
      <url>/2020/01/12/Java%E8%99%9A%E6%8B%9F%E6%9C%BA5/</url>
      
        <content type="html"><![CDATA[<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>垃圾收集算法，都是一个原理，这些算法的实现的最终结果，就是垃圾收集器。每个垃圾收集器虽然算法上类似，但是各个都有着自己的优势。如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/jvm7.jpg" alt="jvm7"></p><p>这七个就是是如今比较流行的垃圾收集器。它们都是在分代收集算法的策略下运行的。</p><h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p>这是一个最古老的垃圾收集器，现在几乎不被使用了。它的原理非常简单，就是在进行垃圾收集的时候暂停所有的线程。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/jvm8.jpg" alt=""></p><p>正如图所示，这是一个单核的垃圾收集器，会在新生代使用复制算法，在老年代执行整理算法。一般在收集几十兆的新生代，所暂停的时间也仅仅在十几毫秒以内，对于运行在客户端模式下的虚拟机而言，也是可以接受的。</p><h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h4><p>Serial Old收集器是Serial收集器的老年版本。它经常被用来与其他收集器搭配使用。一般的搭档是 Parallel Scavenge收集器，还有一个就是作为CMS收集器发生失败时的后备预案。</p><h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p>ParNew收集器是Serial收集器的多线程版本。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/jvm9.jpg" alt=""></p><p>遗憾的是ParNew收集器仅仅只有复制算法实现了多线程，在标记整理当中，还是需要Serial Old收集器，暂停所有的线程来进行回收内存。但垃圾收集器并不是只能使用一种类型，ParNew收集器还能和CMS收集器结合在一起，实现完全的多线程垃圾收集。</p><h4 id="Parallel-Scabenge和Parallel-Old收集器"><a href="#Parallel-Scabenge和Parallel-Old收集器" class="headerlink" title="Parallel Scabenge和Parallel Old收集器"></a>Parallel Scabenge和Parallel Old收集器</h4><p>Parallel Scabenge和Parallel Old并不是同一时期的产物，是先有了Parallel Scabenge收集器，然后在JDK6的时候才提供了Parallel Old收集器，之后我们可以统称为Parallel收集器。运行效果如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/jvm11.jpg" alt=""></p><p>Parallel收集器的特点和其他的收集都有着很大的不同，这个收集器不把目光局限于缩短线程停顿的时间，而是引入了一个新的名词：<strong>吞吐量</strong>。</p><p>吞吐量(Throughput = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间))。</p><p>如果虚拟机完成某个任务，用户代码加上垃圾收集总共耗费了100分钟，其中垃圾收集花掉了一分钟，那么吞吐量就是99%。</p><p>可以通过 -XX：MaxGCPauseMills 参数设置内存回收花费最大时间， -XX:GCTimeRatio 设置垃圾收集时间占总时间的比率。-XX:+UseAdaptiveSizePolicy开启自动吞吐量控制。</p><p>作为一个吞吐量优先的收集器，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整停顿时间。这就是 GC 的自适应调整策略(GC Ergonomics)。</p><p><strong>JDK8用的正是这种模式的收集器</strong>。</p><h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>CMS收集器是一个基于标记清除算法的，能并发收集，低停顿的收集器。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/jvm12.jpg" alt=""></p><p>这个收集器的运行过程更为复杂，整个过程分为四个阶段：</p><ol><li>初始标记</li><li>并发标记</li><li>重新标记</li><li>并发清除</li></ol><p>可惜的是这个收集器无法处理“浮动垃圾”，并且也可能会产生内存碎片过多的问题，目前并未广泛的投入使用。</p><h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p>G1收集器是在垃圾收集器技术发展史上的一个里程碑式的成果。G1的进行回收的标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最大，回收收益最大，这就是G1的Mixed GC模式。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/jvm13.jpg" alt=""></p><p>这个收集器开创了面向局部收集的设计思路和基于Region的内存布局形式，同样有着四个阶段：</p><ol><li>初始标记：仅仅只是标记一下GC Roots能直接关联到的对象。</li><li>并发标记：开始进行可达性分析。</li><li>最终标记：处理并发阶段遗留的SATB记录。</li><li>筛选回收：对各个Region的价值和回收成本进行排序，然后回收。</li></ol><p><strong>就目前从JDK9到最新的JDK13而言，使用的正是G1收集器。</strong>这也是收集器未来的发展趋势。</p><h4 id="shenandoah收集器"><a href="#shenandoah收集器" class="headerlink" title="shenandoah收集器"></a>shenandoah收集器</h4><p>拥有九个阶段的、及其复杂的收集器，是基于G1的思想研发出来，目前处于试验状态。</p><h4 id="ZGC收集器"><a href="#ZGC收集器" class="headerlink" title="ZGC收集器"></a>ZGC收集器</h4><p>引入的染色指针的概念，也是基于G1的思想，而且对并发整理算法有着特别的改进，是一个新的低延迟收集器，目前也处于试验状态。</p><h4 id="Epsilon收集器"><a href="#Epsilon收集器" class="headerlink" title="Epsilon收集器"></a>Epsilon收集器</h4><p>拥有自动内存管理子系统的收集器。不以垃圾回收为关注点，而是集中在内存管理方面，是一个在只需要运行数分钟就关闭的应用上，有着极其低延迟的收集器。</p><h3 id="如何查看GC日志"><a href="#如何查看GC日志" class="headerlink" title="如何查看GC日志"></a>如何查看GC日志</h3><p>我们在进行调优的时候，往往需要根据GC情况来进行，但是我们该怎么得知GC信息呢？</p><h4 id="查看GC详细信息"><a href="#查看GC详细信息" class="headerlink" title="查看GC详细信息"></a>查看GC详细信息</h4><p>在JDK9之前使用-XX:+PrintGCDetails查看GC日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK8</span></span><br><span class="line"><span class="comment">//-XX:+PrintGCDetails</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个成员属性的唯一意义就是占点内存，以便在能在GC日志中看清楚是否有回收过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        test objA = <span class="keyword">new</span> test();</span><br><span class="line">        test objB = <span class="keyword">new</span> test();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line"></span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假设在这行发生GC，objA和objB是否能被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[GC (System.gc()) [PSYoungGen: 6425K-&gt;760K(33280K)] 6425K-&gt;768K(110080K), 0.0019406 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span><br><span class="line"><span class="comment">[Full GC (System.gc()) [PSYoungGen: 760K-&gt;0K(33280K)] [ParOldGen: 8K-&gt;581K(76800K)] 768K-&gt;581K(110080K), [Metaspace: 3099K-&gt;3099K(1056768K)], 0.0054005 secs] [Times: user=0.11 sys=0.00, real=0.01 secs] </span></span><br><span class="line"><span class="comment">Heap</span></span><br><span class="line"><span class="comment"> PSYoungGen      total 33280K, used 860K [0x00000000daf80000, 0x00000000dd480000, 0x0000000100000000)</span></span><br><span class="line"><span class="comment">  eden space 28672K, 3% used [0x00000000daf80000,0x00000000db057230,0x00000000dcb80000)</span></span><br><span class="line"><span class="comment">  from space 4608K, 0% used [0x00000000dcb80000,0x00000000dcb80000,0x00000000dd000000)</span></span><br><span class="line"><span class="comment">  to   space 4608K, 0% used [0x00000000dd000000,0x00000000dd000000,0x00000000dd480000)</span></span><br><span class="line"><span class="comment"> ParOldGen       total 76800K, used 581K [0x0000000090e00000, 0x0000000095900000, 0x00000000daf80000)</span></span><br><span class="line"><span class="comment">  object space 76800K, 0% used [0x0000000090e00000,0x0000000090e917e0,0x0000000095900000)</span></span><br><span class="line"><span class="comment"> Metaspace       used 3121K, capacity 4496K, committed 4864K, reserved 1056768K</span></span><br><span class="line"><span class="comment">  class space    used 340K, capacity 388K, committed 512K, reserved 1048576K</span></span><br></pre></td></tr></table></figure><p>在JDK9以及之后使用-Xlog:gc*查看GC日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-Xlog:gc*</span></span><br><span class="line"><span class="comment">//JDK13</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个成员属性的唯一意义就是占点内存，以便在能在GC日志中看清楚是否有回收过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        test objA = <span class="keyword">new</span> test();</span><br><span class="line">        test objB = <span class="keyword">new</span> test();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line"></span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假设在这行发生GC，objA和objB是否能被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[0.014s][info][gc,heap] Heap region size: 1M</span></span><br><span class="line"><span class="comment">[0.017s][info][gc     ] Using G1</span></span><br><span class="line"><span class="comment">[0.017s][info][gc,heap,coops] Heap address: 0x0000000090e00000, size: 1778 MB, Compressed Oops mode: 32-bit</span></span><br><span class="line"><span class="comment">[0.039s][info][gc           ] Periodic GC disabled</span></span><br><span class="line"><span class="comment">[0.088s][info][gc,task      ] GC(0) Using 2 workers of 8 for full compaction</span></span><br><span class="line"><span class="comment">[0.088s][info][gc,start     ] GC(0) Pause Full (System.gc())</span></span><br><span class="line"><span class="comment">[0.089s][info][gc,phases,start] GC(0) Phase 1: Mark live objects</span></span><br><span class="line"><span class="comment">[0.090s][info][gc,phases      ] GC(0) Phase 1: Mark live objects 1.420ms</span></span><br><span class="line"><span class="comment">[0.090s][info][gc,phases,start] GC(0) Phase 2: Prepare for compaction</span></span><br><span class="line"><span class="comment">[0.090s][info][gc,phases      ] GC(0) Phase 2: Prepare for compaction 0.351ms</span></span><br><span class="line"><span class="comment">[0.090s][info][gc,phases,start] GC(0) Phase 3: Adjust pointers</span></span><br><span class="line"><span class="comment">[0.091s][info][gc,phases      ] GC(0) Phase 3: Adjust pointers 0.674ms</span></span><br><span class="line"><span class="comment">[0.091s][info][gc,phases,start] GC(0) Phase 4: Compact heap</span></span><br><span class="line"><span class="comment">[0.092s][info][gc,phases      ] GC(0) Phase 4: Compact heap 0.484ms</span></span><br><span class="line"><span class="comment">[0.093s][info][gc,heap        ] GC(0) Eden regions: 2-&gt;0(2)</span></span><br><span class="line"><span class="comment">[0.093s][info][gc,heap        ] GC(0) Survivor regions: 0-&gt;0(0)</span></span><br><span class="line"><span class="comment">[0.093s][info][gc,heap        ] GC(0) Old regions: 0-&gt;2</span></span><br><span class="line"><span class="comment">[0.093s][info][gc,heap        ] GC(0) Archive regions: 0-&gt;0</span></span><br><span class="line"><span class="comment">[0.093s][info][gc,heap        ] GC(0) Humongous regions: 6-&gt;0</span></span><br><span class="line"><span class="comment">[0.093s][info][gc,metaspace   ] GC(0) Metaspace: 339K-&gt;339K(1056768K)</span></span><br><span class="line"><span class="comment">[0.093s][info][gc             ] GC(0) Pause Full (System.gc()) 7M-&gt;0M(8M) 4.329ms</span></span><br><span class="line"><span class="comment">[0.093s][info][gc,cpu         ] GC(0) User=0.00s Sys=0.00s Real=0.01s</span></span><br><span class="line"><span class="comment">[0.094s][info][gc,heap,exit   ] Heap</span></span><br><span class="line"><span class="comment">[0.094s][info][gc,heap,exit   ]  garbage-first heap   total 8192K, used 751K [0x0000000090e00000, 0x0000000100000000)</span></span><br><span class="line"><span class="comment">[0.094s][info][gc,heap,exit   ]   region size 1024K, 1 young (1024K), 0 survivors (0K)</span></span><br><span class="line"><span class="comment">[0.094s][info][gc,heap,exit   ]  Metaspace       used 343K, capacity 4494K, committed 4864K, reserved 1056768K</span></span><br><span class="line"><span class="comment">[0.094s][info][gc,heap,exit   ]   class space    used 22K, capacity 386K, committed 512K, reserved 1048576K</span></span><br></pre></td></tr></table></figure><h4 id="查看GC前后堆"><a href="#查看GC前后堆" class="headerlink" title="查看GC前后堆"></a>查看GC前后堆</h4><p>JDK9之前使用-XX:+PrintHeapAtGC</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;Heap before GC invocations=<span class="number">1</span> (full <span class="number">0</span>):</span><br><span class="line"> PSYoungGen      total <span class="number">33280</span>K, used <span class="number">6425</span>K [<span class="number">0x00000000daf80000</span>, <span class="number">0x00000000dd480000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space <span class="number">28672</span>K, <span class="number">22</span>% used [<span class="number">0x00000000daf80000</span>,<span class="number">0x00000000db5c6570</span>,<span class="number">0x00000000dcb80000</span>)</span><br><span class="line">  from space <span class="number">4608</span>K, <span class="number">0</span>% used [<span class="number">0x00000000dd000000</span>,<span class="number">0x00000000dd000000</span>,<span class="number">0x00000000dd480000</span>)</span><br><span class="line">  to   space <span class="number">4608</span>K, <span class="number">0</span>% used [<span class="number">0x00000000dcb80000</span>,<span class="number">0x00000000dcb80000</span>,<span class="number">0x00000000dd000000</span>)</span><br><span class="line"> ParOldGen       total <span class="number">76800</span>K, used <span class="number">0</span>K [<span class="number">0x0000000090e00000</span>, <span class="number">0x0000000095900000</span>, <span class="number">0x00000000daf80000</span>)</span><br><span class="line">  object space <span class="number">76800</span>K, <span class="number">0</span>% used [<span class="number">0x0000000090e00000</span>,<span class="number">0x0000000090e00000</span>,<span class="number">0x0000000095900000</span>)</span><br><span class="line"> Metaspace       used <span class="number">3204</span>K, capacity <span class="number">4496</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 347<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line"><span class="class"><span class="title">Heap</span> <span class="title">after</span> <span class="title">GC</span> <span class="title">invocations</span></span>=<span class="number">1</span> (full <span class="number">0</span>):</span><br><span class="line"> PSYoungGen      total <span class="number">33280</span>K, used <span class="number">824</span>K [<span class="number">0x00000000daf80000</span>, <span class="number">0x00000000dd480000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space <span class="number">28672</span>K, <span class="number">0</span>% used [<span class="number">0x00000000daf80000</span>,<span class="number">0x00000000daf80000</span>,<span class="number">0x00000000dcb80000</span>)</span><br><span class="line">  from space <span class="number">4608</span>K, <span class="number">17</span>% used [<span class="number">0x00000000dcb80000</span>,<span class="number">0x00000000dcc4e030</span>,<span class="number">0x00000000dd000000</span>)</span><br><span class="line">  to   space <span class="number">4608</span>K, <span class="number">0</span>% used [<span class="number">0x00000000dd000000</span>,<span class="number">0x00000000dd000000</span>,<span class="number">0x00000000dd480000</span>)</span><br><span class="line"> ParOldGen       total <span class="number">76800</span>K, used <span class="number">8</span>K [<span class="number">0x0000000090e00000</span>, <span class="number">0x0000000095900000</span>, <span class="number">0x00000000daf80000</span>)</span><br><span class="line">  object space <span class="number">76800</span>K, <span class="number">0</span>% used [<span class="number">0x0000000090e00000</span>,<span class="number">0x0000000090e02000</span>,<span class="number">0x0000000095900000</span>)</span><br><span class="line"> Metaspace       used <span class="number">3204</span>K, capacity <span class="number">4496</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 347<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span>&#123;Heap before GC invocations=<span class="number">2</span> (full <span class="number">1</span>):</span><br><span class="line"> PSYoungGen      total <span class="number">33280</span>K, used <span class="number">824</span>K [<span class="number">0x00000000daf80000</span>, <span class="number">0x00000000dd480000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space <span class="number">28672</span>K, <span class="number">0</span>% used [<span class="number">0x00000000daf80000</span>,<span class="number">0x00000000daf80000</span>,<span class="number">0x00000000dcb80000</span>)</span><br><span class="line">  from space <span class="number">4608</span>K, <span class="number">17</span>% used [<span class="number">0x00000000dcb80000</span>,<span class="number">0x00000000dcc4e030</span>,<span class="number">0x00000000dd000000</span>)</span><br><span class="line">  to   space <span class="number">4608</span>K, <span class="number">0</span>% used [<span class="number">0x00000000dd000000</span>,<span class="number">0x00000000dd000000</span>,<span class="number">0x00000000dd480000</span>)</span><br><span class="line"> ParOldGen       total <span class="number">76800</span>K, used <span class="number">8</span>K [<span class="number">0x0000000090e00000</span>, <span class="number">0x0000000095900000</span>, <span class="number">0x00000000daf80000</span>)</span><br><span class="line">  object space <span class="number">76800</span>K, <span class="number">0</span>% used [<span class="number">0x0000000090e00000</span>,<span class="number">0x0000000090e02000</span>,<span class="number">0x0000000095900000</span>)</span><br><span class="line"> Metaspace       used <span class="number">3204</span>K, capacity <span class="number">4496</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 347<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line"><span class="class"><span class="title">Heap</span> <span class="title">after</span> <span class="title">GC</span> <span class="title">invocations</span></span>=<span class="number">2</span> (full <span class="number">1</span>):</span><br><span class="line"> PSYoungGen      total <span class="number">33280</span>K, used <span class="number">0</span>K [<span class="number">0x00000000daf80000</span>, <span class="number">0x00000000dd480000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space <span class="number">28672</span>K, <span class="number">0</span>% used [<span class="number">0x00000000daf80000</span>,<span class="number">0x00000000daf80000</span>,<span class="number">0x00000000dcb80000</span>)</span><br><span class="line">  from space <span class="number">4608</span>K, <span class="number">0</span>% used [<span class="number">0x00000000dcb80000</span>,<span class="number">0x00000000dcb80000</span>,<span class="number">0x00000000dd000000</span>)</span><br><span class="line">  to   space <span class="number">4608</span>K, <span class="number">0</span>% used [<span class="number">0x00000000dd000000</span>,<span class="number">0x00000000dd000000</span>,<span class="number">0x00000000dd480000</span>)</span><br><span class="line"> ParOldGen       total <span class="number">76800</span>K, used <span class="number">614</span>K [<span class="number">0x0000000090e00000</span>, <span class="number">0x0000000095900000</span>, <span class="number">0x00000000daf80000</span>)</span><br><span class="line">  object space <span class="number">76800</span>K, <span class="number">0</span>% used [<span class="number">0x0000000090e00000</span>,<span class="number">0x0000000090e99838</span>,<span class="number">0x0000000095900000</span>)</span><br><span class="line"> Metaspace       used <span class="number">3204</span>K, capacity <span class="number">4496</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 347<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p>在JDK9之后使用 -Xlog:gc+heap=debug</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0.017</span>s][info][gc,heap] Heap region size: <span class="number">1</span>M</span><br><span class="line">[<span class="number">0.017</span>s][debug][gc,heap] Minimum heap <span class="number">8388608</span>  Initial heap <span class="number">117440512</span>  Maximum heap <span class="number">1864368128</span></span><br><span class="line">[<span class="number">0.091</span>s][debug][gc,heap] GC(<span class="number">0</span>) Heap before GC invocations=<span class="number">0</span> (full <span class="number">0</span>): garbage-first heap   total <span class="number">114688</span>K, used <span class="number">7168</span>K [<span class="number">0x0000000090e00000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">[<span class="number">0.091</span>s][debug][gc,heap] GC(<span class="number">0</span>)   region size <span class="number">1024</span>K, <span class="number">2</span> young (<span class="number">2048</span>K), <span class="number">0</span> survivors (<span class="number">0</span>K)</span><br><span class="line">[<span class="number">0.091</span>s][debug][gc,heap] GC(<span class="number">0</span>)  Metaspace       used <span class="number">334</span>K, capacity <span class="number">4494</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line">[<span class="number">0.091</span>s][debug][gc,heap] GC(<span class="number">0</span>)   <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 21<span class="title">K</span>, <span class="title">capacity</span> 386<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line">[0.095s][info ][gc,heap] GC(0) Eden regions: 2-&gt;0(2)</span><br><span class="line">[<span class="number">0.095</span>s][info ][gc,heap] GC(<span class="number">0</span>) Survivor regions: <span class="number">0</span>-&gt;<span class="number">0</span>(<span class="number">0</span>)</span><br><span class="line">[<span class="number">0.095</span>s][info ][gc,heap] GC(<span class="number">0</span>) Old regions: <span class="number">0</span>-&gt;<span class="number">2</span></span><br><span class="line">[<span class="number">0.095</span>s][info ][gc,heap] GC(<span class="number">0</span>) Archive regions: <span class="number">0</span>-&gt;<span class="number">0</span></span><br><span class="line">[<span class="number">0.095</span>s][info ][gc,heap] GC(<span class="number">0</span>) Humongous regions: <span class="number">6</span>-&gt;<span class="number">0</span></span><br><span class="line">[<span class="number">0.095</span>s][debug][gc,heap] GC(<span class="number">0</span>) Heap after GC invocations=<span class="number">1</span> (full <span class="number">1</span>): garbage-first heap   total <span class="number">8192</span>K, used <span class="number">745</span>K [<span class="number">0x0000000090e00000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">[<span class="number">0.095</span>s][debug][gc,heap] GC(<span class="number">0</span>)   region size <span class="number">1024</span>K, <span class="number">0</span> young (<span class="number">0</span>K), <span class="number">0</span> survivors (<span class="number">0</span>K)</span><br><span class="line">[<span class="number">0.095</span>s][debug][gc,heap] GC(<span class="number">0</span>)  Metaspace       used <span class="number">334</span>K, capacity <span class="number">4494</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line">[<span class="number">0.095</span>s][debug][gc,heap] GC(<span class="number">0</span>)   <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 21<span class="title">K</span>, <span class="title">capacity</span> 386<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure><h4 id="查看并发时间以及停顿时间"><a href="#查看并发时间以及停顿时间" class="headerlink" title="查看并发时间以及停顿时间"></a>查看并发时间以及停顿时间</h4><p>JDK9之前使用 -XX:+PrintGCApplicationConcurrentTime 或-XX:+PrintGCApplicationStoppedTime</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Application time: <span class="number">0.0037062</span> seconds</span><br><span class="line">Application time: <span class="number">0.0004107</span> seconds</span><br></pre></td></tr></table></figure><p>JDK9以及之后使用 -Xlog:safepoint</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0.069</span>s][info][safepoint] Safepoint <span class="string">"EnableBiasedLocking"</span>, Time since last: <span class="number">42245400</span> ns, Reaching safepoint: <span class="number">71800</span> ns, At safepoint: <span class="number">47700</span> ns, Total: <span class="number">119500</span> ns</span><br><span class="line">[<span class="number">0.076</span>s][info][safepoint] Safepoint <span class="string">"RevokeBias"</span>, Time since last: <span class="number">6808300</span> ns, Reaching safepoint: <span class="number">71400</span> ns, At safepoint: <span class="number">85600</span> ns, Total: <span class="number">157000</span> ns</span><br><span class="line">[<span class="number">0.084</span>s][info][safepoint] Safepoint <span class="string">"Deoptimize"</span>, Time since last: <span class="number">7844900</span> ns, Reaching safepoint: <span class="number">57900</span> ns, At safepoint: <span class="number">28000</span> ns, Total: <span class="number">85900</span> ns</span><br><span class="line">[<span class="number">0.096</span>s][info][safepoint] Safepoint <span class="string">"G1CollectFull"</span>, Time since last: <span class="number">7976700</span> ns, Reaching safepoint: <span class="number">48500</span> ns, At safepoint: <span class="number">4234200</span> ns, Total: <span class="number">4282700</span> ns</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap原理</title>
      <link href="/2020/01/11/ConcurrentHashMap%E5%8E%9F%E7%90%86/"/>
      <url>/2020/01/11/ConcurrentHashMap%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="ConcurrentHashMap原理"><a href="#ConcurrentHashMap原理" class="headerlink" title="ConcurrentHashMap原理"></a>ConcurrentHashMap原理</h3><p>ConcurrentHashMap指的是一个线程安全的HashMap，并且ConcurrentHashMap比起HashTable，拥有这着更高的效率。ConcurrentHashMap更多的时候，是用来代替HahsMap在多线程下进行生产活动。</p><h4 id="HashMap线程不安全"><a href="#HashMap线程不安全" class="headerlink" title="HashMap线程不安全"></a>HashMap线程不安全</h4><p>要先说为什么HashMap线程不安全，主要有两个原因。</p><p>1、put的时候导致的多线程数据不一致。<br> 这个问题比较好想象，比如有两个线程A和B，首先A希望插入一个key-value对到HashMap中，首先计算记录所要落到的桶的索引坐标，然后获取到该桶里面的链表头结点，此时线程A的时间片用完了，而此时线程B被调度得以执行，和线程A一样执行，只不过线程B成功将记录插到了桶里面，假设线程A插入的记录计算出来的桶索引和线程B要插入的记录计算出来的桶索引是一样的，那么当线程B成功插入之后，线程A再次被调度运行时，它依然持有过期的链表头但是它对此一无所知，以至于它认为它应该这样做，如此一来就覆盖了线程B插入的记录，这样线程B插入的记录就凭空消失了，造成了数据不一致的行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/hashmap/hashmap11.png" alt="put"></p><p>2、另外一个比较明显的线程不安全的问题是HashMap的get操作可能因为resize而引起死循环（cpu100%），具体分析如下：</p><p>下面的代码是resize的核心内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这个方法的功能是将原来的记录重新计算在新桶的位置，然后迁移过去。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/hashmap/hashmap12.jpg" alt="hashmapresize"></p><p>我们假设有两个线程同时需要执行resize操作，我们原来的桶数量为2，记录数为3，需要resize桶到4，原来的记录分别为：[3,A],[7,B],[5,C]，在原来的map里面，我们发现这三个entry都落到了第二个桶里面。</p><p> 假设线程thread1执行到了resize方法的：next = e.next; 这一句，然后时间片用完了，此时的e = [3,A], next = [7,B]。线程thread2被调度执行并且顺利完成了resize操作，需要注意的是，此时的[7,B]的next为[3,A]。</p><p>此时线程thread1重新被调度运行，此时的thread1持有的引用是已经被thread2 resize之后的结果。线程thread1首先将[3,A]迁移到新的数组上，然后再处理[7,B]，而[7,B]被链接到了[3,A]的后面，处理完[7,B]之后，就需要处理[7,B]的next了啊，而通过thread2的resize之后，[7,B]的next变为了[3,A]，此时，[3,A]和[7,B]形成了环形链表，在get的时候，如果get的key的桶索引和[3,A]和[7,B]一样，那么就会陷入死循环。</p><p>如果在取链表的时候从头开始取（现在是从尾部开始取）的话，则可以保证节点之间的顺序，那样就不存在这样的问题了。</p><p>综合上面两点，可以说明HashMap是线程不安全的。</p><h4 id="ConcurrentHashMap做出的改变"><a href="#ConcurrentHashMap做出的改变" class="headerlink" title="ConcurrentHashMap做出的改变"></a>ConcurrentHashMap做出的改变</h4><p>前面也说过，ConcurrentHashMap可以看作为是一个线程安全的HahsMap，在这个前提下，ConcurrentHashMap本身的数据结构和HashMap并没有什么太大的不同，只是在每个数组(或叫做entry、bucket)，采用CAS和synchronized来保证并发安全。synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/hashmap/hashmap14.jpg" alt=""></p><h5 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h5><p>put方法做出了少许改变，毕竟导致hashmap线程不安全的原因之一就是put方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    static final int spread(int h) &#123;</span></span><br><span class="line"><span class="comment">    return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>, <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">//添加到空节点时无锁</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i,</span></span><br><span class="line"><span class="comment">                                        Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123;</span></span><br><span class="line"><span class="comment">        return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">       <span class="comment">// ...省略部分代码，放到后面讲</span></span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以根据之前hashmap的解析当中看到，这个put方法在计算hash值的方法是传入到了putval当中进行的，并且在进行添添加节点的时候，进行了CAS操作，来保障hashmap的线程安全。CAS操作之前也讲过，就是在进行交换值的时候，如果已经存在了交换关系，则进行自旋再次尝试。当然，如果 CAS 成功，说明 Node 节点已经插入，随后 addCount(1L, binCount) 方法会检查当前容量是否需要进行扩容。</p><p>这里有一个f值，这个putval方法就是根据这个节点的信息去判断接下来该如何行动的。</p><p>如果 f 为 null，说明 table 中这个位置第一次插入元素，利用Unsafe.compareAndSwapObject 方法插入 Node 节点。</p><p>如果f的 hash 值为 -1，说明当前 f 是 ForwardingNode 节点，意味有其它线程正在扩容，则一起进行扩容操作。</p><p>其余情况把新的 Node 节点按链表或红黑树的方式插入到合适的位置，这个过程采用同步内置锁实现并发，代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            binCount = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                K ek;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == key ||</span><br><span class="line">                     (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                    oldVal = e.val;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                        e.val = value;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                              value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">            Node&lt;K,V&gt; p;</span><br><span class="line">            binCount = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                           value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldVal = p.val;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                    p.val = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在节点 f 上进行同步，节点插入之前，再次利用<code>tabAt(tab, i) == f</code>判断，防止被其它线程修改。</p><p>如果 f.hash &gt;= 0，说明 f 是链表结构的头结点，遍历链表，如果找到对应的 node 节点，则修改 value，否则在链表尾部加入节点。 如果 f 是 TreeBin 类型节点，说明 f 是红黑树根节点，则在树结构上遍历元素，更新或增加节点。 如果链表中节点数 binCount &gt;= TREEIFY_THRESHOLD(默认是8)，则把链表转化为红黑树结构。</p><h5 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h5><p>ConcurrentHashMap的扩容方法叫做addCount()，当数组不够的时候，便会触发扩容操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//省略。。。</span></span><br><span class="line">        <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">            <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                   (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">                <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                        sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                        transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                        transfer(tab, nt);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                             (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                    transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">                s = sumCount();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在扩容数组的过程中，通过 Unsafe.compareAndSwapInt 修改 sizeCtl 值，保证只有一个线程能够初始化 nextTable，节点从 table 移动到 nextTable，大体思想是遍历、复制的过程。</p><p>首先根据运算得到需要遍历的次数i，然后利用 tabAt 方法获得 i 位置的元素 f，初始化一个 forwardNode 实例 fwd。</p><p>如果 f == null，则在 table 中的 i 位置放入 fwd，这个过程是采用 Unsafe.compareAndSwapObjectf 方法实现的，很巧妙的实现了节点的并发移动。</p><p>如果 f 是链表的头节点，就构造一个反序链表，把他们分别放在 nextTable 的 i 和 i+n 的位置上，移动完成，采用 Unsafe.putObjectVolatile 方法给 table 原位置赋值 fwd。 如果 f 是 TreeBin 节点，也做一个反序处理，并判断是否需要 untreeify，把处理的结果分别放在 nextTable 的 i 和 i+n 的位置上，移动完成，同样采用 Unsafe.putObjectVolatile 方法给 table 原位置赋值 fwd。 遍历过所有的节点以后就完成了复制工作，把 table 指向 nextTable，并更新 sizeCtl 为新数组大小的 0.75 倍 ，扩容完成。</p><h5 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h5><p>get方法是读取map里面的值，并没有做出结果性的修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="size-方法"><a href="#size-方法" class="headerlink" title="size()方法"></a>size()方法</h5><p>在JDK8的ConcurrentHashMap中，size方法有了很大的改观。它不再是像HashMap一样是一个类的静态字段了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">            (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (<span class="keyword">int</span>)n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现实际上使用的是sumCount方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcurrentHashMap 提供了 baseCount、counterCells 两个辅助变量和一个 CounterCell 辅助内部类。通过迭代 counterCells 来统计 sum 的过程。而这个counterCells的计算，实际上在putVal方法中，也有说明，是使用CAS去完成的。JDK8的size 是通过对 baseCount 和 counterCell 进行 CAS 计算，最终通过 baseCount 和 遍历 CounterCell 数组得出 size。</p><h4 id="JDK7和JDK8的ConcurrentHashMap"><a href="#JDK7和JDK8的ConcurrentHashMap" class="headerlink" title="JDK7和JDK8的ConcurrentHashMap"></a>JDK7和JDK8的ConcurrentHashMap</h4><p>或许很多人在看之前的对ConcurrentHashMap介绍中，都提到了segment这个词，但实际上在JDK8版本中，便取消了这个做法。因为在使用segment的时候，虽然也能包保持线程的安全，但随着ConcurrentHashMapd容量的增大，ssegment的并发性并没有什么提高，而改用CAS和synchronized的方式去保持线程安全，在ConcurrentHashMap容量增大的同时，也提高了锁的细化，让ConcurrentHashMap更接近于HahsMap了。</p><p>其次是synchronized的升级，让它能够拥有更好的性能，去代替segment的ReentrantLock。</p><p>最后是红黑树的引入，这里先不对此做过多解释。</p>]]></content>
      
      
      
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap原理</title>
      <link href="/2020/01/10/HashMap%E5%8E%9F%E7%90%86/"/>
      <url>/2020/01/10/HashMap%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="HashMap原理"><a href="#HashMap原理" class="headerlink" title="HashMap原理"></a>HashMap原理</h3><h4 id="HashMap怎么使用"><a href="#HashMap怎么使用" class="headerlink" title="HashMap怎么使用"></a>HashMap怎么使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,String&gt; map=<span class="keyword">new</span> HashMap&lt;Integer,String&gt; (<span class="number">16</span>);</span><br><span class="line">        System.out.println(<span class="string">"map加入值"</span>);</span><br><span class="line">        map.put(<span class="number">1</span>,<span class="string">"q"</span>);</span><br><span class="line">        map.put(<span class="number">2</span>,<span class="string">"w"</span>);</span><br><span class="line">        map.put(<span class="number">3</span>,<span class="string">"e"</span>);</span><br><span class="line">        System.out.println(<span class="string">"判断该键是否存在:"</span>+map.containsKey(<span class="number">4</span>));</span><br><span class="line">        System.out.println(<span class="string">"获取该键的值:"</span>+map.get(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">"map的大小："</span>+map.size());</span><br><span class="line">        System.out.println(<span class="string">"判断是否相等："</span>+<span class="string">"q"</span>.equals(map.get(<span class="number">1</span>)));</span><br><span class="line">        <span class="keyword">for</span> (String a: map.values()) &#123;</span><br><span class="line">            System.out.print(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">map加入值</span></span><br><span class="line"><span class="comment">判断该键是否存在:false</span></span><br><span class="line"><span class="comment">获取该键的值:q</span></span><br><span class="line"><span class="comment">map的大小：3</span></span><br><span class="line"><span class="comment">判断是否相等：true</span></span><br><span class="line"><span class="comment">qwe</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>HashMap的使用比较直观，可以粗略的把HashMap看做为一个数组去使用。</p><h4 id="HashMap的定义"><a href="#HashMap的定义" class="headerlink" title="HashMap的定义"></a>HashMap的定义</h4><p>从类的定义来看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>HashMap继承了抽象map类，实现了cloneable和Serializable接口。</p><p>HashMap的数据都存在一个entry数组里面，在HashMap有一个静态类去实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK7</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; next;</span><br><span class="line">        <span class="keyword">int</span> hash;</span><br><span class="line"><span class="comment">//JDK8</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br></pre></td></tr></table></figure><p>可以看到无论是JDK7还是JDK8，都定义了两种值，key和value，我们存入的数据，都是存入在这数组之中，而且还定义了一个next，next就像是链表一样，用于指向下一个值。所以table中存储的是Entry的单向链表。默认参数的HashMap结构如下图所示：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/hashmap/hashmapyl2.jpg" alt="hashmap2"></p><p>所以，可以把它看作为是一个数组，然后每个数组都由链表组成。</p><h4 id="HashMap的构造方法"><a href="#HashMap的构造方法" class="headerlink" title="HashMap的构造方法"></a>HashMap的构造方法</h4><p>HashMap一共有四个构造方法，这里只看一下默认的构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//这里调用了this</span></span><br><span class="line"><span class="comment">//DEFAULT_LOAD_FACTOR是一个负载因子，默认为0.75</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="comment">//传入的大小小于0，抛出异常 </span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="comment">//传入的值大于最大值，将其变为等于最大值</span></span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="comment">//加载负载因子</span></span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tableSizeFor是用来纠正传入的大小的</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>哈希桶数组会在首次使用时初始化，默认大小是 16，并根据需要调整大小，且长度总是 2 的次幂。如果构造函数设置的初始容量不是 2 的次幂，那么使用tableSizeFor方法，来设置一个大于且靠近它的 2 的次幂的值。</p><p>影响 HashMap 性能的主要参数是：<strong>初始容量</strong>和<strong>负载因子</strong>。当散列表元素数超过负载因子和当前容量的乘积时（（initialCapacity * loadFactor）。），就会扩容，扩大到原来容量的<strong>两倍</strong>，并对键重新散列。</p><p>HashMap 内部的其他字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 键值对的数量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">// 记录结构修改次数，用于迭代时的快速失败</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"><span class="comment">// 负载因子，默认 0.75f</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="comment">// 扩容的下一个容量值，也就是键值对个数的最大值，它等于(capacity * loadFactor)</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br></pre></td></tr></table></figure><h4 id="HashMap的put-方法"><a href="#HashMap的put-方法" class="headerlink" title="HashMap的put()方法"></a>HashMap的put()方法</h4><p>put方式是我们在使用HashMap中经常使用的方法，所以要好好研究。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们在使用put方法的时候，实际是使用一个putVal方法。而在这个putVal方法中，会将key值先进行hash运算，得到hash码。</p><h5 id="hash-方法"><a href="#hash-方法" class="headerlink" title="hash()方法"></a>hash()方法</h5><p>这个hash方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果key值为null的时候，就返回hash码为0。但如果不为null呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br></pre></td></tr></table></figure><p>这个会是什么意思呢？这段代码叫“<strong>扰动函数</strong>”。<strong>key.hashCode()</strong>函数调用的是key键值类型自带的哈希函数，返回int型散列值。这个求出hashcode的方法非常的复杂。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</span><br></pre></td></tr></table></figure><p>理论上散列值是一个int型，如果直接拿散列值作为下标访问HashMap主数组的话，考虑到2进制32位带符号的int表值范围从<strong>-2147483648</strong>到<strong>2147483648</strong>。前后加起来大概40亿的映射空间。只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。</p><p>但问题是一个40亿长度的数组，内存是放不下的。你想，HashMap扩容之前的数组初始大小才16。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来访问数组下标。</p><p>而这个对数组的长度取模运算的操作，正好解释了<strong>为什么HashMap的数组长度要取2的整次幂。因为这样（数组长度-1 ）正好相当于一个“低位掩码”。</strong></p><p>但这时候问题就来了，这样就算我的散列值分布再松散，要是只取最后几位的话，碰撞也会很严重。更要命的是如果散列本身做得不好，分布上成等差数列的漏洞，恰好使最后几个低位呈现规律性重复，就无比蛋疼。</p><p>这时候“<strong>扰动函数</strong>”的价值就体现出来了：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/hashmap/hashmap4.jpg" alt="raodong"></p><p>右位移16位，正好是32bit的一半，自己的高半区和低半区做异或，就是为了<strong>混合原始哈希码的高位和低位，以此来加大低位的随机性</strong>。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。</p><p>此时的key值先求出hash值，再经过扰动函数之后，得出来的hash值的重复率就大大的降低了。而对数组的长度取模运算的操作，发生在putVal()方法当中。</p><h5 id="putVal-方法"><a href="#putVal-方法" class="headerlink" title="putVal()方法"></a>putVal()方法</h5><p>我们可以从源码上得之，使用put方法，实际上是在使用putVal方法，那我们来解析一下吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 将 key 的 hashCode 散列</span></span><br><span class="line">  <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//1.如果table 为 null，初始化哈希桶数组</span></span><br><span class="line">    <span class="comment">//此时的n就被初始化，赋值为hashmap的大小,即n=length</span></span><br><span class="line">    <span class="comment">//resize()方法后面会提</span></span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">      <span class="comment">//2.计算数组的下标(n - 1) &amp; hash</span></span><br><span class="line">      <span class="comment">//这其实就是mod取余的一种替换方式，相当于hash%(n-1)</span></span><br><span class="line">      <span class="comment">//&amp;是位运算，效率要高于%。至于为什么是跟n-1进行&amp;的位运算，是因为n为2的幂次方，即一定是偶数，偶数减1，即是奇数，这样保证了（n-1）在二进制中最低位是1，而&amp;运算结果的最低位是1还是0完全取决于hash值二进制的最低位。如果n为奇数，则n-1则为偶数，则n-1二进制的最低位横为0，则&amp;位运算的结果最低位横为0，即横为偶数。这样table数组就只可能在偶数下标的位置存储了数据，浪费了所有奇数下标的位置，这样也更容易产生hash冲突。这也是HashMap的容量为什么总是2的平方数的原因。</span></span><br><span class="line"></span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 3. 这个槽还没有插入过数据，直接插入</span></span><br><span class="line">     <span class="comment">// 这里的p结点是根据hash值算出来对应在数组中的元素</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e; K k;</span><br><span class="line">    <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">      e = p;</span><br><span class="line">    <span class="comment">// 4. else表示节点 key 存在，使用链表去连接前一个值，此后这个key返回的value值变成新值</span></span><br><span class="line">           </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 在树中插入</span></span><br><span class="line">      e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">       <span class="comment">// 5. 该链的链长如果大于8，则转成了红黑树进行存储</span></span><br><span class="line">      </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 6. esle表示该链是链表 </span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">          p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 遍历找到尾节点插入</span></span><br><span class="line">          <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">            treeifyBin(tab, hash);</span><br><span class="line">            <span class="comment">// 链表长度大于 8 转为红黑树</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        p = e;</span><br><span class="line">          <span class="comment">// 遍历的过程中，遇到相同 key 则覆盖 value</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">//现有键映射</span></span><br><span class="line">      V oldValue = e.value;</span><br><span class="line">      <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 判断是否允许覆盖，并且value是否为空</span></span><br><span class="line">        e.value = value;</span><br><span class="line">      afterNodeAccess(e);<span class="comment">// 回调以允许LinkedHashMap后置操作</span></span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ++modCount;  <span class="comment">// 更改操作次数</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">      <span class="comment">// 大于临界值</span></span><br><span class="line"> <span class="comment">// 将数组大小设置为原来的2倍，并将原先的数组中的元素放到新数组中</span></span><br><span class="line">        <span class="comment">// 因为有链表，红黑树之类，因此还要调整他们</span></span><br><span class="line">    resize();</span><br><span class="line">     <span class="comment">// 7. 超过最大容量，扩容</span></span><br><span class="line">  afterNodeInsertion(evict);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//JDK8 在插入链表时采用的是尾插入法，也就是顺序插入，而 JDK7 使用的是头插法，逆序插入。</span></span><br></pre></td></tr></table></figure><p>PutVal方法中，会对Hash码和hashmap的长度-1做与运算，这样的运算方式比取余更为快速。从而得到的最后结果就是元素存放的地点。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/hashmap/hashmap5.jpg" alt="putval"></p><h4 id="HashMap的扩容：resize"><a href="#HashMap的扩容：resize" class="headerlink" title="HashMap的扩容：resize()"></a>HashMap的扩容：resize()</h4><h5 id="JDK8的优化扩容机制"><a href="#JDK8的优化扩容机制" class="headerlink" title="JDK8的优化扩容机制"></a>JDK8的优化扩容机制</h5><p>每次在空的数组中存放元素成功，就会执行++size操作，当元素存储的大小大于threshold，即大于整个数组的0.75倍时，就会触发扩容操作，把整个数组扩容成原来大小的<strong>两倍</strong>。因为使用的是<strong>2的次幂扩展</strong>，那么元素的位置要么保持不变，要么在原位置上偏移2的次幂。</p><p>看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/hashmap/hahsmap8.png" alt="扩容"></p><p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/hashmap/hashmap9.png" alt="扩容2"></p><p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/hashmap/hashmap10.png" alt="扩容3"></p><p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。</p><p>我们接下来看看JDK8的resize()的源码实现吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">  Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">  <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">  <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">  <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 超过最大值，不在扩容</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">      threshold = Integer.MAX_VALUE;</span><br><span class="line">      <span class="keyword">return</span> oldTab;</span><br><span class="line">    &#125;<span class="comment">// 否则扩大为原来的 2 倍</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">           oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">      newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// 双倍的阈值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 初始容量置于阈值</span></span><br><span class="line">    <span class="comment">// 初始化时，threshold 暂时保存 initialCapacity 参数的值</span></span><br><span class="line">    newCap = oldThr;</span><br><span class="line">  <span class="keyword">else</span> &#123;               <span class="comment">// 零初始阈值表示使用默认值</span></span><br><span class="line">    newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 计算新的 resize 上限</span></span><br><span class="line">  <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">      newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">  threshold = newThr;</span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">  table = newTab;</span><br><span class="line">  <span class="comment">// 将旧的键值对移动到新的哈希桶数组中</span></span><br><span class="line">  <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">      Node&lt;K,V&gt; e;</span><br><span class="line">      <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (e.next == <span class="keyword">null</span>) <span class="comment">// 无链条</span></span><br><span class="line">          newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">          <span class="comment">// 拆红黑树，先拆成两个子链表，再分别按需转成红黑树</span></span><br><span class="line">          ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">          <span class="comment">// 拆链表，拆成两个子链表并保持原有顺序，在重新计算链表中元素位置时，只可能得到两个子链表：索引不变的元素链表和有相同偏移量的元素链表。</span></span><br><span class="line">          Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">          Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">          Node&lt;K,V&gt; next;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">            next = e.next;</span><br><span class="line">            <span class="comment">// 原位置不变的子链表</span></span><br><span class="line">            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">              loTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 原位置偏移 oldCap 的子链表</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">              hiTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">          <span class="comment">// 放到新的哈希桶中</span></span><br><span class="line">          <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">            newTab[j] = loHead;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">            newTab[j + oldCap] = hiHead;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;<span class="comment">//红黑树之所以能够按照链表的逻辑拆分，是因为链表在转红黑树时，保留了原链表的链条引用，这样也方便了遍历操作。</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="链表转红黑树"><a href="#链表转红黑树" class="headerlink" title="链表转红黑树"></a>链表转红黑树</h5><p>链表转红黑树主要做了以下几件事：</p><ol><li>判断桶容量是否达到树化的最低要求，否则进行扩容</li><li>将原链表转为由 TreeNode 组成的双向链表</li><li>将新链表转为红黑树</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">  <span class="comment">// 如果哈希桶容量小于树化的最小容量，优先进行扩容</span></span><br><span class="line">  <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">    resize();</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123; <span class="comment">// 将普通节点转为树形节点</span></span><br><span class="line">      TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">        hd = p;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        p.prev = tl;</span><br><span class="line">        tl.next = p;</span><br><span class="line">      &#125;</span><br><span class="line">      tl = p;</span><br><span class="line">      <span class="comment">// 把原来的单链表转成了双向链表</span></span><br><span class="line">    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">      hd.treeify(tab); <span class="comment">// 将链表转为红黑树</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap 在设计时应该没有考虑后期会引入红黑树，所以没有提供 key 的比较器或要求 key 实现 Comparable 接口。为了比较两个 key 的大小，HashMap 按以下步骤处理：</p><ol><li>如果两个 key 的 hash 值不等，则比较 hash 值大小</li><li>如果相等，若 key 实现了 Comparable 接口，使用 compareTo 方法比较</li><li>如果结果还是相等，使用自定义的 tieBreakOrder 方法比较，逻辑如下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tieBreakOrder</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> d;</span><br><span class="line">  <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span> || <span class="comment">// 比较 className 的大小</span></span><br><span class="line">    (d = a.getClass().getName().compareTo(b.getClass().getName())) == <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 比较由本地方法生成的 hash 值大小，仍然有可能冲突，几率太小，此时认为是小于的结果</span></span><br><span class="line">    d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ? -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="优化总结"><a href="#优化总结" class="headerlink" title="优化总结"></a>优化总结</h5><p>JDK8 中的 HashMap 代码还是比较复杂的，优化方面主要有以下三点：</p><ul><li>优化 hash 算法只进行一次位移操作</li><li>引入红黑树，在冲突比较严重的情况下，将 get 操作的时间复杂从 O(n) 降为了 O(logn)</li><li>扩容时，利用 2 的次幂数值的二进制特点，既省去重新计算 hash 的时间，又把之前冲突的节点散列到了其他位置</li></ul><p>此外，HashMap 是<strong>非线程安全</strong>的，线程间的<strong>竞争条件</strong>主要是发生冲突或扩容时，链表的断链和续链操作。扩容也就意味着内存拷贝，这是一个很耗费性能的操作，所以预分配一个足够大的初始容量，减少扩容的次数，能够让 HashMap 有更好的表现。</p><h4 id="HashMap的get-方法"><a href="#HashMap的get-方法" class="headerlink" title="HashMap的get()方法"></a>HashMap的get()方法</h4><p>get()方法也是在HashMap一种较为常用的方法，我们来看看它是怎么回事吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">//计算存放在数组table中的位置.具体计算方法上面也已经介绍了</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//先查找是不是就是数组中的元素</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">//该位置为红黑树根节点或者链表头结点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果first为红黑树结点，就在红黑树中遍历查找</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">//不是树结点，就在链表中遍历查找</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据key算出hash值定位到哈希桶的索引，当可以就是当前索引的值则直接返回其对于的value，反之用key去遍历equal该索引下的key，直到找到位置。如图所示：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/hashmap/hashmap6.jpg" alt="get"></p><h4 id="HashMap的remove-方法"><a href="#HashMap的remove-方法" class="headerlink" title="HashMap的remove()方法"></a>HashMap的remove()方法</h4><p>最后还有一个基本的方法，那就是remove方法了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个remove方法实际上调用的是removeNode方法，而它的参数和putVal方法中非常的类似。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index; <span class="comment">// 声明节点数组、当前节点、数组长度、索引值</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果 节点数组tab不为空、数组长度n大于0、根据hash定位到的节点对象p（该节点为 树的根节点 或 链表的首节点）不为空</span></span><br><span class="line"><span class="comment">     * 需要从该节点p向下遍历，找到那个和key匹配的节点对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v; <span class="comment">// 定义要返回的节点对象，声明一个临时节点变量、键变量、值变量</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 如果当前节点的键和key相等，那么当前节点就是要删除的节点，赋值给node</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 到这一步说明首节点没有匹配上，那么检查下是否有next节点</span></span><br><span class="line"><span class="comment">         * 如果没有next节点，就说明该节点所在位置上没有发生hash碰撞, 就一个节点并且还没匹配上，也就没得删了，最终也就返回null了</span></span><br><span class="line"><span class="comment">         * 如果存在next节点，就说明该数组位置上发生了hash碰撞，此时可能存在一个链表，也可能是一颗红黑树</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果当前节点是TreeNode类型，说明已经是一个红黑树，那么调用getTreeNode方法从树结构中查找满足条件的节点</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 如果不是树节点，那么就是一个链表，只需要从头到尾逐个节点比对即可    </span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果e节点的键是否和key相等，e节点就是要删除的节点，赋值给node变量，调出循环</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                            (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                    <span class="comment">// 走到这里，说明e也没有匹配上</span></span><br><span class="line">                    p = e; <span class="comment">// 把当前节点p指向e，这一步是让p存储的永远下一次循环里e的父节点，如果下一次e匹配上了，那么p就是node的父节点</span></span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>); <span class="comment">// 如果e存在下一个节点，那么继续去匹配下一个节点。直到匹配到某个节点跳出 或者 遍历完链表所有节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果node不为空，说明根据key匹配到了要删除的节点</span></span><br><span class="line"><span class="comment">         * 如果不需要对比value值  或者  需要对比value值但是value值也相等</span></span><br><span class="line"><span class="comment">         * 那么就可以删除该node节点了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 如果该节点是个TreeNode对象，说明此节点存在于红黑树结构中，调用removeTreeNode方法（该方法单独解析）移除该节点</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p) <span class="comment">// 如果该节点不是TreeNode对象，node == p 的意思是该node节点就是首节点</span></span><br><span class="line">                tab[index] = node.next; <span class="comment">// 由于删除的是首节点，那么直接将节点数组对应位置指向到第二个节点即可</span></span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 如果node节点不是首节点，此时p是node的父节点，由于要删除node，所有只需要把p的下一个节点指向到node的下一个节点即可把node从链表中删除了</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount; <span class="comment">// HashMap的修改次数递增</span></span><br><span class="line">            --size; <span class="comment">// HashMap的元素个数递减</span></span><br><span class="line">            afterNodeRemoval(node); <span class="comment">// 调用afterNodeRemoval方法，该方法HashMap没有任何实现逻辑，目的是为了让子类根据需要自行覆写</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除操作就是一个查找+删除的过程，它的步骤也很简单，就先根据hashcode值，找到bucket的位置，找到位置之后，在节点中根据key的值，找到对应的value。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>HashMap是基于哈希表实现的，用Entry[]来存储数据，而Entry中封装了key、value、hash以及Entry类型的next</li><li>HashMap存储数据是无序的</li><li>hash冲突是通过拉链法解决的</li><li>HashMap的容量永远为2的幂次方，有利于哈希表的散列</li><li>HashMap不支持存储多个相同的key，且只保存一个key为null的值，多个会覆盖</li><li>put过程，是先通过key算出hash，然后用hash算出应该存储在table中的index，然后遍历table[index]，看是否有相同的key存在，存在，则更新value；不存在则插入到table[index]单向链表的表头，时间复杂度为O(n)</li><li>get过程，通过key算出hash，然后用hash算出应该存储在table中的index，然后遍历table[index]，然后比对key，找到相同的key，则取出其value，时间复杂度为O(n)</li></ol><h4 id="方法摘要"><a href="#方法摘要" class="headerlink" title="方法摘要"></a>方法摘要</h4><p> void    clear()<br>          从此映射中移除所有映射关系。<br> Object    clone()<br>          返回此 HashMap 实例的浅表副本：并不复制键和值本身。<br> boolean    containsKey(Object key)<br>          如果此映射包含对于指定键的映射关系，则返回 true。<br> boolean    containsValue(Object value)<br>          如果此映射将一个或多个键映射到指定值，则返回 true。<br> Set&lt;Map.Entry&lt;K,V&gt;&gt;    entrySet()<br>          返回此映射所包含的映射关系的 Set 视图。<br> V    get(Object key)<br>          返回指定键所映射的值；如果对于该键来说，此映射不包含任何映射关系，则返回 null。<br> boolean    isEmpty()<br>          如果此映射不包含键-值映射关系，则返回 true。<br> Set<K>    keySet()<br>          返回此映射中所包含的键的 Set 视图。<br> V    put(K key, V value)<br>          在此映射中关联指定值与指定键。<br> void    putAll(Map&lt;? extends K,? extends V&gt; m)<br>          将指定映射的所有映射关系复制到此映射中，这些映射关系将替换此映射目前针对指定映射中所有键的所有映射关系。<br> V    remove(Object key)<br>          从此映射中移除指定键的映射关系（如果存在）。<br> int    size()<br>          返回此映射中的键-值映射关系数。<br> Collection<V>    values()<br>          返回此映射所包含的值的 Collection 视图。</p>]]></content>
      
      
      
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS队列同步器</title>
      <link href="/2020/01/09/AQS%E5%90%8C%E6%AD%A5%E5%99%A8/"/>
      <url>/2020/01/09/AQS%E5%90%8C%E6%AD%A5%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="队列同步器-AbstractQueuedSynchronizer"><a href="#队列同步器-AbstractQueuedSynchronizer" class="headerlink" title="队列同步器(AbstractQueuedSynchronizer)"></a>队列同步器(AbstractQueuedSynchronizer)</h3><p>队列同步器，是一个用来构建锁或者其他同步组件的基础框架,像之前提到的重入锁，读写锁，都是使用这个框架搭建起来的。它使用一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。</p><h4 id="队列同步器接口的方法"><a href="#队列同步器接口的方法" class="headerlink" title="队列同步器接口的方法"></a>队列同步器接口的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br></pre></td></tr></table></figure><p>以独占的方式获取同步状态，实现该方法需要查询当前状态并判断同步状态是否符合预期，然后再进行CAS操作设置同步状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br></pre></td></tr></table></figure><p>独占式释放同步状态，等待获取同步状态的线程将有机会获取同步状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br></pre></td></tr></table></figure><p>共享式获取同步状态，返回大于等于0的值，表示获取成功，反之失败</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br></pre></td></tr></table></figure><p>共享释放同步状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>当前同步器是否在独占模式下被线程占用，一般该方法表示是否被当前线程所独占，返回的是一个布尔值</p><h4 id="同步器的工作方式"><a href="#同步器的工作方式" class="headerlink" title="同步器的工作方式"></a>同步器的工作方式</h4><p>先举一个例子，制作一个同步锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.AbstractQueuedSynchronizer;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义同步器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">Sync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>,<span class="number">1</span>))&#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="comment">//当状态为0的时候获得锁</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (getState()==<span class="number">0</span>) &#123;<span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();&#125;</span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">                setState(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//释放锁，将状态设置为0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState()==<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//是否处于独占状态</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回一个Condition，每个Condition都包含一个Condition队列</span></span><br><span class="line">        <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将需要的操作代理到Sync上即可</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync=<span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//表示获得了锁，即上锁的意思</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>,unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.hasQueuedThreads();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类在继承了Lock接口后，继承各种锁的操作方法，然后在类的内部有一个静态类，静态类继承了AbstractQueuedSynchronizer类，通过重写类的方法，去设置锁的类型。该Mutex类在状态为0的时候可以申请获得锁，之后若处于被锁住的状态，就不能够被其他对象所获得，只有等待该对象解锁后，才能够被其他对象获得。</p><p>值得注意的是，锁的设置一般不直接去设置内部的同步器，而是通过一个类去调用方法的方式去使用内部同步器的API来实现相关的功能。这就是一般同步器的工作方式。</p><h4 id="队列同步器的实现原理"><a href="#队列同步器的实现原理" class="headerlink" title="队列同步器的实现原理"></a>队列同步器的实现原理</h4><p>队列同步器是如何完成线程同步的呢？</p><h5 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h5><p>之前有提到，同步器的内部有同步队列FIFO，FIFO是一个双向队列，这个队列的数据模型和一般的双向队列相似。每当有一个线程尝试去进行同步，但同步失败的时候，该线程就会被阻塞，且该线程当时的状态和信息就会构造成一个节点，并将其加入同步队列，只有当同步状态释放的时候，才会把首节点中线程唤醒，再次去尝试获取同步状态。同步队列使得线程之间的数据同步变的更加的有序。队列节点元素有4种类型， 每种类型表示线程被阻塞的原因，这四种类型分别是：</p><ul><li>CANCELLED : 表示该线程是因为超时或者中断原因而被放到队列中</li><li>CONDITION : 表示该线程是因为某个条件不满足而被放到队列中，需要等待一个条件，直到条件成立后才会出队</li><li>SIGNAL : 表示该线程需要被唤醒</li><li>PROPAGATE： 表示在共享模式下，当前节点执行释放release操作后，当前结点需要传播通知给后面所有节点</li></ul><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/aqs2.jpg" alt="aqs2"></p><h5 id="独占式同步状态的获取与释放"><a href="#独占式同步状态的获取与释放" class="headerlink" title="独占式同步状态的获取与释放"></a>独占式同步状态的获取与释放</h5><p>在同步器内部，可以通过调用同步器的acquire方法获取同步状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在同步器中，又会调用自定义的tryAcquire去判断当前是否获取了同步状态，若获取同步状态失败，则构造同步节点并通过addWaiter方法将该节点加入到同步队列尾部，在掉用acquireQueued使其死循环，不断地去尝试获得同步状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//把当前线程包装为node,设为独占模式</span></span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="comment">//如果tail不为空,把node插入末尾</span></span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="comment">//此时可能有其他线程插入,所以重新判断tail</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//若队列为空或者cas设置失败后，调用enq自旋再次设置</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="comment">//此时可能有其他线程插入,所以重新判断tail是否为空</span></span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果tail节点为空,执行enq(node);重新尝试,最终把node插入.在把node插入队列末尾后,它并不立即挂起该节点中线程,因为在插入它的过程中,前面的线程可能已经执行完成,所以它会先进行自旋操作acquireQueued(node, arg),尝试让该线程重新获取锁!当条件满足获取到了锁则可以从自旋过程中退出，否则继续。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="comment">//如果它的前继节点为头结点,尝试获取锁,获取成功则返回           </span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>AQS的模板方法acquire通过调用子类自定义实现的tryAcquire获取同步状态失败后-&gt;将线程构造成Node节点(addWaiter)-&gt;将Node节点添加到同步队列对尾(addWaiter)-&gt;节点以自旋的方法获取同步状态(acquirQueued)。在节点自旋获取同步状态时，只有其前驱节点是头节点的时候才会尝试获取同步状态，如果该节点的前驱不是头节点或者该节点的前驱节点是头节点但获取同步状态失败，则判断当前线程需要阻塞，如果需要阻塞则需要被唤醒过后才返回。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/aqs.jpg" alt="aqs"></p><p>那么接下来看看看独占式同步器是怎么释放的吧，在执行完相应的逻辑后，就需要释放同步状态，这时候就需要调用release方法了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 若释放同步状态成功</span></span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="comment">// 获取同步队列头节点</span></span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 唤醒头节点的后继节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前节点等待状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="comment">// 若状态为SIGNAL、CONDITION或PROPAGATE，CAS将其状态置为0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 获取后继节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 若后继节点为null或其状态为CANCELLED(等待超市或者被中断)</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 从尾结点遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 唤醒节点所关联的线程</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法在自定义方法准备好了之后，去把头结点向后移动一位，表示下一个节点也准备好了。从源码中可以发现唤醒的节点<strong>从尾遍历</strong>而不是从头遍历，原因是当前节点的后继可能为null、等待超时或被中断，所以从尾部向前进行遍。</p><h5 id="共享式同步状态的获取与释放"><a href="#共享式同步状态的获取与释放" class="headerlink" title="共享式同步状态的获取与释放"></a>共享式同步状态的获取与释放</h5><p>前面在介绍锁的时候，除了重入锁这种独占锁之外，还有像读写锁一样的共享锁，同步器身为最高位，当然也有相应的共享式同步状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将共享节点加入同步队列</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 中断标记</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 死循环</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 若前驱节点为头节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 获取同步</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">// 若获取成功</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断线程是否需要阻塞</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个共享式的方法，在一开始调用了tryAcquireShared(arg)方法尝试去获取同步状态，这个方法自然也是自定义的方法，且这个方法的返回值如果是大于或等于0，自然就能够获取同步状态。如果并非如此，就进行doAcquireShared方法，它会不断地自旋去尝试获取同步状态。对应的获得了同步状态后，也有相应的共享释放方法释放状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法在释放同步状态之后，将会唤醒后续处于等待状态的节点。</p><h5 id="独占式超时获取同步状态"><a href="#独占式超时获取同步状态" class="headerlink" title="独占式超时获取同步状态"></a>独占式超时获取同步状态</h5><p>在JDK5之前，当一个线程获取不到锁而被阻塞在synchronized之外时，对该线程进行终端操作，此时线程的中断标志位会被修改，但线程依旧会阻塞在synchronized上，等待获取锁。而早JDK5之中，同步器提供了一个acquireInterruptibly方法，这个方法在等待获取同步状态时，如果当前线程被中断，会立刻返回，并抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">     <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">         doAcquireInterruptibly(arg);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">     <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">             <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">             <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                 setHead(node);</span><br><span class="line">                 p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                 failed = <span class="keyword">false</span>;</span><br><span class="line">                 <span class="keyword">return</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                 parkAndCheckInterrupt())</span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (failed)</span><br><span class="line">             cancelAcquire(node);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>tryAcquireNanos()方法超时获取同步状态是响应中断获取同步状态的”增强版”，在doAcquireInterruptibly基础上增加了超时控制：主要是需要计算出睡眠的时间间隔nanosTimeout，在这个时间段内，如果获取到了同步状态则返回true，否则返回false，并进行异常处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">            doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 超时时间    </span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="comment">// 将独占节点</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 死循环自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 若前驱节点为头节点且获取同步状态成功</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若获取失败，判断是否超时</span></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="comment">// 判断线程是否中断    </span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nanosTimeout的计算公式为：nanosTimeout-=now(当前唤醒时间)-lastTime(上次唤醒时间)。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/aqs3.png" alt="aqs3"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> AQS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机（四）垃圾回收的机制和算法</title>
      <link href="/2020/01/05/Java%E8%99%9A%E6%8B%9F%E6%9C%BA4/"/>
      <url>/2020/01/05/Java%E8%99%9A%E6%8B%9F%E6%9C%BA4/</url>
      
        <content type="html"><![CDATA[<h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><p>Java虚拟机除了支持了Java的跨平台性之外，最重要的就是虚拟机能够自动进行内存的回收，它不像C++那样，需要析构函数之类的去分配和管理内存，同样的也没有指针这个神奇的玩意，在处理不会再被使用的对象时，Java虚拟机会自动帮我们完成内存的回收。而所谓的内存回收，就叫做GC，也可以叫做垃圾收集，了解如何去完成Java的内存回收，对于我们使用Java，是一件非常重要的事情。</p><h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>我想从最简单的开始去描述这一个事物，假如，你需要去判断一个对象是否要被回收，判断的依据是什么呢？一般来说，那就是以后都不会再去使用它了，所以它需要被回收，那么对于这种方式，是使用着什么的计算方法去测试呢？我们可以从synchronized的重入上找思路，是不是可以做出一个计数器，当对象存在引用的时候，就计数器加一，直到对象不被引用，计数器就减一，当对象的计数器归零了，是不是就可以被回收了呢？我们可以做出一个例子看看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment">//JDK6</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个成员属性的唯一意义就是占点内存，以便在能在GC日志中看清楚是否有回收过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        test objA = <span class="keyword">new</span> test();</span><br><span class="line">        test objB = <span class="keyword">new</span> test();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 假设在这行发生GC，objA和objB是否能被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[GC [DefNew: <span class="number">2546</span>K-&gt;<span class="number">173</span>K(<span class="number">4928</span>K), <span class="number">0.0029877</span> secs] <span class="number">2546</span>K-&gt;<span class="number">2221</span>K(<span class="number">15872</span>K), <span class="number">0.0030177</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(System)</span> [Tenured: 2048K-&gt;173<span class="title">K</span><span class="params">(<span class="number">10944</span>K)</span>, 0.0106634 secs] 4403K-&gt;173<span class="title">K</span><span class="params">(<span class="number">15872</span>K)</span>, [Perm : 424K-&gt;424<span class="title">K</span><span class="params">(<span class="number">12288</span>K)</span>], 0.0107119 secs] [Times: user</span>=<span class="number">0.02</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> def <span class="keyword">new</span> generation   total <span class="number">4992</span>K, used <span class="number">91</span>K [<span class="number">0x24450000</span>, <span class="number">0x249b0000</span>, <span class="number">0x299a0000</span>)</span><br><span class="line">  eden space <span class="number">4480</span>K,   <span class="number">2</span>% used [<span class="number">0x24450000</span>, <span class="number">0x24466d20</span>, <span class="number">0x248b0000</span>)</span><br><span class="line">  from space <span class="number">512</span>K,   <span class="number">0</span>% used [<span class="number">0x248b0000</span>, <span class="number">0x248b0000</span>, <span class="number">0x24930000</span>)</span><br><span class="line">  to   space <span class="number">512</span>K,   <span class="number">0</span>% used [<span class="number">0x24930000</span>, <span class="number">0x24930000</span>, <span class="number">0x249b0000</span>)</span><br><span class="line"> tenured generation   total <span class="number">10944</span>K, used <span class="number">173</span>K [<span class="number">0x299a0000</span>, <span class="number">0x2a450000</span>, <span class="number">0x34450000</span>)</span><br><span class="line">   the space <span class="number">10944</span>K,   <span class="number">1</span>% used [<span class="number">0x299a0000</span>, <span class="number">0x299cb588</span>, <span class="number">0x299cb600</span>, <span class="number">0x2a450000</span>)</span><br><span class="line"> compacting perm gen  total <span class="number">12288</span>K, used <span class="number">428</span>K [<span class="number">0x34450000</span>, <span class="number">0x35050000</span>, <span class="number">0x38450000</span>)</span><br><span class="line">   the space <span class="number">12288</span>K,   <span class="number">3</span>% used [<span class="number">0x34450000</span>, <span class="number">0x344bb1a0</span>, <span class="number">0x344bb200</span>, <span class="number">0x35050000</span>)</span><br><span class="line">    ro space <span class="number">10240</span>K,  <span class="number">55</span>% used [<span class="number">0x38450000</span>, <span class="number">0x389d3320</span>, <span class="number">0x389d3400</span>, <span class="number">0x38e50000</span>)</span><br><span class="line">    rw space <span class="number">12288</span>K,  <span class="number">55</span>% used [<span class="number">0x38e50000</span>, <span class="number">0x394f6128</span>, <span class="number">0x394f6200</span>, <span class="number">0x39a50000</span>)</span><br></pre></td></tr></table></figure><p>这段代码使得两个对象互相引用对方，这样的话就似乎永久不会被销毁了<img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/jvm5.jpg" alt="jvm5"></p><p>但接下来的GC日志告诉我们，事情并不是这样的，在进行自主选择的full GC(充分GC)当中，出现了4403K-&gt;173K(15872K)，可见的，就算互相引用，最终也会被销毁的，所以GC所使用的的算法，并不是这样。但也许你会说，它们都是变量，变量之间互相引用本来就是可以随意变换的，可能GC在对引用一个常量的时候，才会做出存活判断，而对变量都进行销毁。</p><h4 id="可达分析算法"><a href="#可达分析算法" class="headerlink" title="可达分析算法"></a>可达分析算法</h4><p>那么我们就使用一种是否引用常量的可达分析算法去判断他们吧</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/jvm6.jpg" alt="jvm6"></p><p>这种方法，可以把一个GC roots作为不可被回收的引用池，所有连接在GC roots的都会是一直存活的对象，直到他们不引用任何GC Roots时，才去判断回收。可作为 GC Roots 的对象：</p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 JNI(即一般说的 Native 方法) 引用的对象</li></ul><h4 id="引用的状态"><a href="#引用的状态" class="headerlink" title="引用的状态"></a>引用的状态</h4><p>这样的算法很纯粹，但是太过狭隘，一个对象可否存活，直接用处引用还是未引用的状态去判断。虽然很科学，但是未必会贴合实际，我们更希望当内存空间还足够时，保留它们，而内存空间在进行一次垃圾回收后，仍然未够的话，就放弃它们。而之后，Java对这个对象的引用状态，又增加了很多概念：</p><ul><li>强引用：类似于 Object obj = new Object();`创建的，只要强引用在就不回收</li><li>软引用：SoftReference 类实现软引用。在系统要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。</li><li>弱引用：WeakReference 类实现弱引用。对象只能生存到下一次垃圾收集之前。在垃圾收集器工作时，无论内存是否足够都会回收掉只被弱引用关联的对象。</li><li>虚引用：PhantomReference 类实现虚引用。无法通过虚引用获取一个对象的实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li></ul><h4 id="对象的自救"><a href="#对象的自救" class="headerlink" title="对象的自救"></a>对象的自救</h4><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，就好像判了刑并不会立即处死一样，还有缓刑这个概念，这个倒是挺人性化的。在虚拟机中，一个对象的真正死亡至少要经历两次标记过程：如果对象在进行中可达性分析后发现没有与 GC Roots 相连接的引用链，那他将会被第一次标记并且进行一次筛选，筛选条件是此对象是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。那么我们来看看，对象如何自救：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// * 1.对象可以在被GC时自我拯救。</span></span><br><span class="line"><span class="comment">// * 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> test SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"yes, i am still alive "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"finalize mehtod executed!"</span>);</span><br><span class="line">        test.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> test();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对象第一次成功拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"no, i am dead "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面这段代码与上面的完全相同，但是这次自救却失败了</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"no, i am dead"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">finalize mehtod executed!</span><br><span class="line">yes, i am still alive </span><br><span class="line">no, i am dead</span><br></pre></td></tr></table></figure><p>可以看到，被测试的对象，在覆盖了Finalizer方法之后，就有了一次暂时不死的机会，让其自救，而在使用了这个方法之后，对象仍然不知死活，那就真的要死了。但是Finalizer方法用系统的开销极大，后面也被废弃了，这里仅仅是谈谈而已。</p><h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><p>方法区之前被称之为永久代，这是一个误解，但事实也和所谓的永久代差不多。一般方法区是很少出现回收这个事件，如果出现回收，那么不外乎有两种情况：废弃的常量和无用的类。废弃的常量判断比较简单，那就是这个常量，比如“qwe”，它在堆中不会在有任何实例去引用它，那么它就暂时失去价值了，所以会被销毁。而无用的类的判断方法更为复杂一点，一般要满足一下三点：</p><ul><li>该类所有的实例都已经回收，也就是 Java 堆中不存在该类的任何实例</li><li>加载该类的 ClassLoader 已经被回收</li><li>该类对应的 java.lang.Class 对象没有任何地方呗引用，无法在任何地方通过反射访问该类的方法</li></ul><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><p>可达分析算法准确来说是一个判断垃圾是否需要被回收的一种机制，而我们的Jvm，对垃圾的收集，也有着不同的算法。这些算法建立在两个假说身上：</p><ol><li>弱分代假说：绝大多数对象都是朝生熄灭的。</li><li>强分代假说：熬过多次垃圾收集过程的对象就越难以消亡。</li></ol><p>这两种假说奠定了垃圾收集器一致性的原则。从而也有了“minor GC”，“MajorGC“，”Full GC“这样不同的回收类型。不同的回收类型对应的不同的分代，在内存块中，也会给对象标明是新生代还是老年代，以此做出区分，这样在每次进行内存回收的时候，能够大大的提高效率。</p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>现在的虚拟机多是使用这样的机制，把Java堆分成为新生代和老年代，根据各个代的特点，使用不同的算法，比如新生代每次GC，都会有70%~90%的对象被回收，所以使用的是复制算法，而在经历15次回收后，该对象就会进入到老年代。老年代使用的是标记清理或者标记整理算法来进行回收。</p><h4 id="标记—清除算法"><a href="#标记—清除算法" class="headerlink" title="标记—清除算法"></a>标记—清除算法</h4><p>最早诞生的垃圾收集算法叫做标记清楚算法。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/jvmsf1.jpg" alt="bjqc"></p><p>这种算法就是把需要被回收的空间标记出来，然后在进行回收，整体而言比较好理解，但是这样的算法有两个不足，一是效率不高，如果内存空间极大，就要进行大量的标记动作，二是空间上会产生大量的碎片。</p><h4 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h4><p>接着就是复制算法，它是为了解决标记清除算法面对大量可回收对象的时候，效率低下的问题。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/jvmsf2.jpg" alt="fzsf"></p><p>这种算法是把空间分成两块，每次只对其中一块进行 GC。当这块内存使用完时，就将还存活的对象复制到另一块上面。解决前一种方法的不足，但是会造成空间利用率低下。</p><p>因为大多数新生代对象都不会熬过第一次 GC。所以没必要 1 : 1 划分空间。可以分一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。</p><p>当回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另一块 Survivor 上，最后清理 Eden 和 Survivor 空间。大小比例一般是 8 : 1 : 1，每次浪费 10% 的 Survivor 空间。但是这里有一个问题就是如果存活的大于 10% 怎么办？这里采用一种分配担保策略：多出来的对象直接进入老年代。</p><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>这种算法的标记过程和标记清除算法一样，只不过后面的步骤不是直接进行清除，而是让所有存活的对象都向内存空间的一段移动。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/jvmsf3.jpg" alt="bjzlsf"></p><p>这种算法也是把需要回收的内存打标记，之后再进行整理，把所有存活的对象内存移动至一端，然后直接清理掉边界以外的内存。</p><h4 id="HotSpot算法的细节实现"><a href="#HotSpot算法的细节实现" class="headerlink" title="HotSpot算法的细节实现"></a>HotSpot算法的细节实现</h4><h5 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h5><p>前面说到使用的是可达分析算法去判断是否存在引用，而在判断的过程中，需要进行枚举根节点操作，去根节点寻找引用链。但是在应用越来越大的时候，可能仅仅方法区就有将近几百兆，要逐个检查他们的是否存在引用。另外，可达性分析对执行时间的敏感还体现在GC停顿上，因为每次要进行枚举根节点的时候，为了线程之间不出错，也为了能够准确的找出所有的引用，会把所有的线程停顿下来，等待所有线程的停顿想必需要大量的时间。</p><p>在停顿下来的时候，其实并不需要一个不漏的检查完所有执行上下文和全局的引用位置。在寻找引用的时候，HotSpot还会用到一种名为OopMap的数据结构，一旦类加载动作完成，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译中，也会在特定的位置记录下栈里和寄存器里是哪里的引用。这样，收集器在扫描的时候，就可以直接得知这些信息，并不需要一个不漏地从方法区等GC Roots开始查找。</p><h5 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h5><p>因为OopMap的内容变化指令非常多，如果为每一条指令都生成对应的OopMap，将会需要大量的额外空间。但实际上，HotSpot也没有为每一条指令都生成OopMap，而是在程序执行到达Safepoint(安全点)的时候，才暂停下来，准备GC。那如何去判断程序是否到达安全点呢？HotSpot使用主动式中断的思想，当GC需要中断线程的时候，会设置一个标志，各个线程会主动去轮询这个标志，当满足安全中断的条件后，才会停下来进行GC</p><h5 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h5><p>Safe Region(安全区域)，可以看作为是扩展了的安全点，当线程执行到安全区域时，会自行标识自己，在这段时候内，如果JVM需要GC，就会自行的进行暂停线程开始GC。</p><h5 id="记忆集与卡表"><a href="#记忆集与卡表" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h5><p>在进行分代收集的时候，新生代和老年代都不是一个独立的个体，它们之间或多或少存在着一些互相引用的问题。如果要对老年代全部进行一次GC Roots，但是老年代却很少有内存是能够回收的，想必开销是非常大的。所以，为了避免这种情况，就在新生代中多了一个名为记忆集的数据结构。</p><p>记忆集是一种用于记录从非收集区域指向收集其余的指针集合的抽象数据结构，它也可以选择很多不同记忆精度面对不同的情况。一般选择的是<strong>卡精度</strong>，也被称为卡表，卡表最简单的形式可以只是一个字节数组，这个数组的每个key都有对应的卡页，一个卡页的内存中通常包含不止一个对象，只要卡页内有一个对象的字段存在跨代指针，就将key值标记为1，并称这个元素变脏了。在GC的时候，只会选择变脏的元素的对应区域进行GCRoots。</p><h5 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h5><p>有其他分代区域中对象的引用了本区域对象时，其对应的元素就会变脏。但这个过程只靠什么去维持的呢？这里可以引入类似于Synchronized的思想，去锁住它，于是便有了写屏障。在更改记忆集的时候，为了原子性得到保障，会使用这个写屏障去维护记忆集，但写屏障不仅仅这有这些作用，它还做到了类似于try-fianlly的操作，只不过这些都被封装起来了，就像Spring里面的AOP一样。</p><h5 id="并发的可达性分析"><a href="#并发的可达性分析" class="headerlink" title="并发的可达性分析"></a>并发的可达性分析</h5><p>当堆越来越大的时候，试图去进行根节点遍历就会变的困难起来。所以面对这种情况，就引入了多线程里面的概念，我们不将所有的线程都暂停后才进行GC，而是直接随着线程的执行而进行根节点遍历。</p><p>但这也引入了新的问题，那就是在多线程情况下的不确定性，比如把新生代要回收的内存区域错误标记成了老年代，这个是可以容忍的，但如果错误的把老年代标记为要被销毁的新生代，那可能会使程序崩溃，为了解决这种事务端，也诞生了两种解决方案：<strong>增量更新和原始快照</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机（三）虚拟机中的内存溢出</title>
      <link href="/2020/01/04/Java%E8%99%9A%E6%8B%9F%E6%9C%BA3/"/>
      <url>/2020/01/04/Java%E8%99%9A%E6%8B%9F%E6%9C%BA3/</url>
      
        <content type="html"><![CDATA[<h3 id="OutOfMemoryError异常"><a href="#OutOfMemoryError异常" class="headerlink" title="OutOfMemoryError异常"></a>OutOfMemoryError异常</h3><p>OutOfMemoryError异常（简称OOM）是Java虚拟机中一个比较常见的异常，它的情况有很多种，我们就以HotSpot的虚拟机为例，讲解一下常见的异常。</p><h3 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h3><p>Java堆是在虚拟机中，所有线程共享的一个堆栈，我们如果在程序中不断地添加一个对象而不去销毁，只会让虚拟机的堆内存填满直到溢出，这是一种常见的错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 默认的jvm设置</span><br><span class="line"></span><br><span class="line">-Xms128m</span><br><span class="line">-Xmx750m</span><br><span class="line">-XX:ReservedCodeCacheSize=<span class="number">240</span>m</span><br><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">-XX:SoftRefLRUPolicyMSPerMB=<span class="number">50</span></span><br><span class="line">-ea</span><br><span class="line">-Dsun.io.useCanonCaches=<span class="keyword">false</span></span><br><span class="line">-Djava.net.preferIPv4Stack=<span class="keyword">true</span></span><br><span class="line">-Djdk.http.auth.tunneling.disabledSchemes=<span class="string">""</span></span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">-XX:-OmitStackTraceInFastThrow</span><br></pre></td></tr></table></figure><p>这是IDEA中的默认的虚拟机配置，可以自行改动。</p><p>java堆前面说过，是所有线程共享的，java程序代码在某些时候出现的错误操作，会导致内存溢出，这个和C++类似，不过Java的虚拟机不仅仅支持了代码的跨平台性，还拥有着自动的内存回收功能，下面来看看Java虚拟机在操作不当时候会出现的错误吧。</p><p>注1：在idea使用虚拟机设置时，点击上方的run-edit configuration-vm option</p><p>注2：以下实验默认基于JDK8，否则会特别声明版本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// VM Args：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;OOMObject&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to java_pid15176.hprof ...</span><br><span class="line">Heap dump file created [<span class="number">28147742</span> bytes in <span class="number">0.098</span> secs]</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at java.util.Arrays.copyOf(Arrays.java:<span class="number">3210</span>)</span><br><span class="line">at java.util.Arrays.copyOf(Arrays.java:<span class="number">3181</span>)</span><br><span class="line">at java.util.ArrayList.grow(ArrayList.java:<span class="number">265</span>)</span><br><span class="line">at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:<span class="number">239</span>)</span><br><span class="line">at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:<span class="number">231</span>)</span><br><span class="line">at java.util.ArrayList.add(ArrayList.java:<span class="number">462</span>)</span><br><span class="line">at test.main(test.java:<span class="number">14</span>)</span><br></pre></td></tr></table></figure><p>像这样不断增加对象的方式，会使得Java堆溢出。在idea中，可以直接点击test.java.14直接找到是哪里出现了错误。</p><h3 id="虚拟机栈和本地方法溢出"><a href="#虚拟机栈和本地方法溢出" class="headerlink" title="虚拟机栈和本地方法溢出"></a>虚拟机栈和本地方法溢出</h3><h4 id="过多的循环"><a href="#过多的循环" class="headerlink" title="过多的循环"></a>过多的循环</h4><p>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常，虽然在Java虚拟机规范当中，是允许Java虚拟机选择是否支持栈动态扩展的，但是在HotSpot中没有这个选项。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用-Xms128k</span></span><br><span class="line"><span class="comment">//减小栈的深度</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stackLength++;</span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test oom = <span class="keyword">new</span> test();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oom.stackLeak();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"stack length:"</span> + oom.stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.StackOverflowError</span><br><span class="line">stack length:<span class="number">997</span></span><br><span class="line">    at test.stackLeak(test.java:<span class="number">8</span>)</span><br><span class="line">at test.stackLeak(test.java:<span class="number">9</span>)</span><br><span class="line">at test.stackLeak(test.java:<span class="number">9</span>)</span><br><span class="line">at test.stackLeak(test.java:<span class="number">9</span>)</span><br><span class="line">at test.stackLeak(test.java:<span class="number">9</span>)</span><br><span class="line">    。。。。。。。。</span><br></pre></td></tr></table></figure><p>这个表示着不断地加入循环，在不断地压栈过程中极大的增加了栈的深度，导致了内存溢出。对于不同的操作系统，栈容量最小值可能有所限制，比如Windows最小不能低于180k，而Linux最小不能低于228k。当然，也不是仅仅使用循环过深才导致的，也会有创建线程过多，导致内存溢出。</p><h4 id="过多的线程"><a href="#过多的线程" class="headerlink" title="过多的线程"></a>过多的线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不在虚拟机上，千万不要尝试，有死机风险</span></span><br><span class="line"><span class="comment">//实验机器为32位系统，可以使用VMbox去尝试</span></span><br><span class="line"><span class="comment">//VM Args：-Xss2M </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dontStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeakByThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    dontStop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        JavaVMStackOOM oom = <span class="keyword">new</span> JavaVMStackOOM();</span><br><span class="line">        oom.stackLeakByThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在高并发环境下，产生过多线程在服务器中是比较正常的事情了。但像这种产生过多的线程，又不能减少线程数的情况下，去减少最大堆和减少栈容量是比较好的选择。</p><h4 id="栈容量无法申请足够的内存"><a href="#栈容量无法申请足够的内存" class="headerlink" title="栈容量无法申请足够的内存"></a>栈容量无法申请足够的内存</h4><p>第一个实验都是基于虚拟机栈不能允许动态扩展的前提下，但如果允许动态扩展，却无法申请到足够内存时，也会抛出StackOverflowError异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> stackLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> unused1, unused2, unused3, unused4, unused5,</span><br><span class="line">                unused6, unused7, unused8, unused9, unused10,</span><br><span class="line">                unused11, unused12, unused13, unused14, unused15,</span><br><span class="line">                unused16, unused17, unused18, unused19, unused20,</span><br><span class="line">                unused21, unused22, unused23, unused24, unused25,</span><br><span class="line">                unused26, unused27, unused28, unused29, unused30,</span><br><span class="line">                unused31, unused32, unused33, unused34, unused35,</span><br><span class="line">                unused36, unused37, unused38, unused39, unused40,</span><br><span class="line">                unused41, unused42, unused43, unused44, unused45,</span><br><span class="line">                unused46, unused47, unused48, unused49, unused50,</span><br><span class="line">                unused51, unused52, unused53, unused54, unused55,</span><br><span class="line">                unused56, unused57, unused58, unused59, unused60,</span><br><span class="line">                unused61, unused62, unused63, unused64, unused65,</span><br><span class="line">                unused66, unused67, unused68, unused69, unused70,</span><br><span class="line">                unused71, unused72, unused73, unused74, unused75,</span><br><span class="line">                unused76, unused77, unused78, unused79, unused80,</span><br><span class="line">                unused81, unused82, unused83, unused84, unused85,</span><br><span class="line">                unused86, unused87, unused88, unused89, unused90,</span><br><span class="line">                unused91, unused92, unused93, unused94, unused95,</span><br><span class="line">                unused96, unused97, unused98, unused99, unused100;</span><br><span class="line"></span><br><span class="line">        stackLength ++;</span><br><span class="line">        test2();</span><br><span class="line"></span><br><span class="line">        unused1 = unused2 = unused3 = unused4 = unused5 =</span><br><span class="line">                unused6 = unused7 = unused8 = unused9 = unused10 =</span><br><span class="line">                        unused11 = unused12 = unused13 = unused14 = unused15 =</span><br><span class="line">                                unused16 = unused17 = unused18 = unused19 = unused20 =</span><br><span class="line">                                        unused21 = unused22 = unused23 = unused24 = unused25 =</span><br><span class="line">                                                unused26 = unused27 = unused28 = unused29 = unused30 =</span><br><span class="line">                                                        unused31 = unused32 = unused33 = unused34 = unused35 =</span><br><span class="line">                                                                unused36 = unused37 = unused38 = unused39 = unused40 =</span><br><span class="line">                                                                        unused41 = unused42 = unused43 = unused44 = unused45 =</span><br><span class="line">                                                                                unused46 = unused47 = unused48 = unused49 = unused50 =</span><br><span class="line">                                                                                        unused51 = unused52 = unused53 = unused54 = unused55 =</span><br><span class="line">                                                                                                unused56 = unused57 = unused58 = unused59 = unused60 =</span><br><span class="line">                                                                                                        unused61 = unused62 = unused63 = unused64 = unused65 =</span><br><span class="line">                                                                                                                unused66 = unused67 = unused68 = unused69 = unused70 =</span><br><span class="line">                                                                                                                        unused71 = unused72 = unused73 = unused74 = unused75 =</span><br><span class="line">                                                                                                                                unused76 = unused77 = unused78 = unused79 = unused80 =</span><br><span class="line">                                                                                                                                        unused81 = unused82 = unused83 = unused84 = unused85 =</span><br><span class="line">                                                                                                                                                unused86 = unused87 = unused88 = unused89 = unused90 =</span><br><span class="line">                                                                                                                                                        unused91 = unused92 = unused93 = unused94 = unused95 =</span><br><span class="line">                                                                                                                                                                unused96 = unused97 = unused98 = unused99 = unused100 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test2();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Error e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"stack length:"</span> + stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stack length:<span class="number">6004</span></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.StackOverflowError</span><br></pre></td></tr></table></figure><p>实验表明，无论是栈帧太大，还是虚拟机栈容量大小，当新的栈帧内存无法分配时，都会抛出StackOverflowError异常。</p><h3 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h3><h4 id="常量池溢出"><a href="#常量池溢出" class="headerlink" title="常量池溢出"></a>常量池溢出</h4><p>方法区曾被称之为永久代，但在jdk7以及之后开始逐步去永久代了，并且在JDK8当中，使用了元空间去代替。方法区存放的是常量池在不断存放过多的常量后也会溢出。以下实验先使用JDK6进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args：-XX:PermSize=10M -XX:MaxPermSize=10M</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用List保持着常量池引用，避免Full GC回收常量池行为</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 10MB的PermSize在integer范围内足够产生OOM了</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.OutOfMemoryError: PermGen space</span><br><span class="line">at java.lang.String.intern(Native Method)</span><br><span class="line">at test.main(test.java from InputFileObject:<span class="number">15</span>)</span><br></pre></td></tr></table></figure><p>这里的intern()是Native方法，作用是如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象，否则将此String对象包含的字符串添加到常量池中，并返回此string对象的引用。如此一来，添加过多的常量，却不进行GC则导致的常量池溢出异常。</p><p>那么接下来是JDK7</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK7</span></span><br><span class="line"><span class="comment">//-Xmx6M</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用Set保持着常量池引用，避免Full GC回收常量池行为</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 在short范围内足以让6MB的PermSize产生OOM了</span></span><br><span class="line">        <span class="keyword">short</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            set.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at java.util.HashMap.resize(HashMap.java:<span class="number">704</span>)</span><br><span class="line">at java.util.HashMap.putVal(HashMap.java:<span class="number">663</span>)</span><br><span class="line">at java.util.HashMap.put(HashMap.java:<span class="number">612</span>)</span><br><span class="line">at java.util.HashSet.add(HashSet.java:<span class="number">220</span>)</span><br><span class="line">at test.main(test.java:<span class="number">13</span>)</span><br></pre></td></tr></table></figure><p>如果在JDK7中，仍然使用 VM Args：-XX:PermSize=10M -XX:MaxPermSize=10M去进行的话，将会永久的运行下去，因为在JDK7中，已经把字符串常量池移动到了Java堆中。所以可以使用-Xmx6M去限制最大的堆，就可以看到不同的结果，结果表明是Java堆溢出。</p><h4 id="JDK6和JDK7"><a href="#JDK6和JDK7" class="headerlink" title="JDK6和JDK7"></a>JDK6和JDK7</h4><p>还有一个比较重要的案例是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK7</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            String str1 = <span class="keyword">new</span> StringBuilder(<span class="string">"计算机"</span>).append(<span class="string">"科学"</span>).toString();</span><br><span class="line">            System.out.println(str1.intern() == str1);</span><br><span class="line"></span><br><span class="line">            String str2 = <span class="keyword">new</span> StringBuilder(<span class="string">"ja"</span>).append(<span class="string">"va"</span>).toString();</span><br><span class="line">            System.out.println(str2.intern() == str2);</span><br><span class="line">        &#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个案例在jdk6中会出现<strong>两个false</strong>，但是在jdk7中会出现<strong>一个true和一个false</strong>，这是因为在jdk6中，intern()会返回首次遇到的字符串复制在永久代中，而StringBuilder则是在堆中，所以两次的引用都不一样。</p><p>而在jdk7中，intern()不会再去复制，而只是在常量池中记录首次出现的引用，因此str1返回的字符串，都是在堆上的，而str2的字符串，在常量池中已经有它的引用了，所以str2的intern()还是返回的常量池的引用。</p><h4 id="方法区溢出"><a href="#方法区溢出" class="headerlink" title="方法区溢出"></a>方法区溢出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//VM Args： -XX:PermSize=10M -XX:MaxPermSize=10M</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">            enhancer.setSuperclass(OOMObject<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">            enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> proxy.invokeSuper(obj, args);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            enhancer.create();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">java.lang.OutOfMemoryError: PermGen space</span><br></pre></td></tr></table></figure><p>方法区内存溢出属于比较常见的溢出异常。一个类要被垃圾收集器回收，判定条件是比较苛刻的。像这样的情况，产生大量的class，就难以被回收，如此类似的还有很多JSP文件。</p><p>在JDK8以后，永久代便安全退出了历史舞台，元空间作为代替者登场。元空间是一个很大的改变，比如像前面的这一些测试，已经很难再使虚拟机产生方法区溢出异常了。我们看看元空间的一些防御措施：</p><p>—XX:MaxMetaspaceSize：设置元空间的最大值，默认为-1，即不受限制，或者说只受限于本地内存大小。</p><p>—XX:MinMetaspaceFreeRatio：作用是在垃圾收集之后控制最小的元空间剩余容量的百分比，可减少因为元空间不足导致的垃圾收集的频率。类似的还有-XX：MaxMetaspaceFreeRatio。</p><h3 id="本机内存直接溢出"><a href="#本机内存直接溢出" class="headerlink" title="本机内存直接溢出"></a>本机内存直接溢出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//VM Args：-Xmx20M -XX:MaxDirectMemorySize=10M</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[0];</span><br><span class="line">        unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            unsafe.allocateMemory(_1MB);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.OutOfMemoryError</span><br></pre></td></tr></table></figure><p>在这一段代码中，通过了反射去获取Unsafe的实例，而unsafe.allocateMemory(_1MB);在不断向系统申请内存分配，却又不进行销毁，导致的本地内存溢出异常。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机（二）HotSpot虚拟机对象探秘</title>
      <link href="/2020/01/04/Java%E8%99%9A%E6%8B%9F%E6%9C%BA2/"/>
      <url>/2020/01/04/Java%E8%99%9A%E6%8B%9F%E6%9C%BA2/</url>
      
        <content type="html"><![CDATA[<h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>在Java中，一个对象的创建，一般是使用new指令去完成。而c++则是直接定义对象就行了，Java虚拟机在对对象的创建和使用中有着自己的分配机制。我们的虚拟机遇到 new 指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。<strong>如果没有，执行相应的类加载</strong>。类加载检查通过之后，为新对象分配内存(内存大小在类加载完成后便可确认)。在堆的空闲内存中划分一块区域。</p><p>内存的划分方式有两种第一个是<strong>：‘指针碰撞-内存规整’</strong>。就是在内存空间中，有已使用内存和未使用内存，它们是整齐排列，有分界线的，当我们需要新的内存空间的时候，指针就会移动一小位内存空间去分配。第二种是：<strong>‘空闲列表-内存交错’</strong>的分配方式，在内存空间中，所有的内存呈现散列分布，需要通过一个表去记录哪里可以使用，哪里不可以使用。</p><p>内存空间分配完成后会初始化为 0(不包括对象头)，接下来就是填充对象头，把对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息存入对象头。new 指令后执行，执行完init 方法才算一份真正可用的对象创建完成。</p><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>我们一般使用的Java虚拟机，叫做HotSpot虚拟机。在 HotSpot 虚拟机中，分为 3 块区域：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)。</p><p><strong>对象头(Header)</strong>：包含两部分，<strong>第一部分</strong>用于存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，32 位虚拟机占 32 bit，64 位虚拟机占 64 bit。官方称为 ‘Mark Word’。<strong>第二部分</strong>是类型指针，即对象指向它的类的元数据指针，虚拟机通过这个指针确定这个对象是哪个类的实例。另外，如果是 Java 数组，对象头中还必须有一块用于记录数组长度的数据，因为普通对象可以通过 Java 对象元数据确定大小，而数组对象不可以。</p><p><strong>实例数据(Instance Data)</strong>：程序代码中所定义的各种类型的字段内容(包含父类继承下来的和子类中定义的)。</p><p><strong>对齐填充(Padding)</strong>：不是必然需要，主要是占位，保证对象大小是某个字节的整数倍。HotSpot虚拟机自动内存管理系统要求对象起始地址必须是8字节的整数倍，不够则进行填充。</p><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>使用对象时，通过栈上的 reference 数据来操作堆上的具体对象。但是 reference 并没有规定使用什么方式去引用，所以是取决于虚拟机的实现而定的，目前主流的方法有两种：</p><h4 id="通过句柄访问"><a href="#通过句柄访问" class="headerlink" title="通过句柄访问"></a>通过句柄访问</h4><p>Java 堆中会分配一块内存作为句柄池。reference 存储的是句柄地址。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/jvm3.jpg" alt="jvm3"></p><p>这个句柄池，可以看做为是一个有完整分类的区域，需要的各个对象，会不断地通过这个分类区域，通过一步步分类寻找，找到所需对象，可见性比较好。</p><h4 id="直接指针访问"><a href="#直接指针访问" class="headerlink" title="直接指针访问"></a>直接指针访问</h4><p>reference 中直接存储对象地址。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/jvm4.jpg" alt="jvm4"></p><p>这种方式是使用指针去直接找到地址，好处就是直接寻址的方式更有利于非常频繁的访问，不好的地方在于可见性不强。这个两种方法各自有各自的好处。通过句柄的方式，在进行GC的时候，由于有一个大致的分类，GC比较快速，但是在访问的时候，花费时间比较长，而通过地址的方式则反之，它在进行频繁访问的的时候有极高的效率，但是在GC的时候，效果不佳。<strong>就单论HotSpot而言，是使用第二种方式去实现的。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机（一）Java虚拟机概念</title>
      <link href="/2020/01/03/Java%E8%99%9A%E6%8B%9F%E6%9C%BA1/"/>
      <url>/2020/01/03/Java%E8%99%9A%E6%8B%9F%E6%9C%BA1/</url>
      
        <content type="html"><![CDATA[<h3 id="Java的起源"><a href="#Java的起源" class="headerlink" title="Java的起源"></a>Java的起源</h3><p>但是要说清楚Java虚拟机，我想从JDK开始说起。我们想要在一个计算机上使用Java，就必须在网上下载JDK和JRE，JDK是Java的开发工具，JRE是Java的运行环境，有了这个两个就能在计算机上使用Java。有人说可能还需要配置path路径，其实也未必，之所以要配置Java_home，不是因为它必须配置了才能用，只是因为配置了path路径后，就能够在全局中访问到它，如果你没有配置，其实在使用idea的时候，也没有多大影响。</p><p>JDK起源于sun公司，这是一个B2B企业，专门为其他企业提供软件服务，但是如今的Java已经不属于sun公司了，sun被Oracle收购了，Java已经属于Oracle了，并且，这家公司还把JDK和JRE结合到了一起，下载的时候直接下载JDK就行了，而在命名上，也有了变化，以后没有1.7和1.8这样的说法了，统称JDk7和JDk8这样的命名，如今的Jdk，貌似出到了JDk13了。</p><h3 id="什么是Java虚拟机"><a href="#什么是Java虚拟机" class="headerlink" title="什么是Java虚拟机"></a>什么是Java虚拟机</h3><p>先简述一下：Java虚拟机把java代码，根据所在平台的不同，会自动编译成相应的字节码，在任何平台上运行。这么讲似乎有点抽象，那我们做一个比喻，比如c语言，它只能在自己的平台上运行，比如Windows，你把c语言代码拿去Linux下运行，那是行不通的，必须安装相应的运行环境，而Java虚拟机的优势在于，你只要写了Java代码，有这个虚拟机，就能在任意平台上运行，这就是所谓的跨平台性。</p><p>但是Java虚拟机并不是一个个体，而是一个种类，自Java的发展史以来，Java虚拟机有很多，而现今在使用的Java虚拟机叫做HotSpot，具体可以在cmd（命令行）中，使用Java -version进行查看。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/jvm2.jpg" alt="jvm2"></p><p>可以从第三行得知，这个是HotSpot虚拟机</p><h3 id="Java虚拟机运行时的数据区域"><a href="#Java虚拟机运行时的数据区域" class="headerlink" title="Java虚拟机运行时的数据区域"></a>Java虚拟机运行时的数据区域</h3><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jvm/jvm.jpg" alt="jvm"></p><p>如图所示，共分为这么几个区域：</p><p><strong>1.程序计数器</strong>：内存空间小，线程私有。字节码解释器工作是就是通过改变这个计数器的值来选取下一条需要执行指令的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器完成。这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器的值则为 (Undefined)。</p><p>（1），区别于计算机硬件的pc寄存器，两者不略有不同。计算机用pc寄存器来存放“伪指令”或地址，而相对于虚拟机，pc寄存器它表现为一块内存(一个字长，虚拟机要求字长最小为32位)，虚拟机的pc寄存器的功能也是存放伪指令，更确切的说存放的是将要执行指令的地址。</p><p>（2）当虚拟机正在执行的方法是一个本地（native）方法的时候，jvm的pc寄存器存储的值是undefined。</p><p>（3）程序计数器是线程私有的，它的生命周期与线程相同，每个线程都有一个。</p><p>（4）此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p><p><strong>2.Java 虚拟机栈</strong>：线程私有，生命周期和线程一致。描述的是 Java 方法执行的内存模型：每个方法在执行时都会床创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。Java虚拟机栈。即是Java中的栈内存。</p><p>（1）线程私有的，它的生命周期与线程相同，每个线程都有一个。</p><p>（2）每个线程创建的同时会创建一个JVM栈，JVM栈中每个栈帧存放的为当前线程中局部基本类型的变量（java中定义的八种基本类型：boolean、char、byte、short、int、long、float、double；和reference （32 位以内的数据类型，具体根据JVM位数（64为还是32位）有关，因为一个solt(槽）占用32位的内存空间 ）、部分的返回结果，非基本类型的对象在JVM栈上仅存放一个指向堆上的地址；</p><p>（3）每一个方法从被调用直至执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><p>（4）栈运行原理：栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法和运行期数据的数据集，当一个方法A被调用时就产生了一个栈帧F1，并被压入到栈中，A方法又调用了B方法，于是产生栈帧F2也被压入栈，B方法又调用了C方法，于是产生栈帧F3也被压入栈…… 依次执行完毕后，先弹出后进……F3栈帧，再弹出F2栈帧，再弹出F1栈帧。</p><p><strong>3.本地方法栈</strong>：区别于 Java 虚拟机栈的是，Java 虚拟机栈为虚拟机执行 Java 方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。而所谓的Native方法，就是指使用非Java语言的方法，比如C++等，整个Java虚拟机的内部实现都是由C++构成的。</p><p>（1）先解释什么是本地方法：jvm中的本地方法是指方法的修饰符是带有native的但是方法体不是用java代码写的一类方法，这类方法存在的意义当然是填补java代码不方便实现的缺陷而提出的。案例介绍将在 下面22知识点仔细介绍。</p><p>（2）作用同java虚拟机栈类似，区别是：虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则是为虚拟机使用到的Native方法服务。</p><p>（3）是线程私有的，它的生命周期与线程相同，每个线程都有一个。</p><p><strong>4..Java 堆</strong>：对于绝大多数应用来说，这块区域是 JVM 所管理的内存中最大的一块。线程共享，主要是存放对象实例和数组。内部会划分出多个线程私有的分配缓冲区。可以位于物理上不连续的空间，但是逻辑上要连续。即是所谓的堆内存的存放地点，在Java中经常会用到。</p><p>（1）是Java虚拟机所管理的内存中最大的一块。</p><p>（2）不同于上面3个，堆是jvm所有线程共享的。</p><p>（3）在虚拟机启动的时候创建。</p><p>（4）唯一目的就是存放对象实例，几乎所有的对象实例以及数组都要在这里分配内存。</p><p>（5）Java堆是垃圾收集器管理的主要区域。</p><p>（6）因此很多时候java堆也被称为“GC堆”（Garbage Collected Heap）。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以Java堆还可以细分为：新生代和老年代；新生代又可以分为：Eden 空间、From Survivor空间、To Survivor空间。（23知识点详细介绍）</p><p>（7）java堆是计算机物理存储上不连续的、逻辑上是连续的，也是大小可调节的（通过-Xms和-Xmx控制）。</p><p>（8）如果在堆中没有内存完成实例的分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p><p><strong>5.方法区</strong>：方法区在GC中，曾经也被称之为永久代，在JDK8以及之后被称之为元空间。也可以从逻辑上推导，方法在虚拟机中一般不会被GC回收。属于共享内存区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><p>（1）在虚拟机启动的时候创建。</p><p>（2）所有jvm线程共享。</p><p>（3）除了和堆一样不需要不连续的内存空间和可以固定大小或者可扩展外，还可以选择不实现垃圾收集。</p><p>（4）用于存放已被虚拟机加载的类信息、常量、静态变量、以及编译后的方法实现的二进制形式的机器指令集等数据。</p><p>（5）被装载的class的信息存储在Methodarea的内存中。当虚拟机装载某个类型时，它使用类装载器定位相应的class文件，然后读入这个class文件内容并把它传输到虚拟机中。</p><p>（6）运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><p><strong>6.运行时常量池</strong>：属于方法区一部分，用于存放编译期生成的各种字面量和符号引用。编译器和运行期(String 的 intern() )都可以将常量放入池中。内存有限，无法申请时抛出 OutOfMemoryError。</p><p><strong>7.直接内存</strong>：非虚拟机运行时数据区的部分。可以看作为本机内存，本机内存不受堆大小的限制。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（二十一）AIO</title>
      <link href="/2020/01/02/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B21/"/>
      <url>/2020/01/02/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B21/</url>
      
        <content type="html"><![CDATA[<h3 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h3><p>在网络编程的一步一步进化中，NIO取代了旧的IO方式。而如今，NIO这样的通过selector不断去监控channel的方式，已经开始不满足于现如今的优化需要，也因为NIO一直都是一个同步的IO队列，对于高并发情况下，产生的阻塞依然会让人苦恼，于是乎，像AIO这样的异步IO方式，便诞生了。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/nio/aio.jpg" alt="aio"></p><p>AIO非常的简单，甚至可以说是完全的从面向对象出发，对方发送什么，我就<strong>立即</strong>返回。请注意这里的立即，因为AIO是异步的，所以它注定不会在服务端缓慢的处理信息，这里就要引入之前学过的Future模式，AIO正是这样的模式，得益于Future，收到了信息，便立即返回，然后在返回的途中处理完全部的数据。这样，即完成了异步（因为是立即返回，所以并不产生阻塞），又使得程序更为简洁。</p><p>以下便是使用AIO去再次重制服务器。注意，AIO的编程方式，虽然最终是面向对象，但还是引入了一个新的方式，那就是函数式编程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIOEchoServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> port=<span class="number">8000</span>;</span><br><span class="line">    <span class="keyword">private</span> AsynchronousServerSocketChannel server;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AIOEchoServer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        server=AsynchronousServerSocketChannel.open().bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> AIOEchoServer().start();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务端口为："</span>+port);</span><br><span class="line"></span><br><span class="line">        server.accept(<span class="keyword">null</span>, <span class="keyword">new</span> CompletionHandler&lt;AsynchronousSocketChannel, Object&gt;() &#123;</span><br><span class="line">            <span class="keyword">final</span> ByteBuffer byteBuffer=ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel result, Object attachment)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"执行的线程为："</span>+Thread.currentThread().getName());</span><br><span class="line">                Future&lt;Integer&gt; writeResult=<span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//使用future模式，接收到数据便立即返回，在返回中处理，便可异步的使用</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    byteBuffer.clear();</span><br><span class="line">                    <span class="comment">//清除上次的缓存</span></span><br><span class="line">                    result.read(byteBuffer).get(<span class="number">100</span>, TimeUnit.SECONDS);</span><br><span class="line">                    byteBuffer.flip();</span><br><span class="line">                    writeResult=result.write(byteBuffer);</span><br><span class="line">                    <span class="comment">//将数据立即写回给客户端</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        server.accept(<span class="keyword">null</span>,<span class="keyword">this</span>);</span><br><span class="line">                        writeResult.get();</span><br><span class="line">                        <span class="comment">//服务器将进行下一次客户端接收的准备，</span></span><br><span class="line">                        <span class="comment">// 使用future.get，通过等待，保证write操作写完，再关闭</span></span><br><span class="line">                        result.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"失败"</span>+exc);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是echo服务器，它的实际代码量其实非常的少，只有buffer那一段才是最为重要的。这里的AsynchronousServerSocketChannel调用了accept和read和write，它们的共同点就是，都继承了一个叫做CompletionHandler的接口，而这个CompletionHandler的接口又能够再接收一个AsynchronousSocketChannel，这样，服务器开始了它的俄罗斯套娃之旅。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> &lt;A&gt; <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(A attachment,</span></span></span><br><span class="line"><span class="function"><span class="params">                                CompletionHandler&lt;AsynchronousSocketChannel,? <span class="keyword">super</span> A&gt; handler)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;A&gt; <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(ByteBuffer src,</span></span></span><br><span class="line"><span class="function"><span class="params">                            A attachment,</span></span></span><br><span class="line"><span class="function"><span class="params">                            CompletionHandler&lt;Integer,? <span class="keyword">super</span> A&gt; handler)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    write(src, <span class="number">0L</span>, TimeUnit.MILLISECONDS, attachment, handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;A&gt; <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(ByteBuffer dst,</span></span></span><br><span class="line"><span class="function"><span class="params">                           A attachment,</span></span></span><br><span class="line"><span class="function"><span class="params">                           CompletionHandler&lt;Integer,? <span class="keyword">super</span> A&gt; handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    read(dst, <span class="number">0L</span>, TimeUnit.MILLISECONDS, attachment, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，这样的函数式编程思维，使得AIO更为简洁，每次只有服务器接收到了数据才会返回。函数式编程在《Java8实战》中有着重的讲述，也算是JDK8或以上才拥有的特点。而我们也可以应用到客户端上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIOClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AsynchronousSocketChannel client= AsynchronousSocketChannel.open();</span><br><span class="line">        <span class="comment">//建立通道</span></span><br><span class="line">        client.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">8000</span>), <span class="keyword">null</span>,</span><br><span class="line">                <span class="keyword">new</span> CompletionHandler&lt;Void, Object&gt;() &#123;</span><br><span class="line">            <span class="comment">//先连接，连接过程中传入一个CompletionHandler写入</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Void result, Object attachment)</span> </span>&#123;</span><br><span class="line">                        client.write(ByteBuffer.wrap(<span class="string">"hello!"</span>.getBytes()),<span class="keyword">null</span>,</span><br><span class="line">                                <span class="keyword">new</span> CompletionHandler&lt;Integer,Object&gt;()&#123;</span><br><span class="line">                        <span class="comment">//开始写入，完了接着往回read</span></span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, Object attachment)</span> </span>&#123;</span><br><span class="line">                                        <span class="keyword">try</span> &#123;</span><br><span class="line">                                            ByteBuffer buffer=ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                                            client.read(buffer, buffer, <span class="keyword">new</span> CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">                                             <span class="comment">//开始读取，读取完了关闭</span></span><br><span class="line">                                                <span class="meta">@Override</span></span><br><span class="line">                                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">                                                    buffer.flip();</span><br><span class="line">                                                    System.out.println(<span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">                                                    <span class="keyword">try</span> &#123;</span><br><span class="line">                                                        client.close();</span><br><span class="line">                                                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                                                        e.printStackTrace();</span><br><span class="line">                                                    &#125;</span><br><span class="line">                                                &#125;</span><br><span class="line"></span><br><span class="line">                                                <span class="meta">@Override</span></span><br><span class="line">                                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                                                &#125;</span><br><span class="line">                                            &#125;);</span><br><span class="line">                                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                                            e.printStackTrace();</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">服务端口为：8000</span></span><br><span class="line"><span class="comment">执行的线程为：Thread-9</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">hello!</span></span><br></pre></td></tr></table></figure><p>这里使用了connect去连接服务器，连接的时候，传入了一个CompletionHandler接口，完成连接之后便开始写入，而在写入的参数中又有一个CompletionHandler接口，完成它的读回，读取的过程中又有一个CompletionHandler，继续完成它的关闭连接操作，这样，它们便连接起来的了。每当有数据发送至服务端时，便可以立即被返回，不在服务器逗留。AIO的方式，又极大的提高了效率。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（二十）网络NIO</title>
      <link href="/2020/01/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B20/"/>
      <url>/2020/01/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B20/</url>
      
        <content type="html"><![CDATA[<h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><h4 id="什么是NIO"><a href="#什么是NIO" class="headerlink" title="什么是NIO"></a>什么是NIO</h4><p>NIO，即new io，一个可以代替Java io的一个新的机制。这个机制极大的区别的传统的io，让程序在多线程上拥有更好的效率。我们先来看看它和传统的io有什么区别。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/nio/nio2.png" alt="nioandio"></p><p>它在类型上和io不同，nio主要是一个面向缓冲区操作的，我们传统的io，都是使用着stream流的方式去读写信息，而nio则是先接收任何的值，进入到缓冲队列，再将其通过通道的方式，传递给服务器，如图。<img src="https://gitee.com/antarctica/img_sotre/raw/img/img/nio/nio.png" alt="nioofshape"></p><p>因为在buffer中，有一个叫做byteBuffer的类，能够容乃任意类型的值而不改变，能将一个buffer加入到通道中进行传输。回过头来看，传统的io对于处理客户传进来的一个信息，会分出一个线程去进行io操作。而nio不一样，这就要关系到选择器了，nio只使用一个线程去管理客户传进来的信息，每当客户有信息传入时，选择器会给这个信息先分一个类，分成需要进行io操作的一类，和不需要进行io操作的一类。这样会使需要io操作的一类才进行io函数去处理，这在宏观上，有什么区别呢？举一个例子，你在逛淘宝店铺，当你点击进去一个店铺的时候，就向服务器传达了一个信息，表示客户您在线，而传统的io则直接分给你一个线程，你的所有购买商品的操作，都会在这个线程中完成，而我们的nio呢，则不会直接分发线程给你，而是接收你的所有操作，并把需要io和不需要的io的操作分开来，这样，就不会长时间的去占用系统资源。而我们的通道（channel），则在这个时候起到了极大的作用：<img src="https://gitee.com/antarctica/img_sotre/raw/img/img/nio/nio6.png" alt="channel"></p><p>因为每一次启动io连接，都需要cpu去处理和调度，但是反反复复的使用cpu去开启和关闭io连接，无疑是一个极大的浪费，所以便使用了通道这一个技术，将io的数据使用buffer缓冲保存起来，并且通过通道去发送缓冲，这样效率便有了提升。</p><p>说到nio，也一下socket，是操作系统提供给通信层的一组抽象API接口。因为socket的存在，才能让两个进程实现通信。<img src="https://gitee.com/antarctica/img_sotre/raw/img/img/nio/nio3.jpg" alt="socket"></p><p>socket在计算机网络中，起到至关重要的地步，正是因为socket的存在，才使得数据连接起来，我们来看看socket是如何在客户端和服务器之间通信的。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/nio/nio4.jpg" alt="socket2"></p><p>服务端首先初始化socket()，然后与端口绑定bind()，再对端口进行监听<code>listen()</code>，接着调用accept()堵塞等待客户端连接。此时，若有一个客户端初始化了一个Socket，然后连接服务端connect()。若连接成功，此时客户端与服务端的连接就建立了。客户端发送请求write()，服务端接收请求并处理read()，然后将回应发送给客户端write()，客户端读取数据read()，最后关闭连接close()，一次交互结束。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/nio/nio5.gif" alt="socket3"></p><p>在这之后，我们使用socket来制作一个简单的echo服务器吧。echo服务器很简单，它在客户单读取的所有数据，都会原封不动的传输给服务端。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/nio/nio7.png" alt="echo"></p><p>参考资料：</p><p><a href="https://www.cnblogs.com/pony1223/p/8138233.html" target="_blank" rel="noopener">https://www.cnblogs.com/pony1223/p/8138233.html</a></p><p><a href="https://www.jianshu.com/p/01b9a454de5a" target="_blank" rel="noopener">https://www.jianshu.com/p/01b9a454de5a</a></p><p><a href="https://blog.csdn.net/weibo1230123/article/details/81951731" target="_blank" rel="noopener">https://blog.csdn.net/weibo1230123/article/details/81951731</a></p><h4 id="基于Socket的echo服务器"><a href="#基于Socket的echo服务器" class="headerlink" title="基于Socket的echo服务器"></a>基于Socket的echo服务器</h4><p>这个服务器逻辑较为简单，就是从客户端接收到什么，就再次向客户端发送什么，这次先使用普通的io流进行编程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">echo</span>服务器 </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService es= Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServerSocket echo=<span class="keyword">null</span>;</span><br><span class="line">        Socket client=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            echo=<span class="keyword">new</span> ServerSocket(<span class="number">8000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                client=echo.accept();</span><br><span class="line">                <span class="comment">//接收服务器获得的信息</span></span><br><span class="line">                System.out.println(<span class="string">"客户端地址："</span>+client.getRemoteSocketAddress()+<span class="string">" 发起了连接"</span>);</span><br><span class="line">                es.execute(<span class="keyword">new</span> HandleMsg(client));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HandleMsg</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        Socket clientSocket;</span><br><span class="line">        <span class="comment">//建立一个客户端的socket</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HandleMsg</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.clientSocket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            BufferedReader is=<span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//缓冲区的读</span></span><br><span class="line">            PrintWriter os=<span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//打印流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is =<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(clientSocket.getInputStream()));</span><br><span class="line">                os=<span class="keyword">new</span> PrintWriter(clientSocket.getOutputStream(),<span class="keyword">true</span>);</span><br><span class="line">                <span class="comment">//先将两个值进行初始化，使其指向Socket对象，避免空指针异常</span></span><br><span class="line">                <span class="comment">//从客户端读取信息</span></span><br><span class="line">                String input=<span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">long</span> start=System.currentTimeMillis();</span><br><span class="line">                <span class="keyword">while</span> ((input=is.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    os.println(input);</span><br><span class="line">                    <span class="comment">//使其读取的数据输出回客户端</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">long</span> end=System.currentTimeMillis();</span><br><span class="line">                System.out.println(<span class="string">"花费时间："</span>+(end-start)+<span class="string">"ms"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (is!=<span class="keyword">null</span>)is.close();</span><br><span class="line">                    <span class="keyword">if</span> (os!=<span class="keyword">null</span>)os.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端地址：/127.0.0.1:50214 发起了连接</span></span><br><span class="line"><span class="comment">//花费时间：1ms</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 客户端<span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket client=<span class="keyword">null</span>;</span><br><span class="line">        PrintWriter writer=<span class="keyword">null</span>;</span><br><span class="line">        BufferedReader reader=<span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//定义各个值</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            client=<span class="keyword">new</span> Socket();</span><br><span class="line">            client.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>,<span class="number">8000</span>));</span><br><span class="line">            <span class="comment">//去连接这个服务器的地址</span></span><br><span class="line">            writer=<span class="keyword">new</span> PrintWriter(client.getOutputStream(),<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//设置好输出流</span></span><br><span class="line">            writer.println(<span class="string">"hello!"</span>);</span><br><span class="line">            writer.flush();</span><br><span class="line">            reader=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(client.getInputStream()));</span><br><span class="line">            <span class="comment">//此时的i流正在读取从服务器发送回来的消息，寻址主要靠client的port端口</span></span><br><span class="line">            System.out.println(<span class="string">"来自于服务器："</span>+reader.readLine());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (writer!=<span class="keyword">null</span>)writer.close();</span><br><span class="line">            <span class="keyword">if</span> (reader!=<span class="keyword">null</span>)reader.close();</span><br><span class="line">            <span class="keyword">if</span> (client!=<span class="keyword">null</span>)client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//来自于服务器：hello!</span></span><br></pre></td></tr></table></figure><p>如此一来便完成了一个简单的服务器。但是，这样的io型服务器，在实际使用中，往往不尽人意，因为你可以从结构看到，它在对服务器有着硬性要求的条件下，对客户端的要求也不低，为什么这么说呢？因为每次的任务提交，都需要进行一段时间的阻塞，假如在我们的客户端网络状况及其不好，那么对服务端来说，也有着极大的影响。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 客户端<span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService es= Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> sleeptime=<span class="number">1000</span>*<span class="number">1000</span>*<span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClient</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Socket client=<span class="keyword">null</span>;</span><br><span class="line">            PrintWriter writer=<span class="keyword">null</span>;</span><br><span class="line">            BufferedReader reader=<span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                client =<span class="keyword">new</span> Socket();</span><br><span class="line">                client.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>,<span class="number">8000</span>));</span><br><span class="line">                <span class="comment">//设定连接服务器的地址</span></span><br><span class="line">                writer=<span class="keyword">new</span> PrintWriter(client.getOutputStream(),<span class="keyword">true</span>);</span><br><span class="line">                writer.print(<span class="string">"H"</span>);</span><br><span class="line">                LockSupport.parkNanos(sleeptime);</span><br><span class="line">                writer.print(<span class="string">"e"</span>);</span><br><span class="line">                LockSupport.parkNanos(sleeptime);</span><br><span class="line">                writer.print(<span class="string">"l"</span>);</span><br><span class="line">                LockSupport.parkNanos(sleeptime);</span><br><span class="line">                writer.print(<span class="string">"l"</span>);</span><br><span class="line">                LockSupport.parkNanos(sleeptime);</span><br><span class="line">                writer.print(<span class="string">"o"</span>);</span><br><span class="line">                LockSupport.parkNanos(sleeptime);</span><br><span class="line">                writer.print(<span class="string">"!"</span>);</span><br><span class="line">                LockSupport.parkNanos(sleeptime);</span><br><span class="line">                <span class="comment">//传达数据</span></span><br><span class="line">                writer.println();</span><br><span class="line">                writer.flush();</span><br><span class="line"></span><br><span class="line">                reader=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(client.getInputStream()));</span><br><span class="line">                <span class="comment">//初始化</span></span><br><span class="line">                System.out.println(<span class="string">"来自于服务器："</span>+reader.readLine());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (writer!=<span class="keyword">null</span>)writer.close();</span><br><span class="line">                  <span class="keyword">if</span> (reader!=<span class="keyword">null</span>)reader.close();</span><br><span class="line">                  <span class="keyword">if</span> (client!=<span class="keyword">null</span>)client.close();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EchoClient ec=<span class="keyword">new</span> EchoClient();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            es.execute(ec);</span><br><span class="line">        &#125;</span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*注：一下输出结果均来自于服务器</span></span><br><span class="line"><span class="comment">客户端地址：/127.0.0.1:50254 发起了连接</span></span><br><span class="line"><span class="comment">客户端地址：/127.0.0.1:50256 发起了连接</span></span><br><span class="line"><span class="comment">客户端地址：/127.0.0.1:50255 发起了连接</span></span><br><span class="line"><span class="comment">客户端地址：/127.0.0.1:50257 发起了连接</span></span><br><span class="line"><span class="comment">客户端地址：/127.0.0.1:50258 发起了连接</span></span><br><span class="line"><span class="comment">客户端地址：/127.0.0.1:50259 发起了连接</span></span><br><span class="line"><span class="comment">客户端地址：/127.0.0.1:50260 发起了连接</span></span><br><span class="line"><span class="comment">客户端地址：/127.0.0.1:50261 发起了连接</span></span><br><span class="line"><span class="comment">客户端地址：/127.0.0.1:50262 发起了连接</span></span><br><span class="line"><span class="comment">客户端地址：/127.0.0.1:50263 发起了连接</span></span><br><span class="line"><span class="comment">花费时间：6002ms</span></span><br><span class="line"><span class="comment">花费时间：6002ms</span></span><br><span class="line"><span class="comment">花费时间：6002ms</span></span><br><span class="line"><span class="comment">花费时间：6001ms</span></span><br><span class="line"><span class="comment">花费时间：6002ms</span></span><br><span class="line"><span class="comment">花费时间：6001ms</span></span><br><span class="line"><span class="comment">花费时间：6001ms</span></span><br><span class="line"><span class="comment">花费时间：6003ms</span></span><br><span class="line"><span class="comment">花费时间：6002ms</span></span><br><span class="line"><span class="comment">花费时间：6003ms</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看到，当我们的客户端网络状态很差的时候，我们的服务器状态也变的很差，服务器在等待客户端传输完数据的这六秒之内，是不能够做任何事情的，换句话说，属于服务器的性能，都用于等待你网络传输完数据。这表示你的多核服务器，将会有极大的资源浪费在这里。因此，NIO顺应而生了，NIO就是为了解决这样的问题而来，通过缓冲和通道交换的形式，NIO的选择器能够将需要读写的线程标记出来，让服务器在等待的过程中，还能去计算其他的事务。</p><h4 id="使用NIO在构建echo服务器"><a href="#使用NIO在构建echo服务器" class="headerlink" title="使用NIO在构建echo服务器"></a>使用NIO在构建echo服务器</h4><p>在NIO中，之前也提到过channel（通道），这个channel可以看作为socket。而向channel中传达buffer，就等于向socket中传达流，buffer和流不同的地方在于，buffer不会被阻塞，因为它仅是一个数据队列。而每一个channel中都有一个叫做selectablechannel，它被selector（选择器）所管理者。而selector可以被一个线程管理，也可以被多个线程管理，每当channel准备好数据时，selector就会得到通知，去处理这一些数据。那么，我们就来重新实现一下echo服务器吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.spi.SelectorProvider;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 使用<span class="title">NIO</span>来实现服务器 </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="comment">//构造一个选择器</span></span><br><span class="line">    <span class="keyword">private</span> ExecutorService es= Executors.newCachedThreadPool();</span><br><span class="line">    <span class="comment">//线程池</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Socket,Long&gt; time_start=<span class="keyword">new</span> HashMap&lt;Socket, Long&gt;(<span class="number">10240</span>);</span><br><span class="line">    <span class="comment">//用于统计服务器线程在一个客户端上花费的时间</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startServer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        selector= SelectorProvider.provider().openSelector();</span><br><span class="line">        <span class="comment">//开始使用选择器,此处使用的是工厂方法，返回一个instance</span></span><br><span class="line">        ServerSocketChannel ssc=ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">//开始构建通道，获得一个实例</span></span><br><span class="line">        ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//将通道的类型设置为非阻塞型</span></span><br><span class="line">                <span class="comment">//InetSocketAddress isa=new InetSocketAddress(InetAddress.getLocalHost(),8000);</span></span><br><span class="line">                <span class="comment">//这里意思也是为 localhost 和8000，只不过使用了类去包装它，</span></span><br><span class="line">        InetSocketAddress isa=<span class="keyword">new</span> InetSocketAddress(<span class="number">8000</span>);</span><br><span class="line">        <span class="comment">//进行端口的设定</span></span><br><span class="line">        ssc.socket().bind(isa);</span><br><span class="line">        <span class="comment">//将通道口绑定端口</span></span><br><span class="line">        SelectionKey key=ssc.register(selector,SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="comment">//最为关键的一步，将通道注册到选择器中，并设置捕获时间为：1 &lt;&lt; 4（二进制）</span></span><br><span class="line">        <span class="comment">//这样，选择器就能够为通道服务了。</span></span><br><span class="line">        <span class="comment">// register是一个注册器，会返回一个selector和channel的键值对，而selectionkey能够存储这样的关系</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            <span class="comment">//阻塞方法，如果没有任何数据，则会对线程进行阻塞，节省资源</span></span><br><span class="line">            <span class="comment">//但当有数据传输时，便返回收到的selectionkey</span></span><br><span class="line">            Set readyKeys=selector.selectedKeys();</span><br><span class="line">            <span class="comment">//获取key，并将其存放到列表中</span></span><br><span class="line">            Iterator i=readyKeys.iterator();</span><br><span class="line">            <span class="comment">//迭代器</span></span><br><span class="line">            <span class="keyword">long</span> e=System.currentTimeMillis();;</span><br><span class="line">            <span class="keyword">while</span> (i.hasNext())&#123;</span><br><span class="line">                SelectionKey sk=(SelectionKey) i.next();</span><br><span class="line">                i.remove();</span><br><span class="line">                <span class="comment">//从i中获取一个key值，务必将其移除，不然会next将永不为空</span></span><br><span class="line">                <span class="keyword">if</span> (sk.isAcceptable())&#123;</span><br><span class="line">                    doAccept(sk);</span><br><span class="line">                    <span class="comment">//判断当前channel是否在接收状态，是则进行接收</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sk.isValid()&amp;&amp;sk.isReadable())&#123;</span><br><span class="line">                    <span class="keyword">if</span> (!time_start.containsKey(((SocketChannel)sk.channel()).socket())) &#123;</span><br><span class="line">                        time_start.put(((SocketChannel)sk.channel()).socket(),</span><br><span class="line">                            System.currentTimeMillis());</span><br><span class="line">                        <span class="comment">//是否可读，是则进行读取，并截取一个时间戳</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    doRead(sk);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sk.isValid()&amp;&amp;sk.isWritable())&#123;</span><br><span class="line">                    doWrite(sk);</span><br><span class="line">                    <span class="comment">//判断是否可读，是则进行读取</span></span><br><span class="line">                    <span class="keyword">long</span> b=time_start.remove(((SocketChannel)sk.channel()).socket());</span><br><span class="line">                    System.out.println(<span class="string">"花费时间："</span>+(e-b)+<span class="string">"ms"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAccept</span><span class="params">(SelectionKey sk)</span></span>&#123;</span><br><span class="line">        ServerSocketChannel server=(ServerSocketChannel)sk.channel();</span><br><span class="line">        <span class="comment">//每当有一个客户端接入时，便产生一个新的channel去连接</span></span><br><span class="line">        SocketChannel clientChannel;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clientChannel=server.accept();</span><br><span class="line">            <span class="comment">//接收消息</span></span><br><span class="line">            clientChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//设置为非阻塞型</span></span><br><span class="line">            SelectionKey clientKey=clientChannel.register(selector,SelectionKey.OP_READ);</span><br><span class="line">            <span class="comment">//将新生成的channel注册到selector选择器，并且告诉选择器，可以进行读取操作了</span></span><br><span class="line">            EchoClient ehco=<span class="keyword">new</span> EchoClient();</span><br><span class="line">            clientKey.attach(ehco);</span><br><span class="line">            <span class="comment">//将这个客户端实例附加到连接的socket当中，共享这一个实例</span></span><br><span class="line">            InetAddress clientAddress=clientChannel.socket().getInetAddress();</span><br><span class="line">            System.out.println(<span class="string">"数据连接来自于："</span>+clientAddress.getHostAddress()+<span class="string">"."</span>);</span><br><span class="line">            <span class="comment">//将相关消息打印出来</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"接收新客户失败"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doRead</span><span class="params">(SelectionKey sk)</span></span>&#123;</span><br><span class="line">        SocketChannel channel=(SocketChannel)sk.channel();</span><br><span class="line">        <span class="comment">//接收参数，获得当前客户端的channel</span></span><br><span class="line">        ByteBuffer byteBuffer=ByteBuffer.allocate(<span class="number">8192</span>);</span><br><span class="line">        <span class="comment">//设置缓冲区为8kb</span></span><br><span class="line">        <span class="keyword">int</span> length;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            length=channel.read(byteBuffer);</span><br><span class="line">            <span class="comment">//channel.read(byteBuffer);表示将所有的数据读取到缓冲区中</span></span><br><span class="line">            <span class="comment">//使用length去表现是否有数据，没有则断掉连接</span></span><br><span class="line">            <span class="keyword">if</span> (length&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                disconnect(sk);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"接收新客户失败"</span>);</span><br><span class="line">            disconnect(sk);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        <span class="comment">//重置缓冲区，为数据处理做准备</span></span><br><span class="line">        es.execute(<span class="keyword">new</span> HandleMsg(sk,byteBuffer));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">disconnect</span><span class="params">(SelectionKey sk)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWrite</span><span class="params">(SelectionKey sk)</span></span>&#123;</span><br><span class="line">        SocketChannel channel =(SocketChannel) sk.channel();</span><br><span class="line">        <span class="comment">//接收参数，获得当前客户端的channel</span></span><br><span class="line">        EchoClient echo=(EchoClient) sk.attachment();</span><br><span class="line">        <span class="comment">//将数据类型转换为可以被处理的数据</span></span><br><span class="line">        LinkedList&lt;ByteBuffer&gt; data=echo.getData();</span><br><span class="line">        <span class="comment">//获取发送的内容列表</span></span><br><span class="line"></span><br><span class="line">        ByteBuffer byteBuffer=data.getLast();</span><br><span class="line">        <span class="comment">//获得列表顶部元素</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> length =channel.write(byteBuffer);</span><br><span class="line">            <span class="comment">//将数据进行回写</span></span><br><span class="line">            <span class="keyword">if</span> (length==-<span class="number">1</span>)&#123;</span><br><span class="line">                disconnect(sk);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">//错误则断开连接</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (byteBuffer.remaining()==<span class="number">0</span>)&#123;</span><br><span class="line">                data.removeFirst();</span><br><span class="line">                <span class="comment">//为null则移除顶部元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"接收新客户失败"</span>);</span><br><span class="line">            disconnect(sk);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (data.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            sk.interestOps(SelectionKey.OP_READ);</span><br><span class="line">            <span class="comment">//告诉选择器，现在只能够进行读操作了</span></span><br><span class="line">            <span class="comment">//因为不一定还有数据可以写，因此每次想要执行写操作时，都要在前进的doread中进行判断</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandleMsg</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        SelectionKey sk;</span><br><span class="line">        ByteBuffer byteBuffer;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HandleMsg</span><span class="params">(SelectionKey sk, ByteBuffer byteBuffer)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.sk = sk;</span><br><span class="line">            <span class="keyword">this</span>.byteBuffer = byteBuffer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数据将被转移到这里进行处理，如果有实际数据，将为其分配一个线程</span></span><br><span class="line">        <span class="comment">//而没有数据，自然不会分配线程</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            EchoClient ehco=(EchoClient) sk.attachment();</span><br><span class="line">            <span class="comment">//将数据类型转换为可以被处理的数据</span></span><br><span class="line">            ehco.enqueue(byteBuffer);</span><br><span class="line">            <span class="comment">//这里是入队压栈，如果需要处理数据的业务，都可以在这里进行处理</span></span><br><span class="line">            sk.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span><br><span class="line">            <span class="comment">//处理完后，告诉选择器，现在既可以进行读操作，也可以进行写操作</span></span><br><span class="line">            selector.wakeup();</span><br><span class="line">            <span class="comment">//强迫选择器立即返回</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> LinkedList&lt;ByteBuffer&gt; data;</span><br><span class="line">        <span class="comment">//建立一个队列，来存储数据</span></span><br><span class="line">        EchoClient()&#123;</span><br><span class="line">            data=<span class="keyword">new</span> LinkedList&lt;ByteBuffer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> LinkedList&lt;ByteBuffer&gt; <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(ByteBuffer byteBuffer)</span></span>&#123;</span><br><span class="line">            data.addFirst(byteBuffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        使用NIO来实现服务器 echoServer = <span class="keyword">new</span> 使用NIO来实现服务器();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            echoServer.startServer();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">数据连接来自于：127.0.0.1.</span></span><br><span class="line"><span class="comment">数据连接来自于：127.0.0.1.</span></span><br><span class="line"><span class="comment">数据连接来自于：127.0.0.1.</span></span><br><span class="line"><span class="comment">数据连接来自于：127.0.0.1.</span></span><br><span class="line"><span class="comment">数据连接来自于：127.0.0.1.</span></span><br><span class="line"><span class="comment">数据连接来自于：127.0.0.1.</span></span><br><span class="line"><span class="comment">数据连接来自于：127.0.0.1.</span></span><br><span class="line"><span class="comment">数据连接来自于：127.0.0.1.</span></span><br><span class="line"><span class="comment">数据连接来自于：127.0.0.1.</span></span><br><span class="line"><span class="comment">数据连接来自于：127.0.0.1.</span></span><br><span class="line"><span class="comment">花费时间：1ms</span></span><br><span class="line"><span class="comment">花费时间：1ms</span></span><br><span class="line"><span class="comment">花费时间：1ms</span></span><br><span class="line"><span class="comment">花费时间：1ms</span></span><br><span class="line"><span class="comment">花费时间：1ms</span></span><br><span class="line"><span class="comment">花费时间：1ms</span></span><br><span class="line"><span class="comment">花费时间：1ms</span></span><br><span class="line"><span class="comment">花费时间：1ms</span></span><br><span class="line"><span class="comment">花费时间：1ms</span></span><br><span class="line"><span class="comment">花费时间：1ms</span></span><br><span class="line"><span class="comment">//客户端B</span></span><br><span class="line"><span class="comment">来自于服务器：Hello!</span></span><br><span class="line"><span class="comment">来自于服务器：Hello!</span></span><br><span class="line"><span class="comment">来自于服务器：Hello!</span></span><br><span class="line"><span class="comment">来自于服务器：Hello!</span></span><br><span class="line"><span class="comment">来自于服务器：Hello!</span></span><br><span class="line"><span class="comment">来自于服务器：Hello!</span></span><br><span class="line"><span class="comment">来自于服务器：Hello!</span></span><br><span class="line"><span class="comment">来自于服务器：Hello!</span></span><br><span class="line"><span class="comment">来自于服务器：Hello!</span></span><br><span class="line"><span class="comment">来自于服务器：Hello!</span></span><br></pre></td></tr></table></figure><p>需要表达的都写了注释，在此不过多赘述。我们可以比较直观的看到，即使客户端出现的网络的延迟，也不会给服务器带来太大的问题，服务器只会在接收完客户端数据后再开启线程进行处理，而不是直接就分发线程给客户端。这里最关键的角色，还是selector（选择器）。</p><h4 id="使用NIO来构建客户端"><a href="#使用NIO来构建客户端" class="headerlink" title="使用NIO来构建客户端"></a>使用NIO来构建客户端</h4><p>上面使用了NIO来构建echo服务器，但还是用socket来构建的客户端。因此，我们可以使用NIO去重新构建一下客户端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.spi.SelectorProvider;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 客户端<span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(String ip,<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel channel=SocketChannel.open();</span><br><span class="line">        channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">this</span>.selector= SelectorProvider.provider().openSelector();</span><br><span class="line">        <span class="comment">//初始化选择器和通道</span></span><br><span class="line">        channel.connect(<span class="keyword">new</span> InetSocketAddress(ip,port));</span><br><span class="line">        <span class="comment">//绑定到socket上</span></span><br><span class="line">        channel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">        <span class="comment">//注册到选择器中，并且表示可以连接</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">working</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!selector.isOpen())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            selector.select();</span><br><span class="line">            <span class="comment">//无数据则阻塞，有则接受，并返回一个selectionkey</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; i=<span class="keyword">this</span>.selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (i.hasNext())&#123;</span><br><span class="line">                SelectionKey key=i.next();</span><br><span class="line">                i.remove();</span><br><span class="line">                <span class="comment">//传入并清空</span></span><br><span class="line">                <span class="keyword">if</span> (key.isConnectable())&#123;</span><br><span class="line">                    connect(key);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                    <span class="comment">//如果能读，则读</span></span><br><span class="line">                    read(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel channel=(SocketChannel)key.channel();</span><br><span class="line">        <span class="keyword">if</span> (channel.isConnectionPending())&#123;</span><br><span class="line">            channel.finishConnect();</span><br><span class="line">            <span class="comment">//如果正在连接，则完成连接</span></span><br><span class="line">        &#125;</span><br><span class="line">        channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//不阻塞</span></span><br><span class="line">        channel.write(ByteBuffer.wrap(<span class="keyword">new</span> String(<span class="string">"hello server!\r\n"</span>).getBytes()));</span><br><span class="line">        <span class="comment">//写入一个字符串</span></span><br><span class="line">        channel.register(<span class="keyword">this</span>.selector,SelectionKey.OP_READ);</span><br><span class="line">        <span class="comment">//表示现在可以进行读取操作了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel channel=(SocketChannel) key.channel();</span><br><span class="line">        <span class="comment">//创建读取缓冲区</span></span><br><span class="line">        ByteBuffer byteBuffer=ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">        channel.read(byteBuffer);</span><br><span class="line">        <span class="comment">//进行读取</span></span><br><span class="line">        <span class="keyword">byte</span>[] data=byteBuffer.array();</span><br><span class="line">        <span class="comment">//将缓冲区的字符串转化为字节流数组</span></span><br><span class="line">        String msg=<span class="keyword">new</span> String(data).trim();</span><br><span class="line">        <span class="comment">//转换为字符串</span></span><br><span class="line">        System.out.println(<span class="string">"客户端收到的信息为："</span>+msg);</span><br><span class="line">        channel.close();</span><br><span class="line">        key.selector().close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        客户端C t=<span class="keyword">new</span> 客户端C();</span><br><span class="line">        t.init(<span class="string">"localhost"</span>,<span class="number">8000</span>);</span><br><span class="line">        t.working();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端收到的信息为：hello server!</span></span><br><span class="line"><span class="comment">/*echo服务器：</span></span><br><span class="line"><span class="comment">数据连接来自于：127.0.0.1.</span></span><br><span class="line"><span class="comment">花费时间：2ms</span></span><br></pre></td></tr></table></figure><p>如此一来，便使用NIO实现了这个客户端C。可以看到，在使用NIO重构的过程中，不仅使得服务器和客户端有了更多优化，而且对于代码的复杂程度，也有着显著的减少。</p><p>不过，NIO虽然提供了不同于IO的阻塞策略，使得服务器得到优化，但是，NIO本身的IO行为，仍然是同步的，也就是说，也是在IO都准备好了之后，再去通知线程。那有没有方法可以先让IO操作完成后，再去通知线程呢？当然有，那就是AIO（Asynchronized），一种异步的IO方式。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（十九）并行算法</title>
      <link href="/2019/12/31/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B19/"/>
      <url>/2019/12/31/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B19/</url>
      
        <content type="html"><![CDATA[<h3 id="串行计算在并行的情况"><a href="#串行计算在并行的情况" class="headerlink" title="串行计算在并行的情况"></a>串行计算在并行的情况</h3><p>在串行条件下，许多计算方法，都比较的贴近自然语言，就好似a=b+c； 这样的计算方法，无疑那么的明显，就是a要等于b和c的和，和我们使用手写写出来的，并没与什么区别。但是，这样的计算方法，在并行条件下，却有那么点不同。或者说，串行计算在并行条件(多线程)下，也只会执行串行计算。举个例子：(B+C)*D-2；这样的计算式，我们可能将它们拆分开来计算，不可能先计算D-2再去计算 *(B+C)，这样有违于计算的基本常识。所以，想要得到最终的答案，就不得不一直去等待(B+C)的结果，这样的话，很多并行计算其实也没有那么多优势。但人们的眼光不仅仅拘于此，人们想到了使用流水线的方式，去发挥并行计算所能达到的最佳性能，你可将以上式子，在并行条件下拆分为，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T1=A+B;T2=T1*D;T3=T2-<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p> 这样的形式,让每一个线程在运行时，不必去重新计算他们的值，使用分工合作，一个线程负责加操作，一个负责乘操作，一个负责减操作，如此一来，就将我们的串行计算，大大的优化了。我们也可以使用例子去验证一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行一个(B+C)*D/2的例子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">msg</span> </span>&#123;</span><br><span class="line">    <span class="comment">//信息交换的载体</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> i;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> j;</span><br><span class="line">    <span class="keyword">public</span> String s=<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">puls</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BlockingQueue&lt;msg&gt; bq=<span class="keyword">new</span> LinkedBlockingQueue&lt;msg&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                msg m=bq.take();</span><br><span class="line">                <span class="comment">//从队列获得值</span></span><br><span class="line">                m.j=m.i+m.j;</span><br><span class="line">                <span class="comment">//求两数之和</span></span><br><span class="line">                multiply.bq.add(m);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">multiply</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BlockingQueue&lt;msg&gt; bq=<span class="keyword">new</span> LinkedBlockingQueue&lt;msg&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                msg m=bq.take();</span><br><span class="line">                m.i=m.i*m.j;</span><br><span class="line">                div.bq.add(m);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">div</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BlockingQueue&lt;msg&gt; bq=<span class="keyword">new</span> LinkedBlockingQueue&lt;msg&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                msg m=bq.take();</span><br><span class="line">                m.i=m.i/m.j;</span><br><span class="line">                System.out.println(m.s+<span class="string">"="</span>+m.i);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> puls()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> multiply()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> div()).start();</span><br><span class="line">        <span class="comment">//开启三个线程，但在并未传入参数之前，都会被take所阻塞</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">1000</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;<span class="number">1000</span> ; j++) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                msg m=<span class="keyword">new</span> msg();</span><br><span class="line">                m.i=i;</span><br><span class="line">                m.j=j;</span><br><span class="line">                m.s=<span class="string">"(("</span>+i+<span class="string">"+"</span>+j+<span class="string">")*"</span>+i+<span class="string">")/2"</span>;</span><br><span class="line">                puls.bq.add(m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">((<span class="number">1</span>+<span class="number">1</span>)*<span class="number">1</span>)/<span class="number">2</span>=<span class="number">1.0</span></span><br><span class="line">((<span class="number">1</span>+<span class="number">2</span>)*<span class="number">1</span>)/<span class="number">2</span>=<span class="number">1.0</span></span><br><span class="line">((<span class="number">1</span>+<span class="number">3</span>)*<span class="number">1</span>)/<span class="number">2</span>=<span class="number">1.0</span></span><br><span class="line">((<span class="number">1</span>+<span class="number">4</span>)*<span class="number">1</span>)/<span class="number">2</span>=<span class="number">1.0</span></span><br><span class="line">((<span class="number">1</span>+<span class="number">5</span>)*<span class="number">1</span>)/<span class="number">2</span>=<span class="number">1.0</span></span><br><span class="line">((<span class="number">1</span>+<span class="number">6</span>)*<span class="number">1</span>)/<span class="number">2</span>=<span class="number">1.0</span></span><br><span class="line">((<span class="number">1</span>+<span class="number">7</span>)*<span class="number">1</span>)/<span class="number">2</span>=<span class="number">1.0</span></span><br></pre></td></tr></table></figure><p>这样的并行计算，就结束啦。</p><h3 id="并行下的搜索"><a href="#并行下的搜索" class="headerlink" title="并行下的搜索"></a>并行下的搜索</h3><p>在并行条件下 ，除了使用的计算方式会有所不同之外，使用的算法也有着相应的改变。就比如搜索这一个算法，搜索在串行条件下，无论是二分搜索或者是其他搜索，我们都只需要在一个数组中遍历就了，最基本的搜索方式，就是在无序数组中，使用逐步遍历的方式进行搜索。那么在并行条件下，使用搜索，怎么把多线程里面的能力利用起来呢？这就要涉及到了一个线程之间的通信，我们可以想办法把一个数组分成两块，一个线程搜一块，这不就提高效率了吗，而之前所提到的Future模式，便可以应用到这里，搜索到了并返回搜索结果，这也是runnable接口所不具有的呢。来试试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] arr=&#123;<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>&#125;;</span><br><span class="line">    <span class="comment">//表示要搜索的原数组</span></span><br><span class="line">    <span class="keyword">static</span> ExecutorService es= Executors.newCachedThreadPool();</span><br><span class="line">    <span class="comment">//线程池</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Thread_num=<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//线程数量</span></span><br><span class="line">    <span class="keyword">static</span> AtomicInteger result=<span class="keyword">new</span> AtomicInteger(-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//定义搜索结果，没有搜到则返回-1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> value,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( i = begin; i &lt;end ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (result.get()&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> result.get();</span><br><span class="line">                <span class="comment">//表示找到了</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[i]==value)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!result.compareAndSet(-<span class="number">1</span>,i))&#123;</span><br><span class="line">                    <span class="comment">//如果设置失败，表示其他线程先找到了</span></span><br><span class="line">                    <span class="keyword">return</span> result.get();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> begin,end,value;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">task</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.begin = begin;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> r=search(value,begin,end);</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">psearch</span><span class="params">(<span class="keyword">int</span> value)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//根据线程数量对数组进行划分</span></span><br><span class="line">        <span class="keyword">int</span> sub=arr.length/Thread_num+<span class="number">1</span>;</span><br><span class="line">        List&lt;Future&lt;Integer&gt;&gt; r=<span class="keyword">new</span> ArrayList&lt;Future&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;arr.length ; i+=sub) &#123;</span><br><span class="line">            <span class="keyword">int</span> end=i+sub;</span><br><span class="line">            <span class="keyword">if</span> (end&gt;=arr.length)&#123;</span><br><span class="line">                end=arr.length;</span><br><span class="line">            &#125;</span><br><span class="line">            r.add(es.submit(<span class="keyword">new</span> task(value,i,end)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Future&lt;Integer&gt; f:</span><br><span class="line">             r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f.get()&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> f.get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=psearch(<span class="number">12</span>);</span><br><span class="line">        <span class="keyword">if</span> (i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"找到了，数组下标为："</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"没有找到"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到了，数组下标为：1</span></span><br></pre></td></tr></table></figure><p>通过使用Callable，就把并行搜索给实现了</p><h3 id="并行下的排序"><a href="#并行下的排序" class="headerlink" title="并行下的排序"></a>并行下的排序</h3><p>讲到排序，想必大家一开始学到的排序大多数冒泡排序之类的吧，像冒泡排序这种排序手法，在此不多赘述，但冒泡排序的特点就是，如果右边的数值比左边大，那么就将这两个相邻的数字进行一次交换，这个排序手法在串行条件下是那么的明确和简单。<img src="https://gitee.com/antarctica/img_sotre/raw/img/img/xier.gif" alt="冒泡"></p><p>但是在并行条件下，两个不同的线程要怎么把这种即比较手法结合到一起呢？这似乎是一个难题，因为这不等于搜索，可以拆分成两块去搜，排序的要求至少对整体而言，必须是可见的，毕竟部分有序不等于整体有序，为了解决这种难题，从冒泡排序中更改了一些逻辑，诞生了一个新的排序方法：奇偶排序</p><h4 id="交换型排序：奇偶排序"><a href="#交换型排序：奇偶排序" class="headerlink" title="交换型排序：奇偶排序"></a>交换型排序：奇偶排序</h4><p>奇偶排序并不是字面上意思，即奇数与奇数排序偶数与偶数排序，奇偶排序实际上是分两个线程，一边使得该数组中的奇数与其相邻的数字进行比较和交换，一边让该数组中偶数和相邻的数字进行比较和交换。这样不断重复下来即可，这样就可以将冒泡排序的排序手法，运用到多线程中了。使用实际例子试一试吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] arr=&#123;<span class="number">16</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">13</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> ExecutorService es= Executors.newCachedThreadPool();</span><br><span class="line">    <span class="comment">//线程池</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//设置是否进行交换的标志，以此控制奇偶数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">(<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">        flag = f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">sort</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> i, CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.i = i;</span><br><span class="line">            <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i]&gt;arr[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=arr[i];</span><br><span class="line">                arr[i]=arr[i+<span class="number">1</span>];</span><br><span class="line">                arr[i+<span class="number">1</span>]=temp;</span><br><span class="line">                <span class="comment">//交换</span></span><br><span class="line">                setFlag(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">psort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag==<span class="number">1</span> || start==<span class="number">1</span>)&#123;</span><br><span class="line">            setFlag(<span class="number">0</span>);</span><br><span class="line">            CountDownLatch latch=<span class="keyword">new</span> CountDownLatch(arr.length/<span class="number">2</span>-(arr.length%<span class="number">2</span>==<span class="number">0</span>?start:<span class="number">0</span>));</span><br><span class="line">            <span class="comment">//偶数的数组长度，当start等于1时，只有len/2-1个线程</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;arr.length-<span class="number">1</span> ; i+=<span class="number">2</span>) &#123;</span><br><span class="line">                es.submit(<span class="keyword">new</span> sort(i,latch));</span><br><span class="line">                <span class="comment">//此处是核心所在，每次i+2，可以跳过 奇/偶 的位置</span></span><br><span class="line">                <span class="comment">// 不断地去提交任务给线程执行，每次执行完都会set一个flag，</span></span><br><span class="line">                <span class="comment">// 开始下一次 奇/偶 排序</span></span><br><span class="line">            &#125;</span><br><span class="line">            latch.await();</span><br><span class="line">            <span class="comment">//等待所有线程结束</span></span><br><span class="line">            <span class="keyword">if</span> (start==<span class="number">0</span>)&#123;</span><br><span class="line">                start=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                start=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"交换前："</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a:</span><br><span class="line">             arr) &#123;</span><br><span class="line">            System.out.print(<span class="string">" "</span>+a);</span><br><span class="line">        &#125;</span><br><span class="line">        psort(arr);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"交换后："</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a:</span><br><span class="line">                arr) &#123;</span><br><span class="line">            System.out.print(<span class="string">" "</span>+a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">交换前：</span><br><span class="line"> <span class="number">16</span> <span class="number">12</span> <span class="number">14</span> <span class="number">11</span> <span class="number">15</span> <span class="number">13</span></span><br><span class="line">交换后：</span><br><span class="line"> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span></span><br></pre></td></tr></table></figure><p>这样一来，就排序成功了，内部运行的效果可看下图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/%E5%A5%87%E5%81%B6%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F.gif" alt="奇偶排序">))</p><h4 id="插入型排序：希尔排序"><a href="#插入型排序：希尔排序" class="headerlink" title="插入型排序：希尔排序"></a>插入型排序：希尔排序</h4><p>插入排序是一种常见的排序类型，这个和交换类型排序有着比较大的区别，直接选择排序就是一种插入型排序。把数组分成两部分，一部分是排序好的，一部分是还未排序好的，把未排序好的数组中的元素插入到排序好的数组中，就是插入排序。如果想要把这样排序应用到并行程序当中，未免也太过于困难，于是乎，便根据插入排序的基本原则，诞生了一种适合多线程下运行的排序：希尔排序。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/xier2.jpg" alt="希尔"></p><p>我们来看看希尔排序如何在多线程下实现吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] arr=&#123;<span class="number">16</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">13</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> ExecutorService es= Executors.newCachedThreadPool();</span><br><span class="line">    <span class="comment">//线程池</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">shell</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> h=<span class="number">0</span>;</span><br><span class="line">        CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">shell</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> h, CountDownLatch latch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.i = i;</span><br><span class="line">            <span class="keyword">this</span>.h = h;</span><br><span class="line">            <span class="keyword">this</span>.latch = latch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i]&lt;arr[i-h])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=arr[i];</span><br><span class="line">                <span class="keyword">int</span> j=i-h;</span><br><span class="line">                <span class="keyword">while</span> (j&gt;=<span class="number">0</span> &amp;&amp; arr[j]&gt;temp)&#123;</span><br><span class="line">                    arr[j+h]=arr[j];</span><br><span class="line">                    j-=h;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[j+h]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pshell</span><span class="params">(<span class="keyword">int</span>[]arr)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h=<span class="number">1</span>;</span><br><span class="line">        CountDownLatch latch=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (h&lt;=arr.length/<span class="number">3</span>)&#123;</span><br><span class="line">            h=h*<span class="number">3</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//计算出最大的h值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (h&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(<span class="string">"gap="</span>+h);</span><br><span class="line">            <span class="keyword">if</span> (h&gt;=<span class="number">4</span>)&#123;</span><br><span class="line">                latch=<span class="keyword">new</span> CountDownLatch(arr.length-h);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"交换的步骤："</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt;arr.length ; i++) &#123;</span><br><span class="line">                <span class="comment">//控制线程的数量</span></span><br><span class="line">                <span class="keyword">if</span> (h&gt;=<span class="number">4</span>)&#123;</span><br><span class="line">                    es.execute(<span class="keyword">new</span> shell(i,h,latch));</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[i]&lt;arr[i-h])&#123;</span><br><span class="line">                        <span class="keyword">int</span> temp=arr[i];</span><br><span class="line">                        <span class="keyword">int</span> j=i-h;</span><br><span class="line">                        <span class="keyword">while</span> (j&gt;=<span class="number">0</span>&amp;&amp;arr[j]&gt;temp)&#123;</span><br><span class="line">                            arr[j+h]=arr[j];</span><br><span class="line">                            j-=h;</span><br><span class="line">                        &#125;</span><br><span class="line">                        arr[j+h]=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Arrays.toString(arr));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            latch.await();</span><br><span class="line">            <span class="comment">//等待排序完成</span></span><br><span class="line">            h=(h-<span class="number">1</span>)/<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"交换前："</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a:</span><br><span class="line">                arr) &#123;</span><br><span class="line">            System.out.print(<span class="string">" "</span>+a);</span><br><span class="line">        &#125;</span><br><span class="line">        pshell(arr);</span><br><span class="line">        System.out.println(<span class="string">"交换后："</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a:</span><br><span class="line">                arr) &#123;</span><br><span class="line">            System.out.print(<span class="string">" "</span>+a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">交换前：</span><br><span class="line"> <span class="number">16</span> <span class="number">12</span> <span class="number">14</span> <span class="number">11</span> <span class="number">15</span> <span class="number">13</span></span><br><span class="line">gap=<span class="number">4</span></span><br><span class="line">交换的步骤：</span><br><span class="line"></span><br><span class="line">gap=<span class="number">1</span></span><br><span class="line">交换的步骤：</span><br><span class="line">[<span class="number">12</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">13</span>]</span><br><span class="line">[<span class="number">12</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">13</span>]</span><br><span class="line">[<span class="number">11</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">13</span>]</span><br><span class="line">[<span class="number">11</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">13</span>]</span><br><span class="line">[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>]</span><br><span class="line">交换后：</span><br><span class="line"> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span></span><br></pre></td></tr></table></figure><p>如此一来，就排序成功了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（十八）Future模式</title>
      <link href="/2019/12/31/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B18/"/>
      <url>/2019/12/31/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B18/</url>
      
        <content type="html"><![CDATA[<h3 id="Future模式"><a href="#Future模式" class="headerlink" title="Future模式"></a>Future模式</h3><p>Future模式是在多线程程序中设计中的一个非常常见的设计模式，它和Runnable非常类似，总整体而言，可以看作为有了返回值的Runnable。但是Future模式是继承Callable接口，重写call()方法的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Future模式的由来"><a href="#Future模式的由来" class="headerlink" title="Future模式的由来"></a>Future模式的由来</h4><p>Future模式的诞生也很贴近现实，我们的Runnable接口模式可以看做为很古老的 “一手交钱一手交货”，而Future模式则看作为，我们使用支票交易。这两者的区别在于哪里呢？Runnable要求你来交易的时候，必须去银行把钱全都取出来后，才可以交易，比如你运行的run方法，要工作完了，才可以交易，而Future模式则表示，我告诉你我能够给你钱，到时候你去银行取就可以了，我们先进行交易。这样的改进极大的提高了效率。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/future.png" alt="future"></p><p>就如上图所示main代表主系统，client表示客户要处理的信息，data表示客户最终要获得的信息，realdata表示实际的数据，而使用future可以先返回一个futuredata，给data，futuredata是realdata包装，futuredata先返回结果值到data中，然后realdata再慢慢返回全部的数据。这种模式可以应用到大规模的抽奖当中，抽奖的时候可以先返回你是否抽到奖，之后再慢慢返回抽到的奖品的具体信息。</p><h4 id="实现Future模式"><a href="#实现Future模式" class="headerlink" title="实现Future模式"></a>实现Future模式</h4><p>我们可以试着手写出这样的模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getResult</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureData</span> <span class="keyword">implements</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> RealData realData=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> isReady=<span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setRealData</span><span class="params">(RealData realData)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isReady)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.realData=realData;</span><br><span class="line">        isReady=<span class="keyword">true</span>;</span><br><span class="line">        System.out.println(<span class="string">"真实数据到达，唤醒getResult"</span>);</span><br><span class="line">        notifyAll();</span><br><span class="line">        <span class="comment">//当真实的数据已经到达之后，唤醒全部的线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!isReady)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"等待真实数据处理完毕"</span>);</span><br><span class="line">                wait();</span><br><span class="line">                <span class="comment">//等到真实的处理处理完毕</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> realData.result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealData</span> <span class="keyword">implements</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealData</span><span class="params">(String result)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb=<span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            sb.append(result);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                <span class="comment">//模拟线程真实数据的缓慢处理</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.result = sb.toString();</span><br><span class="line">        <span class="comment">//完成构造</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Data <span class="title">request</span> <span class="params">(<span class="keyword">final</span> String q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> FutureData future=<span class="keyword">new</span> FutureData();</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="comment">//真实数据构建比较慢，所以在单独的线程中运行</span></span><br><span class="line">                System.out.println(<span class="string">"开始对真实数据进行搭建"</span>);</span><br><span class="line">                RealData realData=<span class="keyword">new</span> RealData(q);</span><br><span class="line">                future.setRealData(realData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        System.out.println(<span class="string">"返回future"</span>);</span><br><span class="line">        <span class="keyword">return</span> future;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Client client=<span class="keyword">new</span> Client();</span><br><span class="line">        <span class="comment">//这里将立即返回，因为得到的是future凭证，而不是真实数据</span></span><br><span class="line">        Data data=client.request(<span class="string">"qwe"</span>);</span><br><span class="line">        System.out.println(<span class="string">"请求完毕"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//模拟其他业务的进行，不妨碍真实数据</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用真实的数据</span></span><br><span class="line">        System.out.println(<span class="string">"getResult:数据="</span>+data.getResult());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">返回future</span><br><span class="line">请求完毕</span><br><span class="line">开始对真实数据进行搭建</span><br><span class="line">真实数据到达，唤醒getResult</span><br><span class="line">getResult:数据=qweqweqweqweqweqweqweqweqweqwe</span><br></pre></td></tr></table></figure><p>可以看到，是先返回一个凭证，然后让程序接着运行下去，最后获得结果。</p><h4 id="JDK内置的Future模式"><a href="#JDK内置的Future模式" class="headerlink" title="JDK内置的Future模式"></a>JDK内置的Future模式</h4><p>这种Future模式在JDK当然内置也有，如图：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/future2.jpg" alt="fu2"></p><p>我们使用内置的Future模式来试试吧，它主要是继承一个Callable接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealData</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String para;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealData</span><span class="params">(String para)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.para = para;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StringBuffer sb=<span class="keyword">new</span> StringBuffer();</span><br><span class="line">        System.out.println(<span class="string">"开始搭建真实数据"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            sb.append(para);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"返回数据"</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//构造FutureTask</span></span><br><span class="line">        FutureTask&lt;String&gt; f=<span class="keyword">new</span> FutureTask&lt;String&gt;(<span class="keyword">new</span> RealData(<span class="string">"qwe"</span>));</span><br><span class="line">        <span class="comment">//这里会传入一个值表示使用真实的数据，而我们的真实数据会先返回Future凭证</span></span><br><span class="line">        ExecutorService es= Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">        es.submit(f);</span><br><span class="line">        System.out.println(<span class="string">"请求完毕"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"做些其他的事情"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"数据="</span>+f.get());</span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">请求完毕</span><br><span class="line">做些其他的事情</span><br><span class="line">开始搭建真实数据</span><br><span class="line">返回数据</span><br><span class="line">数据=qweqweqweqweqweqweqweqweqweqwe</span><br></pre></td></tr></table></figure><p>注意:这里和run方法的区别是，如果你使用Runable接口去实现，那么在run方法执行完之后，数据就没了，或者直接输出，但是，这样是不会被自己给控制的。这里使用的future，想让它什么时候输出数据，就什么时候输出数据。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（十七）常见的设计模式</title>
      <link href="/2019/12/30/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B17/"/>
      <url>/2019/12/30/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B17/</url>
      
        <content type="html"><![CDATA[<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式，也就是所谓的工厂模式，单例模式是在设计模式中非常常见的模式，也是应用最为普遍的模式之一。它的特点是：<strong>确保系统中的类只产生一个实例。</strong>运用这种模式带来的最直观的好处是，减小开销，提高效率。这种模式省略了大量的new操作，对于要大量的使用某些重量级对象的程序而言，有着极大的优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"创建一个实例"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance=<span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看，这就是一个单例工厂，设置构造函数为私有，让它不能够被随意的使用，设置它的对象为private，保证对象的私有，不会被外界肆意的修改，并且设置获取对象的函数也为私有，保证只会被本类所调用。</p><p>之所以这么做，是会让所有需要使用这个类的时候，实例只会在第一次被创建的时候使用new去创建它，之后的每一次使用，都只是return回一个实例而已，这个类没有set方法，也不是public型，可以很好的保证自身的安全。</p><p>但是，这样做也会有些不足，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> status=<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"创建一个实例"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> singleton instance=<span class="keyword">new</span> singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(singleton.status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">创建一个实例</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>test只是想要使用一个类里面的静态成员，并没有去创建这个类的实例，但它还是创建了，这个实例，虽然这样并不一定会出错，毕竟singleton也不可被修改，可这终归不可控。但是否可以被改造为可控？当然可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lazysingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> status=<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">lazysingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"创建一个延迟的实例"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> lazysingleton instance=<span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> lazysingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance=<span class="keyword">new</span> lazysingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(lazysingleton.status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这样便不会造成问题了，但随之而来的是，加了一个synchronized去保证不会被多次创建的时候，也极大的降低了效率。于是，我们便可以结合两者的优点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">staicsingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> status=<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">staicsingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"创建一个静态的实例"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">singlrtonholder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> staicsingleton instance=<span class="keyword">new</span> staicsingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> staicsingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singlrtonholder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(staicsingleton.status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>这样结合了两者的特点，使用一个静态的类去调用构造方法，这个和《effective Java》中的用静态方法去代替构造方法，有着异曲同工之妙。</p><h3 id="不变模式"><a href="#不变模式" class="headerlink" title="不变模式"></a>不变模式</h3><p>不变模式是在设计模式中，最为安全的模式。简而言之，不变模式通过把所有的类和属性，都设置为final型，使得它们永远的不可以被改变，从而保证了自身的安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">product</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置final型确保不会被子类继承给改变</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String no;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String price;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">product</span><span class="params">(String no, String name, String price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生产者—消费者模式"><a href="#生产者—消费者模式" class="headerlink" title="生产者—消费者模式"></a>生产者—消费者模式</h3><p>这个模式可以说是现实生活中很多场景的抽象，之前提到的BlockQueue，就是被运用在这种状态下的。就好似很多程序在被设计之初，如果将接收和处理，这两种操作结合到一起的话，虽然在一定程度上减少了程序的复杂程度，但是这会让整个程序的耦合度变得很高，一旦有什么需求的改动，或者客户端出现了些变化，就会导致整个系统变的更加复杂，甚至生涩难懂。所以，在现在，很多程序的设计都会运用到接收和处理的分离，就好似前端和后端的分离一样，两者变得不再互相依赖，想要这样的条件，就必须引用一个内存缓冲区，来作为数据的传输通道，而它们的实现，正是使用了BlockQueue。</p><p><img src="https://i.loli.net/2019/12/30/jOCf1pU57cXvmbW.png" alt="内存缓冲区"></p><p>而这个BlockQueue作为内存缓冲区来调节数据的运作。下面用一个实例来展示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PCData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> intdata;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PCData</span><span class="params">(<span class="keyword">int</span> intdata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.intdata = intdata;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PCData</span><span class="params">(String intdata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.intdata = Integer.valueOf(intdata);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIntdata</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> intdata;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"PCData&#123;"</span> +</span><br><span class="line">                <span class="string">"intdata="</span> + intdata +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isRunning =<span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> BlockingQueue&lt;PCData&gt; queue;</span><br><span class="line">        <span class="comment">//内存缓冲区</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger count=<span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        <span class="comment">//总数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> sleeptime=<span class="number">1000</span>;</span><br><span class="line">        <span class="comment">//线程睡眠时间</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">producer</span><span class="params">(BlockingQueue queue)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.queue=queue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                PCData data=<span class="keyword">null</span>;</span><br><span class="line">                Random r=<span class="keyword">new</span> Random();</span><br><span class="line">                System.out.println(<span class="string">"生产者线程"</span> +</span><br><span class="line">                        Thread.currentThread().getId()+<span class="string">"开始运行"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">while</span> (isRunning)&#123;</span><br><span class="line">                                Thread.sleep(r.nextInt(sleeptime));</span><br><span class="line">                                data=<span class="keyword">new</span> PCData(count.incrementAndGet());</span><br><span class="line">                                System.out.println(<span class="string">"数据入队成功！"</span>);</span><br><span class="line">                                <span class="keyword">if</span> (!queue.offer(data,<span class="number">2</span>, TimeUnit.SECONDS))&#123;</span><br><span class="line">                                        <span class="comment">//提交数据到缓冲区</span></span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">                isRunning=<span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.xml.internal.bind.v2.runtime.output.Pcdata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.MessageFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue &lt;PCData&gt; queue;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> sleeptime=<span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">consumer</span><span class="params">(BlockingQueue&lt;PCData&gt; queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"消费者线程"</span> +</span><br><span class="line">                Thread.currentThread().getId()+<span class="string">"开始运行"</span>);</span><br><span class="line"></span><br><span class="line">        Random r=<span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                PCData data=queue.take();</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span>!=data)&#123;</span><br><span class="line">                    <span class="keyword">int</span> re=data.getIntdata()*data.getIntdata();</span><br><span class="line">                    System.out.println(MessageFormat.format(<span class="string">"&#123;0&#125;*&#123;1&#125;=&#123;2&#125;"</span>,</span><br><span class="line">                            data.getIntdata(),</span><br><span class="line">                            data.getIntdata(),</span><br><span class="line">                            re));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            Thread.interrupted();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        LinkedBlockingQueue queue = <span class="keyword">new</span> LinkedBlockingQueue(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//建立缓冲区间</span></span><br><span class="line">        producer producer1=<span class="keyword">new</span> producer(queue);</span><br><span class="line">        producer producer2=<span class="keyword">new</span> producer(queue);</span><br><span class="line">        producer producer3=<span class="keyword">new</span> producer(queue);</span><br><span class="line">        consumer consumer1=<span class="keyword">new</span> consumer(queue);</span><br><span class="line">        consumer consumer2=<span class="keyword">new</span> consumer(queue);</span><br><span class="line">        consumer consumer3=<span class="keyword">new</span> consumer(queue);</span><br><span class="line"></span><br><span class="line">        ExecutorService es=Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//建立一个线程池</span></span><br><span class="line">        es.execute(producer1);</span><br><span class="line">        es.execute(producer2);</span><br><span class="line">        es.execute(producer3);</span><br><span class="line">        es.execute(consumer1);</span><br><span class="line">        es.execute(consumer2);</span><br><span class="line">        es.execute(consumer3);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        producer1.stop();</span><br><span class="line">        producer2.stop();</span><br><span class="line">        producer3.stop();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">消费者线程<span class="number">15</span>开始运行</span><br><span class="line">生产者线程<span class="number">14</span>开始运行</span><br><span class="line">消费者线程<span class="number">16</span>开始运行</span><br><span class="line">生产者线程<span class="number">13</span>开始运行</span><br><span class="line">生产者线程<span class="number">12</span>开始运行</span><br><span class="line">消费者线程<span class="number">17</span>开始运行</span><br><span class="line">数据入队成功！</span><br><span class="line"><span class="number">1</span>*<span class="number">1</span>=<span class="number">1</span></span><br><span class="line">数据入队成功！</span><br><span class="line"><span class="number">2</span>*<span class="number">2</span>=<span class="number">4</span></span><br><span class="line">数据入队成功！</span><br><span class="line"><span class="number">3</span>*<span class="number">3</span>=<span class="number">9</span></span><br><span class="line">数据入队成功！</span><br><span class="line"><span class="number">4</span>*<span class="number">4</span>=<span class="number">16</span></span><br><span class="line">数据入队成功！</span><br><span class="line"><span class="number">5</span>*<span class="number">5</span>=<span class="number">25</span></span><br><span class="line">数据入队成功！</span><br><span class="line"><span class="number">6</span>*<span class="number">6</span>=<span class="number">36</span></span><br><span class="line">数据入队成功！</span><br><span class="line"><span class="number">7</span>*<span class="number">7</span>=<span class="number">49</span></span><br><span class="line">数据入队成功！</span><br><span class="line"><span class="number">8</span>*<span class="number">8</span>=<span class="number">64</span></span><br><span class="line">数据入队成功！</span><br><span class="line"><span class="number">9</span>*<span class="number">9</span>=<span class="number">81</span></span><br><span class="line">数据入队成功！</span><br><span class="line"><span class="number">10</span>*<span class="number">10</span>=<span class="number">100</span></span><br></pre></td></tr></table></figure><p>可见 LinkedBlockingQueue这个队列承担了内存的缓冲区，作为一个程序的中间件，使得生产者和消费者连接起来，即使生产者并不认识消费者，也不知道彼此的工作方式，也可以通过建立缓冲区的方式，将它们连接起来。</p><h3 id="Disruptor：高性能的生产者和消费者框架"><a href="#Disruptor：高性能的生产者和消费者框架" class="headerlink" title="Disruptor：高性能的生产者和消费者框架"></a>Disruptor：高性能的生产者和消费者框架</h3><p>既然大家都能想的到用队列去实现内存缓冲区，那么也会有人想到该怎么去优化它，使其变的更好用，于是，一家名为LMAX的公司，便开发了一个高效的无锁内存队列，那就是Disruptor。Disruptor框架中，使用了一个环形的队列，叫做ringbuffer，这是一个有头尾两个指针的队列，而且数组大小为2的次幂。因为ringbuffer使用的是位运算符，它的sequence（队列）通过和queueSize-1的值做&amp;（与运算），能够快速的定位到实际元素的位置。注意，它和普通的环形队列相比，它并没有使用出队这个操作，而是用新覆盖旧元素的方法，去减少空间的分配和回收所需要的开销。</p><h4 id="重新实现这个案例"><a href="#重新实现这个案例" class="headerlink" title="重新实现这个案例"></a>重新实现这个案例</h4><p>我们可以尝试着用ringbuffer去重新实现它：(注：这需要外接一个jar包，jdk并不自带)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PCData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PCData</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PCData</span><span class="params">(<span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.EventFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PCDFactory</span> <span class="keyword">implements</span> <span class="title">EventFactory</span>&lt;<span class="title">PCData</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PCData <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PCData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.RingBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RingBuffer&lt;PCData&gt; ringBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">producer</span><span class="params">(RingBuffer&lt;PCData&gt; ringBuffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ringBuffer = ringBuffer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushData</span><span class="params">(ByteBuffer bb)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sequence = ringBuffer.next();</span><br><span class="line">        <span class="comment">//获取下一个可以使用的队列盒子</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PCData event =ringBuffer.get(sequence);</span><br><span class="line">            <span class="comment">//获取当前队列盒子中的值</span></span><br><span class="line">            event.setValue(bb.getLong(<span class="number">0</span>));</span><br><span class="line">            <span class="comment">//加将目标值设置为期望值，意思就是新值覆盖旧值，节省出队的开销</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            ringBuffer.publish(sequence);</span><br><span class="line">            <span class="comment">//加入已经制作完成的队列盒子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.WorkHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">consumer</span> <span class="keyword">implements</span> <span class="title">WorkHandler</span>&lt;<span class="title">PCData</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(PCData o)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getId()+<span class="string">"线程正在消费"</span> +</span><br><span class="line">                o.getValue()*o.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.BlockingWaitStrategy;</span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.RingBuffer;</span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.dsl.Disruptor;</span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.dsl.ProducerType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService es= Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//制作线程池</span></span><br><span class="line">        PCDFactory f=<span class="keyword">new</span> PCDFactory();</span><br><span class="line">        <span class="comment">//从工厂中制作一个新的实例，此处使用了单例模式</span></span><br><span class="line">        <span class="keyword">int</span> size=<span class="number">1024</span>;</span><br><span class="line">        <span class="comment">//队列的大小必须为2的次幂</span></span><br><span class="line">        Disruptor&lt;PCData&gt; disruptor=<span class="keyword">new</span> Disruptor&lt;PCData&gt;(f,</span><br><span class="line">                size,</span><br><span class="line">                es,</span><br><span class="line">                ProducerType.MULTI,</span><br><span class="line">                <span class="keyword">new</span> BlockingWaitStrategy());</span><br><span class="line">        <span class="comment">//每个参数分别为，实例，大小，线程池，生产者类型和策略</span></span><br><span class="line">        disruptor.handleEventsWithWorkerPool(</span><br><span class="line">                <span class="keyword">new</span> consumer(),</span><br><span class="line">                <span class="keyword">new</span> consumer(),</span><br><span class="line">                <span class="keyword">new</span> consumer(),</span><br><span class="line">                <span class="keyword">new</span> consumer()</span><br><span class="line">        );</span><br><span class="line">        disruptor.start();</span><br><span class="line"></span><br><span class="line">        RingBuffer&lt;PCData&gt; ringBuffer=disruptor.getRingBuffer();</span><br><span class="line">        <span class="comment">//将框架内容整合到环形队列中，这里算制作完了整个队列</span></span><br><span class="line">        producer p=<span class="keyword">new</span> producer(ringBuffer);</span><br><span class="line">        <span class="comment">//生产者添加环形队列，并表示可以正式生产</span></span><br><span class="line">        ByteBuffer bb= ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; <span class="keyword">true</span> ; i++) &#123;</span><br><span class="line"></span><br><span class="line">            bb.putLong(<span class="number">0</span>,i);</span><br><span class="line">            p.pushData(bb);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">"增加数据:"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">13</span>线程正在消费<span class="number">0</span></span><br><span class="line">增加数据:<span class="number">0</span></span><br><span class="line"><span class="number">16</span>线程正在消费<span class="number">1</span></span><br><span class="line">增加数据:<span class="number">1</span></span><br><span class="line"><span class="number">15</span>线程正在消费<span class="number">4</span></span><br><span class="line">增加数据:<span class="number">2</span></span><br><span class="line"><span class="number">14</span>线程正在消费<span class="number">9</span></span><br><span class="line">增加数据:<span class="number">3</span></span><br><span class="line"><span class="number">13</span>线程正在消费<span class="number">16</span></span><br><span class="line">增加数据:<span class="number">4</span></span><br><span class="line"><span class="number">16</span>线程正在消费<span class="number">25</span></span><br><span class="line">增加数据:<span class="number">5</span></span><br><span class="line"><span class="number">15</span>线程正在消费<span class="number">36</span></span><br><span class="line">增加数据:<span class="number">6</span></span><br><span class="line"><span class="number">14</span>线程正在消费<span class="number">49</span></span><br><span class="line">增加数据:<span class="number">7</span></span><br><span class="line"><span class="number">13</span>线程正在消费<span class="number">64</span></span><br><span class="line">增加数据:<span class="number">8</span></span><br><span class="line"><span class="number">16</span>线程正在消费<span class="number">81</span></span><br><span class="line">增加数据:<span class="number">9</span></span><br><span class="line"><span class="number">15</span>线程正在消费<span class="number">100</span></span><br><span class="line">增加数据:<span class="number">10</span></span><br><span class="line"><span class="number">14</span>线程正在消费<span class="number">121</span></span><br><span class="line">增加数据:<span class="number">11</span></span><br><span class="line"><span class="number">13</span>线程正在消费<span class="number">144</span></span><br><span class="line">增加数据:<span class="number">12</span></span><br><span class="line"><span class="number">16</span>线程正在消费<span class="number">169</span></span><br><span class="line">增加数据:<span class="number">13</span></span><br><span class="line"><span class="number">15</span>线程正在消费<span class="number">196</span></span><br><span class="line">增加数据:<span class="number">14</span></span><br><span class="line"><span class="number">14</span>线程正在消费<span class="number">225</span></span><br></pre></td></tr></table></figure><p>消费者在继承了WorkHandler的接口后，会要求重写消费该队列的方法，每次在生产者中使用了ringBuffer.publish(sequence);加入一个元素后，消费者会自动去调用重写的消费方法，去使用这个元素，比如求这个元素的平方。之所以使用bytebuffer去存储元素，是因为它能够存放任何的数据类型。每次存放一个数据后，都要使用next方法去继续获得下一个元素所存放的盒子。整个数据结构的图示如下：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/ringbuffer.jpg" alt="ringbuffer"></p><h4 id="选择合适的策略"><a href="#选择合适的策略" class="headerlink" title="选择合适的策略"></a>选择合适的策略</h4><p>Disruptor在制作的时候，最后一个参数叫做BlockingWaitStrategy，这是disruptor的一个默认的策略，它和blockqueue非常类似，都是使用阻塞的方式，使用锁和条件(condition)进行阻塞，这种情况下非常节省cpu的使用，但使用着阻塞，便意味着在高并发的情况下，效果不会那么理想。接下来总结一个有哪些策略：</p><ol><li>sleepWaitStrategy：这个策略虽然不进行将线程挂起的操作，但是会使用自旋的方式让获取资源，这个策略不会占用太多的CPU资源，但是对数据处理效率也不高，甚至比阻塞的效率更低一点。好处就是，对生产者线程的影响非常小，比较适合异步日志。</li><li>BlockingWaitStrategy：使用锁和条件去阻塞队列，保证线程安全，但在高并发情况下效率低下。</li><li>YieldWaitStrategy：这个策略去CPU要求很高，消费者非常疯狂的去获得生产者所加入的元素，因为它的消费者会在内部执行一个Threa.yield的死循环。</li><li>BusySpinWaitStrategy：这个策略效率非常非常的高，但是它会使用掉几乎所有的CPU资源。</li></ol><h4 id="CPU的Cache优化"><a href="#CPU的Cache优化" class="headerlink" title="CPU的Cache优化"></a>CPU的Cache优化</h4><p>上述的一些策略，都是为了调节CPU资源等等的问题，可见CPU在程序中的重要性，我们除了要从框架上优化和调节CPU的使用之外，我们也要稍微了解一下CPU的机制，在讲述volatile的时候，使用了这一张图：<img src="https://gitee.com/antarctica/img_sotre/raw/img/img/volatileyuanli.png" alt="volatile"></p><p>这张图也可以表示出，CPU都是从缓存中获取数据。但是要注意，每个数据被加入到cache中的时候，并不是单个单个存在的：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/cpu1.png" alt="CPU1"></p><p>像这样，每次在将一个新的x被更新后，就会使得所有和x层所在的元素，一同被声明为无效，对于这样的情况，我们的程序都可以想办法对cpu进行优化，这优化在《Java并发编程艺术》一书中也有所提及，就是想办法将其凑够一行，如图：<br><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/cpu2.png" alt="cpu2"></p><p>这样，每次被声明无效过后，只有x会被无效化，而y不会，这也是典型的以空间去换时间的做法，那我们可以在实际中试一试看看真的能不能提高效率。(注：使用JDK7)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> 解决<span class="title">cpu</span>的<span class="title">cache</span>优化问题 <span class="keyword">implements</span> <span class="title">Runnable</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM_THREADS=<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ITERATIONS=<span class="number">500L</span>*<span class="number">1000L</span>*<span class="number">1000L</span>;</span><br><span class="line">    <span class="comment">//项目大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> arrayindex;</span><br><span class="line">    <span class="comment">//数组的索引</span></span><br><span class="line">    <span class="keyword">public</span> 解决cpu的cache优化问题(<span class="keyword">int</span> arrayindex) &#123;</span><br><span class="line">        <span class="keyword">this</span>.arrayindex = arrayindex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileLong</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">long</span> q1,q2,q3,q4,q5,q6,q7;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value=<span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">long</span> p1,p2,p3,p4,p5,p6,p7;</span><br><span class="line">        <span class="comment">//填充物，这关系到测试的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> VolatileLong[] longs=<span class="keyword">new</span> VolatileLong[NUM_THREADS];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;longs.length ; i++) &#123;</span><br><span class="line">            longs[i]=<span class="keyword">new</span> VolatileLong();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> start =System.currentTimeMillis();</span><br><span class="line">        Runtest();</span><br><span class="line">        System.out.println(<span class="string">"持续时间="</span>+(System.currentTimeMillis()-start));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Runtest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread[] ts=<span class="keyword">new</span> Thread[NUM_THREADS];</span><br><span class="line">        <span class="comment">//2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;ts.length ; i++) &#123;</span><br><span class="line">            ts[i]=<span class="keyword">new</span> Thread(<span class="keyword">new</span> 解决cpu的cache优化问题(i));</span><br><span class="line">            <span class="comment">//建立测试线程</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread t:</span><br><span class="line">             ts) &#123;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread t:</span><br><span class="line">             ts) &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> i=ITERATIONS+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">0</span>!=--i)&#123;</span><br><span class="line">            longs[arrayindex].value=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 持续时间=3514</span></span><br></pre></td></tr></table></figure><p>那我们把填充物给注释掉呢，看看结果会怎么样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 持续时间=8312</span></span><br></pre></td></tr></table></figure><p>可以看到性能差距非常之大。为什么呢？因为CPU的每次缓存，都是缓存64的字节数，一个对象的引用一般占用4个字节，而在这里填充15个字节，使得缓存满64个字节，这样，便优化了效率。</p><p>但是注意，这里使用的是JDK7，因为jdk8会自动优化不使用的字段，这样我们的填充物就被所谓的 “优化”给优化没了，这可能就是所谓的负优化把……</p><p>而我们所使用的Disruptor就考虑到了这一层，所以，在总体实现上Disruptor的ringbuffer队列会比传统的LinkingBlockQueue快了很多。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（十六）死锁状态</title>
      <link href="/2019/12/30/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B16/"/>
      <url>/2019/12/30/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B16/</url>
      
        <content type="html"><![CDATA[<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>在实际应用上，使用锁的环境远远要多于使用无锁。但是经常使用锁，一般都会面对一个问题，那就是死锁，现在用一个例子，简单的阐述死锁。</p><h4 id="哲学家的餐桌"><a href="#哲学家的餐桌" class="headerlink" title="哲学家的餐桌"></a>哲学家的餐桌</h4><p>哲学家就餐问题就是一个常见的死锁问题。有四个哲学家坐在一个正方形的桌子上面，每个桌角都放置有一个叉子，而哲学家必须使用两个叉子才能正常进餐，但是哲学家们并不一直用餐，它们有时候还会停止进餐，用一段时间去思考哲学问题，这样的话，餐桌上的叉子就一直都处于被竞争的状态，最多时，可以同时存在两个哲学家进餐，两个哲学家思考。但是，又因为哲学家们从不进行交谈，这就会产生一个问题，如果有一个哲学家只拿到了右边的叉子，需要等待左边的叉子的时候，左边的哲学家也在等待他左边的叉子，这样互相等待而不行动的状态，称之为死锁状态。这里就举一个最简单的例子，只有两个哲学家在吃饭。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Object tool;</span><br><span class="line">    <span class="keyword">static</span> Object f1=<span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> Object f2=<span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">test</span><span class="params">(Object tool)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tool = tool;</span><br><span class="line">        <span class="keyword">if</span> (tool==f1)&#123;</span><br><span class="line">            <span class="keyword">this</span>.setName(<span class="string">"哲学家A"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tool==f2)&#123;</span><br><span class="line">            <span class="keyword">this</span>.setName(<span class="string">"哲学家B"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        test 哲学家A=<span class="keyword">new</span> test(f1);</span><br><span class="line">        test 哲学家B=<span class="keyword">new</span> test(f2);</span><br><span class="line">        哲学家A.start();</span><br><span class="line">        哲学家B.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tool==f1)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (f1)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (f2)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"哲学家A开始进餐"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tool==f2)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (f2)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (f1)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"哲学家B开始进餐"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动后发现进程并不会结束，将永久运行一下，因为它们在互相获取彼此的叉子的时候，又互相被锁住了。此时打开任务管理器，可以看到并不占用CPU ，因为产生了死锁，谁都没有行动。</p><p>也可以使用jps工具和jstack工具（只要能使用javac，就能使用这些工具）从cmd打印出到底出了什么问题哦!</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/jps.png" alt="jps"></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">"哲学家B":</span><br><span class="line">  waiting to lock monitor <span class="number">0</span>x000000000ae4f488 (object <span class="number">0</span>x00000000db0a48a0, a java.lang.Object),</span><br><span class="line">  which is held by "哲学家A"</span><br><span class="line">"哲学家A":</span><br><span class="line">  waiting to lock monitor <span class="number">0</span>x000000000ae4c9e8 (object <span class="number">0</span>x00000000db0a48b0, a java.lang.Object),</span><br><span class="line">  which is held by "哲学家B"</span><br><span class="line"></span><br><span class="line">Java stack information <span class="keyword">for</span> the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">"哲学家B":</span><br><span class="line">        <span class="built_in">at</span> test.run(test.java:<span class="number">46</span>)</span><br><span class="line">        - waiting to lock &lt;<span class="number">0</span>x00000000db0a48a0&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;<span class="number">0</span>x00000000db0a48b0&gt; (a java.lang.Object)</span><br><span class="line">"哲学家A":</span><br><span class="line">        <span class="built_in">at</span> test.run(test.java:<span class="number">34</span>)</span><br><span class="line">        - waiting to lock &lt;<span class="number">0</span>x00000000db0a48b0&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;<span class="number">0</span>x00000000db0a48a0&gt; (a java.lang.Object)</span><br><span class="line"></span><br><span class="line">Found <span class="number">1</span> deadlock.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（十五）线程互助的SynchronousQueue</title>
      <link href="/2019/12/29/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B15/"/>
      <url>/2019/12/29/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B15/</url>
      
        <content type="html"><![CDATA[<h4 id="让线程之间互相帮助：SynchronousQueue"><a href="#让线程之间互相帮助：SynchronousQueue" class="headerlink" title="让线程之间互相帮助：SynchronousQueue"></a>让线程之间互相帮助：SynchronousQueue</h4><p>在线程池的介绍当中，提到一个非常特殊的队列，叫做SynchronousQueue。它的容量为0，对任何一个写操作，都要等待一个读操作，可以把SynchronousQueue看做为一个数据的交换通道。讲到这样一个需要等待操作的方法，不得不提到之前的LinkedBLockQueue，它的put方法和take方法，正是需要等待队列的来唤醒，而我们这个SynchronousQueue，也正有着异曲同工之秒，它的put方法和take方法都涉及到了一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transferer.transfer(o, <span class="keyword">false</span>, <span class="number">0</span>) == <span class="keyword">null</span>)<span class="comment">//put</span></span><br><span class="line">transferer.transfer(<span class="keyword">null</span>, <span class="keyword">false</span>, <span class="number">0</span>)<span class="comment">//take</span></span><br></pre></td></tr></table></figure><p>而这个方法的参数有哪些呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> Object <span class="title">transfer</span><span class="params">(Object e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span>;</span><br></pre></td></tr></table></figure><p>可以看到，这个是一个抽象方法，等待SynchronousQueue去实现，而第一个值Object表示是否传入参数，第二个值表示是否传入存在时间，第三个值表示时长。为什么要这么做呢？因为如果传入的值一直都没有相应的take操作将其取出，就会导致堵塞，这样会使得SynchronousQueue不能正常工作，所以需要设定自我销毁时间。</p><p>transfer主要分三个部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                SNode h = head;</span><br><span class="line">                <span class="keyword">if</span> (h == <span class="keyword">null</span> || h.mode == mode) &#123;  <span class="comment">// empty or same-mode</span></span><br><span class="line">                    <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>) &#123;      <span class="comment">// can't wait</span></span><br><span class="line">                        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.isCancelled())</span><br><span class="line">                            casHead(h, h.next);     <span class="comment">// pop cancelled node</span></span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s = snode(s, e, h, mode))) &#123;</span><br><span class="line">                        SNode m = awaitFulfill(s, timed, nanos);</span><br><span class="line">                        <span class="keyword">if</span> (m == s) &#123;               <span class="comment">// wait was cancelled</span></span><br><span class="line">                            clean(s);</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> ((h = head) != <span class="keyword">null</span> &amp;&amp; h.next == s)</span><br><span class="line">                            casHead(h, s.next);     <span class="comment">// help s's fulfiller</span></span><br><span class="line">                        <span class="keyword">return</span> (mode == REQUEST) ? m.item : s.item;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>根据SynchronousQueue的特性，对任何一个写操作，都要等待一个读操作。一开始的SNode表示等待队列的节点，之后的if所判断的是如果队列为空，则直接返回空，或者队列中元素的模式和本次操作相同。比如都是读操作，则需要等待入队，从elseif开始，表示入队成功，之后节点就会处于自旋、等待的状态，直到有一个相应的线程使其唤醒。之后的操作则是帮助两个头部节点完成出队的操作，当然，这帮助不一定会有效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!isFulfilling(h.mode)) &#123; <span class="comment">// try to fulfill</span></span><br><span class="line">                    <span class="keyword">if</span> (h.isCancelled())            <span class="comment">// already cancelled</span></span><br><span class="line">                        casHead(h, h.next);         <span class="comment">// pop and retry</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s=snode(s, e, h, FULFILLING|mode))) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (;;) &#123; <span class="comment">// loop until matched or waiters disappear</span></span><br><span class="line">                            SNode m = s.next;       <span class="comment">// m is s's match</span></span><br><span class="line">                            <span class="keyword">if</span> (m == <span class="keyword">null</span>) &#123;        <span class="comment">// all waiters are gone</span></span><br><span class="line">                                casHead(s, <span class="keyword">null</span>);   <span class="comment">// pop fulfill node</span></span><br><span class="line">                                s = <span class="keyword">null</span>;           <span class="comment">// use new node next time</span></span><br><span class="line">                                <span class="keyword">break</span>;              <span class="comment">// restart main loop</span></span><br><span class="line">                            &#125;</span><br><span class="line">                            SNode mn = m.next;</span><br><span class="line">                            <span class="keyword">if</span> (m.tryMatch(s)) &#123;</span><br><span class="line">                                casHead(s, mn);     <span class="comment">// pop both s and m</span></span><br><span class="line">                                <span class="keyword">return</span> (mode == REQUEST) ? m.item : s.item;</span><br><span class="line">                            &#125; <span class="keyword">else</span>                  <span class="comment">// lost match</span></span><br><span class="line">                                s.casNext(m, mn);   <span class="comment">// help unlink</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>如果等待队列和本次操作，是互补的，那么就插入一个完成状态的节点，让他匹配到一个等待节点上，之后弹出这两个节点，并且使得对应的两个线程继续执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;                            <span class="comment">// help a fulfiller</span></span><br><span class="line">                    SNode m = h.next;               <span class="comment">// m is h's match</span></span><br><span class="line">                    <span class="keyword">if</span> (m == <span class="keyword">null</span>)                  <span class="comment">// waiter is gone</span></span><br><span class="line">                        casHead(h, <span class="keyword">null</span>);           <span class="comment">// pop fulfilling node</span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        SNode mn = m.next;</span><br><span class="line">                        <span class="keyword">if</span> (m.tryMatch(h))          <span class="comment">// help match</span></span><br><span class="line">                            casHead(h, mn);         <span class="comment">// pop both h and m</span></span><br><span class="line">                        <span class="keyword">else</span>                        <span class="comment">// lost match</span></span><br><span class="line">                            h.casNext(m, mn);       <span class="comment">// help unlink</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>如果线程发现等待队列的节点就是完成节点，那么帮助这个节点完成任务，其流程和步骤2是一样的。</p><p>下面用一个实际例子去展示：例子来自于：<a href="https://blog.csdn.net/yanyan19880509/article/details/52562039" target="_blank" rel="noopener">https://blog.csdn.net/yanyan19880509/article/details/52562039</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 关于<span class="title">SynchronousQueueTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SynchronousQueue&lt;Integer&gt; queue = <span class="keyword">new</span> SynchronousQueue&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        Thread putThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"put 线程开始"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.put(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"put 线程结束"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread takeThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"take 线程开始"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"take 来自于 put线程: "</span> + queue.take());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"take 线程结束"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        putThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        takeThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，必须等待其他的线程使用take操作的时候，才能够让put的线程继续运行下去。这正是SynchronousQueue的特点，它不能够容乃任何事物，只能是一个任意门，一个通道，它是不能存放任何实体的。（注：SynchronousQueue内部没有容器指的是没有像数组那样的内存空间存多个元素，但是是有单地址内存空间，用于交换数据）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（十四）无锁状态</title>
      <link href="/2019/12/29/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B14/"/>
      <url>/2019/12/29/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B14/</url>
      
        <content type="html"><![CDATA[<h3 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h3><p>加锁是保证线程安全的常用手法，但是被加锁之后，往往会产生一些效率的问题，那不使用锁，也能保证线程安全吗？当然可以，并且，使用无锁的方法去实现的线程安全，不仅仅在效率上占优，而且，还不会产生死锁的问题哦。</p><h4 id="无锁的策略：CAS-Compare-And-Swap"><a href="#无锁的策略：CAS-Compare-And-Swap" class="headerlink" title="无锁的策略：CAS(Compare And Swap)"></a>无锁的策略：CAS(Compare And Swap)</h4><p>经常被使用的无锁方法，叫做CAS，就是比较和交换。它不是一个固定的类或者方法，而是一个常用的策略，是一个算法。CAS通常包括着三个参数（V,E,N）V代表着即将要被更新的变量，E代表着预期的值，N代表着新的值，只有当且仅当V=E的时候，才会把V更新为N。这表示着如果有多个线程企图使用CAS操作去更新一个值的时候，只有一个会更新成功，并且把更新成功后其他线程的E变换为更新过后的值，导致了其他线程的V！=E 从而使得其他线程的更新操作失败，不过，这并不会直接导致他们取消这次操作，而是让他们再次开始<strong>自旋</strong>去尝试进行CAS操作。</p><h4 id="AtomicInteger：无锁的线程安全整数"><a href="#AtomicInteger：无锁的线程安全整数" class="headerlink" title="AtomicInteger：无锁的线程安全整数"></a>AtomicInteger：无锁的线程安全整数</h4><p>AtomicInteger是一个使用CAS操作去实现的类，它是一个无锁的、线程安全的整体，它的任何类似于i++之类的操作，即使没有被加上锁，依然是线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicInteger a=<span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> test());</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> test());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(<span class="string">"a="</span>+a);</span><br><span class="line">        ExecutorService es= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            es.submit(<span class="keyword">new</span> test());</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        es.shutdown();</span><br><span class="line">        System.out.println(<span class="string">"a="</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">100000</span>; i++) &#123;</span><br><span class="line">            a.incrementAndGet();<span class="comment">//a++操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a=<span class="number">200000</span></span><br><span class="line">a=<span class="number">1200000</span></span><br></pre></td></tr></table></figure><p>可以看到，无论是单独的使用线程，还是使用线程池，它们对于a的++操作，都是线程安全的。而AtomicInteger常用的方法有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span><span class="comment">//i++</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span><span class="comment">//i--</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span><span class="comment">//i+delta</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span><span class="comment">//++i</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">decrementAndGet</span><span class="params">()</span><span class="comment">//--i</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> delta)</span><span class="comment">//delta+i</span></span></span><br><span class="line"><span class="function">    <span class="comment">//注意顺序</span></span></span><br></pre></td></tr></table></figure><p>我们看看incrementAndGet()的源码吧！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jdk8，经过了层层封装，就以JDK7为例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> var5;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">        &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//jdk7</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = get();<span class="comment">//获取值</span></span><br><span class="line">            <span class="keyword">int</span> next = current + <span class="number">1</span>;<span class="comment">//创建新的对象使其+1，这种本身不变，通过创建新值的方式，来使自己增加，更具有安全性</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(current, next))<span class="comment">//CAS操作</span></span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>一开始看到这个for (;;) 它是一个无限的循环，正如开头所说的那样，就算失败也不会返回false，而是进行不断地尝试，直到正确为止。第二，这个CAS操作会在自己的线程中创建一个新的值，这样的线程局部变量仅仅对自身有效，而在执行CAS操作的时候，如果在这个时候，目标的值被改变，就不会返回，而是自旋，直到成功为止。</p><h4 id="Unsafe：Java中的指针"><a href="#Unsafe：Java中的指针" class="headerlink" title="Unsafe：Java中的指针"></a>Unsafe：Java中的指针</h4><p>看到无论是JDK7还是JDK8，都使用了一个叫做Unfase的类去调用CAS操作，在compareAndSet中，有着四个参数，this代表的是自身这个对象，valueOffset代表着目标的偏移量，expect是旧值，update是新值。而Java中其实并没有指针，所以他是不安全的，是Unsafe的，而这个valueOffset就是一个字段到目标头部的偏移量，通过这个偏移量快速定位字段，看不懂也没关系，这涉及到底层实现。</p><p>在AtomicInteger中，Unsafe有这样的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br></pre></td></tr></table></figure><p>它实际获取的是Unsafe这个类中的getUnsafe方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Class var0 = Reflection.getCallerClass();</span><br><span class="line">    <span class="keyword">if</span> (var0.getClassLoader() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Unsafe"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> theUnsafe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它有一个特别的地方，在那个if的判断语句当中，有着var0.getClassLoader() != null ，这个判断，它表示着如果这个类的类加载器不为空，则直接抛出异常，并且停止工作，这使我们无法直接去使用这个类，说明它是一个JDK内部的专属类，不可以被外部对象所使用。也就是说，我们不需要或不能去直接使用Unsafe，而是应该通过CAS去操纵它。</p><h4 id="AtomReference：无锁的对象引用"><a href="#AtomReference：无锁的对象引用" class="headerlink" title="AtomReference：无锁的对象引用"></a>AtomReference：无锁的对象引用</h4><p>除了AtomicInteger这样对整数进行无锁，却又能保证线程安全的类之外，设计者当然也考虑到了对象的线程安全使用问题。它的使用和AtomicInteger非常类似，在此不多赘述，只展示区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> AtomicReference&lt;String&gt; a=<span class="keyword">new</span> AtomicReference&lt;String&gt;();<span class="comment">//被定义</span></span><br><span class="line"><span class="comment">//内部实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getAndSet</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            V x = get();</span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(x, newValue))</span><br><span class="line">                <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>但是需要补充的是，它们都涉及到了一个问题：对象的值被修改回原值，到底算不算修改。比如有三个线程ABC，A把i=1修改成i=2，B把i=2，再修改成i=1,那么对于C线程来说，i在进行CAS比较的时候，到底是被修改了还是没有被修改呢？但从代码上而言，对于C线程来说，i没有被修改，应该继续去执行CAS操作，而不是看做为被修改，从而再次循环。这或许在思维和逻辑上表示正确，但是现实生活中，却不应该是这样子，比如家里人给你1000块钱生活费，你一到账就用3秒时间全部还了花呗，你不能说在1分钟后，家里人问你到账没有，你说没有。实际上你确确实实花了那一部分钱，但这个在CAS操作中并没有被记录而已。接下来我们使用代码去还原当时的场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicReference&lt;Integer&gt; money=<span class="keyword">new</span> AtomicReference&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        money.set(<span class="number">900</span>);</span><br><span class="line">        <span class="comment">//你有900块</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">3</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                        Integer m=money.get();</span><br><span class="line">                        <span class="keyword">if</span>(m&lt;<span class="number">1000</span>)&#123;<span class="comment">//生活费不足</span></span><br><span class="line">                            <span class="keyword">if</span>(money.compareAndSet(m,m+<span class="number">1000</span>))&#123;</span><br><span class="line">                                System.out.println(<span class="string">"不足1000元，已打钱，余额："</span>+money.get());</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//System.out.println("还不需要");</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">100</span> ; i++) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                        Integer m=money.get();</span><br><span class="line">                        <span class="keyword">if</span>(m&gt;<span class="number">500</span>)&#123;<span class="comment">//还花呗</span></span><br><span class="line">                            System.out.println(<span class="string">"大于500块"</span>);</span><br><span class="line">                            <span class="keyword">if</span> (money.compareAndSet(m,m-<span class="number">500</span>))&#123;</span><br><span class="line">                                System.out.println(<span class="string">"成功还款500，余额："</span>+money.get());</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">"没有足够金额"</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">不足<span class="number">1000</span>元，已打钱，余额：<span class="number">1900</span></span><br><span class="line">大于<span class="number">500</span>块</span><br><span class="line">成功还款<span class="number">500</span>，余额：<span class="number">1400</span></span><br><span class="line">大于<span class="number">500</span>块</span><br><span class="line">成功还款<span class="number">500</span>，余额：<span class="number">900</span></span><br><span class="line">不足<span class="number">1000</span>元，已打钱，余额：<span class="number">1900</span></span><br><span class="line">大于<span class="number">500</span>块</span><br><span class="line">成功还款<span class="number">500</span>，余额：<span class="number">1400</span></span><br><span class="line">大于<span class="number">500</span>块</span><br><span class="line">成功还款<span class="number">500</span>，余额：<span class="number">900</span></span><br><span class="line">不足<span class="number">1000</span>元，已打钱，余额：<span class="number">1900</span></span><br></pre></td></tr></table></figure><p>这种几率非常非常的小，但是还是有可能发生的，为了解决这样的问题，就诞生了AtomicStampedReference。当然，也可以使用带版本号的方式去辨别。</p><h4 id="AtomicStampedReference：带有时间戳的对象引用"><a href="#AtomicStampedReference：带有时间戳的对象引用" class="headerlink" title="AtomicStampedReference：带有时间戳的对象引用"></a>AtomicStampedReference：带有时间戳的对象引用</h4><p>它会产生一个时间戳单位，并且在进行CAS的时候，会多传入两个参数，使其同时进行CAS操作，让它的时间戳+1，这样，修改了时间戳之后，代表了执行成功，就不会再次执行这样的操作了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//源码  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">        Pair&lt;V&gt; current = pair;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">            expectedReference == current.reference &amp;&amp;</span><br><span class="line">            expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">            ((newReference == current.reference &amp;&amp;</span><br><span class="line">              newStamp == current.stamp) ||</span><br><span class="line">             casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//修改后</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; money=<span class="keyword">new</span> AtomicStampedReference&lt;Integer&gt;(<span class="number">900</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">3</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> time=money.getStamp();<span class="comment">//获取了时间戳</span></span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                        Integer m=money.getReference();</span><br><span class="line">                        <span class="keyword">if</span>(m&lt;<span class="number">1000</span>)&#123;<span class="comment">//生活费不足</span></span><br><span class="line">                            <span class="keyword">if</span>(money.compareAndSet(m,m+<span class="number">1000</span>,time,time+<span class="number">1</span>))&#123;<span class="comment">//多传入了两个参数</span></span><br><span class="line">                                System.out.println(<span class="string">"不足1000元，已打钱，余额："</span>+money.getReference());</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//System.out.println("还不需要");</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">100</span> ; i++) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                        <span class="keyword">int</span> time=money.getStamp();</span><br><span class="line">                        Integer m=money.getReference();</span><br><span class="line">                        <span class="keyword">if</span>(m&gt;<span class="number">500</span>)&#123;<span class="comment">//还花呗</span></span><br><span class="line">                            System.out.println(<span class="string">"大于500块"</span>);</span><br><span class="line">                            <span class="keyword">if</span> (money.compareAndSet(m,m-<span class="number">500</span>,time,time+<span class="number">1</span>))&#123;</span><br><span class="line">                                System.out.println(<span class="string">"成功还款500，余额："</span>+money.getReference());</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">"没有足够金额"</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">不足<span class="number">1000</span>元，已打钱，余额：<span class="number">1900</span></span><br><span class="line">大于<span class="number">500</span>块</span><br><span class="line">成功还款<span class="number">500</span>，余额：<span class="number">1400</span></span><br><span class="line">大于<span class="number">500</span>块</span><br><span class="line">成功还款<span class="number">500</span>，余额：<span class="number">900</span></span><br><span class="line">大于<span class="number">500</span>块</span><br><span class="line">成功还款<span class="number">500</span>，余额：<span class="number">400</span></span><br><span class="line">没有足够金额</span><br><span class="line">没有足够金额</span><br><span class="line">没有足够金额</span><br></pre></td></tr></table></figure><h4 id="AtomicIntegerArray：无锁的数组"><a href="#AtomicIntegerArray：无锁的数组" class="headerlink" title="AtomicIntegerArray：无锁的数组"></a>AtomicIntegerArray：无锁的数组</h4><p>同理，这里仅仅是简单展示一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicIntegerArray a=<span class="keyword">new</span> AtomicIntegerArray(<span class="number">10</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> test());</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> test());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(<span class="string">"a="</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">100000</span>; i++) &#123;</span><br><span class="line">            a.incrementAndGet(i%a.length());<span class="comment">//a++操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a=[<span class="number">20000</span>, <span class="number">20000</span>, <span class="number">20000</span>, <span class="number">20000</span>, <span class="number">20000</span>, <span class="number">20000</span>, <span class="number">20000</span>, <span class="number">20000</span>, <span class="number">20000</span>, <span class="number">20000</span>]</span><br></pre></td></tr></table></figure><h4 id="AtomicIntegerFieldUpdater：使int型也拥有原子性"><a href="#AtomicIntegerFieldUpdater：使int型也拥有原子性" class="headerlink" title="AtomicIntegerFieldUpdater：使int型也拥有原子性"></a>AtomicIntegerFieldUpdater：使int型也拥有原子性</h4><p>在实际开发过程中，由于初期考虑不周，没有对某些类设计为原子性，可能会在以后所应用的某些场景，出现线程安全的问题。就比如一些餐馆的菜单类在ID字段上设计为int型，很多时候我们并不需要去频繁的改动它，或者说，这菜品的ID也只是一个只读类型。但是在之后的过程中，这家餐馆被收购了，需要非常频繁的去改动菜品的ID，这就会涉及到数据不一致的问题，但是当初被设计的时候没有被考虑到，如果我们需要更改的话，可能会非常麻烦或者出现其他的错误，所以与其修改，不如去增加，这样更安全。所以我们使用AtomicIntegerFieldUpdater，去实现它。</p><p>举一个场景，某一地要进行一个选举，现在开始模拟投票场景，如果选民投了候选人一票，就记为1，否则为0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerFieldUpdater;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">candidate</span></span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;candidate&gt; scoreUpdater</span><br><span class="line">            =AtomicIntegerFieldUpdater.newUpdater(candidate.class,"score");</span><br><span class="line">    <span class="comment">//传入一个泛型，在newUpdater中传入要绑定的类和类属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AtomicInteger all=<span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//总票数,用于检查updater工作是否正确</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> candidate stu=<span class="keyword">new</span> candidate();<span class="comment">//一个类的实例</span></span><br><span class="line">        Thread[] t=<span class="keyword">new</span> Thread[<span class="number">10000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10000</span> ; i++) &#123;</span><br><span class="line">            t[i]=<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (Math.random()&gt;<span class="number">0.4</span>)&#123;<span class="comment">//假设有60%的人投了票</span></span><br><span class="line">                        scoreUpdater.incrementAndGet(stu);<span class="comment">//安全的增加这个类的属性的值，即使它不是AtomicInteger型</span></span><br><span class="line">                        all.incrementAndGet();<span class="comment">//起到验证作用</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10000</span> ; i++) &#123;</span><br><span class="line">            t[i].join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"score="</span>+stu.score);</span><br><span class="line">        System.out.println(<span class="string">"all="</span>+all);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//score=6013</span></span><br><span class="line"><span class="comment">//all=6013</span></span><br></pre></td></tr></table></figure><p>模拟这个选举，有60%的人投了这个候选人，那么使用这个候选人的属性，使得它绑定到scoreUpdater，使其成为原子的。因此做了个试验去验证。我们再来看看它是怎么实现的吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">AtomicIntegerFieldUpdater&lt;U&gt; <span class="title">newUpdater</span><span class="params">(Class&lt;U&gt; tclass, String fieldName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AtomicIntegerFieldUpdaterImpl&lt;U&gt;(tclass, fieldName, Reflection.getCallerClass());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>它传入的参数，一个是calss的值，一个是calss的属性，然后定位到这个类的属性，将其绑定成AtomicInteger，并且返回。最后使用AtomicIntegerFieldUpdater要注意几点：</p><ol><li>Updater只能修改可见变量，因为在源码中，使用了反射，所以score不能设置为private。</li><li>必须声明为volatile型</li><li>它的AtomicIntegerFieldUpdaterImpl中，也运用到了Unsafe，所以不支持静态变量，不能设置为static</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> CAS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（十三）ThreadLocal</title>
      <link href="/2019/12/28/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B13/"/>
      <url>/2019/12/28/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B13/</url>
      
        <content type="html"><![CDATA[<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>锁可以保证一个变量被使用的时候，可以将其锁住，不让其他线程修改，那么引申到一个问题，可不可给每个线程都设置一个变量，让他们各自为营，以空间去换取时间呢？当然可以，于是乎就有了ThreadLocal这个新的方法，举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleDateFormat sdf=<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:m:ss"</span>);</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService es= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            es.execute(<span class="keyword">new</span> test());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Date t=sdf.parse(<span class="string">"2019-12-28 15:19:"</span>+i/<span class="number">60</span>);</span><br><span class="line">            System.out.println(i+<span class="string">":"</span>+t);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Exception in thread <span class="string">"pool-1-thread-6"</span> Exception in thread <span class="string">"pool-1-thread-4"</span> Exception in thread <span class="string">"pool-1-thread-7"</span> Exception in thread <span class="string">"pool-1-thread-1"</span> Exception in thread <span class="string">"pool-1-thread-2"</span> java.lang.NumberFormatException: multiple points</span><br><span class="line">at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:<span class="number">1890</span>)</span><br><span class="line">at sun.misc.FloatingDecimal.parseDouble(FloatingDecimal.java:<span class="number">110</span>)</span><br><span class="line">at java.lang.Double.parseDouble(Double.java:<span class="number">538</span>)</span><br><span class="line">at java.text.DigitList.getDouble(DigitList.java:<span class="number">169</span>)</span><br><span class="line">at java.text.DecimalFormat.parse(DecimalFormat.java:<span class="number">2089</span>)</span><br><span class="line">at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:<span class="number">1869</span>)</span><br><span class="line">at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:<span class="number">1514</span>)</span><br><span class="line">at java.text.DateFormat.parse(DateFormat.java:<span class="number">364</span>)</span><br><span class="line">at test.run(test.java:<span class="number">20</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1149</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line">java.lang.NumberFormatException: multiple points</span><br><span class="line">at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:<span class="number">1890</span>)</span><br><span class="line">at sun.misc.FloatingDecimal.parseDouble(FloatingDecimal.java:<span class="number">110</span>)</span><br><span class="line">at java.lang.Double.parseDouble(Double.java:<span class="number">538</span>)</span><br><span class="line">at java.text.DigitList.getDouble(DigitList.java:<span class="number">169</span>)</span><br><span class="line">at java.text.DecimalFormat.parse(DecimalFormat.java:<span class="number">2089</span>)</span><br><span class="line">at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:<span class="number">1869</span>)</span><br><span class="line">at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:<span class="number">1514</span>)</span><br><span class="line">at java.text.DateFormat.parse(DateFormat.java:<span class="number">364</span>)</span><br><span class="line">at test.run(test.java:<span class="number">20</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1149</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line">java.lang.NumberFormatException: For input string: <span class="string">""</span></span><br><span class="line">at java.lang.NumberFormatException.forInputString(NumberFormatException.java:<span class="number">65</span>)</span><br><span class="line">at java.lang.Long.parseLong(Long.java:<span class="number">601</span>)</span><br><span class="line">at java.lang.Long.parseLong(Long.java:<span class="number">631</span>)</span><br><span class="line">at java.text.DigitList.getLong(DigitList.java:<span class="number">195</span>)</span><br><span class="line">at java.text.DecimalFormat.parse(DecimalFormat.java:<span class="number">2084</span>)</span><br><span class="line">at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:<span class="number">1869</span>)</span><br><span class="line">at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:<span class="number">1514</span>)</span><br><span class="line">at java.text.DateFormat.parse(DateFormat.java:<span class="number">364</span>)</span><br><span class="line">at test.run(test.java:<span class="number">20</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1149</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line">Exception in thread <span class="string">"pool-1-thread-5"</span> java.lang.NumberFormatException: For input string: <span class="string">""</span></span><br><span class="line">at java.lang.NumberFormatException.forInputString(NumberFormatException.java:<span class="number">65</span>)</span><br><span class="line">at java.lang.Long.parseLong(Long.java:<span class="number">601</span>)</span><br><span class="line">at java.lang.Long.parseLong(Long.java:<span class="number">631</span>)</span><br><span class="line">at java.text.DigitList.getLong(DigitList.java:<span class="number">195</span>)</span><br><span class="line">at java.text.DecimalFormat.parse(DecimalFormat.java:<span class="number">2084</span>)</span><br><span class="line">at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:<span class="number">1869</span>)</span><br><span class="line">at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:<span class="number">1514</span>)</span><br><span class="line">at java.text.DateFormat.parse(DateFormat.java:<span class="number">364</span>)</span><br><span class="line">at test.run(test.java:<span class="number">20</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1149</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line">java.lang.NumberFormatException: For input string: <span class="string">""</span></span><br><span class="line">at java.lang.NumberFormatException.forInputString(NumberFormatException.java:<span class="number">65</span>)</span><br><span class="line">at java.lang.Long.parseLong(Long.java:<span class="number">601</span>)</span><br><span class="line">at java.lang.Long.parseLong(Long.java:<span class="number">631</span>)</span><br><span class="line">at java.text.DigitList.getLong(DigitList.java:<span class="number">195</span>)</span><br><span class="line">at java.text.DecimalFormat.parse(DecimalFormat.java:<span class="number">2084</span>)</span><br><span class="line">at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:<span class="number">2162</span>)</span><br><span class="line">at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:<span class="number">1514</span>)</span><br><span class="line">at java.text.DateFormat.parse(DateFormat.java:<span class="number">364</span>)</span><br><span class="line">at test.run(test.java:<span class="number">20</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1149</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line">java.lang.NumberFormatException: For input string: <span class="string">""</span></span><br><span class="line">at java.lang.NumberFormatException.forInputString(NumberFormatException.java:<span class="number">65</span>)</span><br><span class="line">at java.lang.Long.parseLong(Long.java:<span class="number">601</span>)</span><br><span class="line">at java.lang.Long.parseLong(Long.java:<span class="number">631</span>)</span><br><span class="line">at java.text.DigitList.getLong(DigitList.java:<span class="number">195</span>)</span><br><span class="line">at java.text.DecimalFormat.parse(DecimalFormat.java:<span class="number">2084</span>)</span><br><span class="line">at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:<span class="number">1869</span>)</span><br><span class="line">at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:<span class="number">1514</span>)</span><br><span class="line">at java.text.DateFormat.parse(DateFormat.java:<span class="number">364</span>)</span><br><span class="line">at test.run(test.java:<span class="number">20</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1149</span>)<span class="number">0</span>:Sat Dec <span class="number">28</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">00</span> CST <span class="number">2019</span></span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:Sat Dec <span class="number">28</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">00</span> CST <span class="number">2019</span></span><br><span class="line"><span class="number">0</span>:Sat Dec <span class="number">28</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">00</span> CST <span class="number">2019</span></span><br><span class="line"><span class="number">0</span>:Sat Dec <span class="number">28</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">00</span> CST <span class="number">2019</span></span><br></pre></td></tr></table></figure><p>很明显，不可以，因为sdf.parse并不是线程安全的，所以我们除了可以使用锁去锁住它之外，还可以使用ThreadLocal去处理，为每一个线程都产生一个ThreadLocal的局部对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; sdf=<span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;();</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService es= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            es.execute(<span class="keyword">new</span> test());</span><br><span class="line">        &#125;</span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(sdf.get()==<span class="keyword">null</span>)&#123;</span><br><span class="line">                sdf.set(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:m:ss"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            Date t=sdf.get().parse(<span class="string">"2019-12-28 15:19:"</span>+i/<span class="number">60</span>);</span><br><span class="line">            System.out.println(i+<span class="string">":"</span>+t);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:Sat Dec <span class="number">28</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">00</span> CST <span class="number">2019</span></span><br><span class="line"><span class="number">0</span>:Sat Dec <span class="number">28</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">00</span> CST <span class="number">2019</span></span><br><span class="line"><span class="number">0</span>:Sat Dec <span class="number">28</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">00</span> CST <span class="number">2019</span></span><br><span class="line"><span class="number">0</span>:Sat Dec <span class="number">28</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">00</span> CST <span class="number">2019</span></span><br><span class="line"><span class="number">0</span>:Sat Dec <span class="number">28</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">00</span> CST <span class="number">2019</span></span><br><span class="line"><span class="number">0</span>:Sat Dec <span class="number">28</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">00</span> CST <span class="number">2019</span></span><br><span class="line"><span class="number">0</span>:Sat Dec <span class="number">28</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">00</span> CST <span class="number">2019</span></span><br><span class="line"><span class="number">0</span>:Sat Dec <span class="number">28</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">00</span> CST <span class="number">2019</span></span><br><span class="line"><span class="number">0</span>:Sat Dec <span class="number">28</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">00</span> CST <span class="number">2019</span></span><br><span class="line"><span class="number">0</span>:Sat Dec <span class="number">28</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">00</span> CST <span class="number">2019</span></span><br></pre></td></tr></table></figure><p>可以看到，为每一个线程都分配了一个对象去工作，以空间换取时间，这使得我们每个线程都有了独立的局部变量，让其线程安全。但如果在应用上为每个对象都分配相同的对象实例，也是会导致线程不安全的。</p><h4 id="ThreadLocal实现原理"><a href="#ThreadLocal实现原理" class="headerlink" title="ThreadLocal实现原理"></a>ThreadLocal实现原理</h4><h5 id="set和get"><a href="#set和get" class="headerlink" title="set和get"></a>set和get</h5><p>ThreadLocal最主要的就是它的set和get</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们传入的值，传入到了一个map中。把当前线程的值看做为一个key，把传入的参数看作为一个value，先获取当前线程的id，作为一个key，如果不存在则创造一个全局的map（其实就是ThreadLocal本身），将其key和value加入map中，若存在这个key，则重新修改这个值。在使用get方法取出的时候，利用了泛型，将value的值重新完整的取出。</p><h5 id="exit和remove"><a href="#exit和remove" class="headerlink" title="exit和remove"></a>exit和remove</h5><p>当我们的线程退出的时候，自动会执行exit方法，而exit方法也包括了对ThreadLocal的清理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (group != <span class="keyword">null</span>) &#123;</span><br><span class="line">        group.threadTerminated(<span class="keyword">this</span>);</span><br><span class="line">        group = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Aggressively null out all reference fields: see bug 4006245 */</span></span><br><span class="line">    target = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/* Speed the release of some of these resources */</span></span><br><span class="line">    threadLocals = <span class="keyword">null</span>;</span><br><span class="line">    inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">    inheritedAccessControlContext = <span class="keyword">null</span>;</span><br><span class="line">    blocker = <span class="keyword">null</span>;</span><br><span class="line">    uncaughtExceptionHandler = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但平常我们并不经常单独的去使用一个线程，而是使用线程池去使用线程，这就牵扯到了一个问题，那就是线程池的线程有线程复用现象，那么这样的线程就不会被销毁，那么ThreadLocal也就一直存在，当它积累到一定程度的时候，就有内存泄漏的风险，于是乎，我们便可以手动的去销毁ThreadLocalmap。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t.remove();</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">         <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">             m.remove(<span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>除此之外，还可以主动的设置object=null，让jvm更快的回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>的<span class="title">GC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> ThreadLocal&lt;SimpleDateFormat&gt; t1=<span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.toString()+<span class="string">"is GC"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> CountDownLatch cd=<span class="keyword">new</span> CountDownLatch(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService es= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10000</span> ; i++) &#123;</span><br><span class="line">            es.execute(<span class="keyword">new</span> ParseDate(i));</span><br><span class="line">        &#125;</span><br><span class="line">        cd.await();</span><br><span class="line">        System.out.println(<span class="string">"任务完成"</span>);</span><br><span class="line">        t1=<span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"首次GC成功"</span>);</span><br><span class="line"></span><br><span class="line">        t1=<span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;();</span><br><span class="line">        cd=<span class="keyword">new</span> CountDownLatch(<span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10000</span> ; i++) &#123;</span><br><span class="line">            es.execute(<span class="keyword">new</span> ParseDate(i));</span><br><span class="line">        &#125;</span><br><span class="line">        cd.await();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"第二次GC成功"</span>);</span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseDate</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ParseDate</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.i = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(t1.get()==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    t1.set(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)&#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                            System.out.println(<span class="keyword">this</span>.toString()+<span class="string">"is GC2"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    System.out.println(Thread.currentThread().getId()+<span class="string">"create SimpleDateFormat"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                Date t=t1.get().parse(<span class="string">"2019-12-28 15:19:"</span>+i/<span class="number">60</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                cd.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">13</span>create SimpleDateFormat</span><br><span class="line"><span class="number">21</span>create SimpleDateFormat</span><br><span class="line"><span class="number">19</span>create SimpleDateFormat</span><br><span class="line"><span class="number">16</span>create SimpleDateFormat</span><br><span class="line"><span class="number">14</span>create SimpleDateFormat</span><br><span class="line"><span class="number">17</span>create SimpleDateFormat</span><br><span class="line"><span class="number">18</span>create SimpleDateFormat</span><br><span class="line"><span class="number">20</span>create SimpleDateFormat</span><br><span class="line"><span class="number">15</span>create SimpleDateFormat</span><br><span class="line"><span class="number">12</span>create SimpleDateFormat</span><br><span class="line">任务完成</span><br><span class="line">首次GC成功</span><br><span class="line">ThreadLocal的GC$<span class="number">1</span>@<span class="number">74560f</span>d0is GC</span><br><span class="line"><span class="number">14</span>create SimpleDateFormat</span><br><span class="line"><span class="number">18</span>create SimpleDateFormat</span><br><span class="line"><span class="number">19</span>create SimpleDateFormat</span><br><span class="line"><span class="number">17</span>create SimpleDateFormat</span><br><span class="line"><span class="number">13</span>create SimpleDateFormat</span><br><span class="line"><span class="number">15</span>create SimpleDateFormat</span><br><span class="line"><span class="number">20</span>create SimpleDateFormat</span><br><span class="line"><span class="number">21</span>create SimpleDateFormat</span><br><span class="line"><span class="number">12</span>create SimpleDateFormat</span><br><span class="line"><span class="number">16</span>create SimpleDateFormat</span><br><span class="line">第二次GC成功</span><br></pre></td></tr></table></figure><p>这个例子首先设置了只有10个线程的线程池，然后使用线程池去使用线程，而CountDownLatch则是必须执行10000次，因为只有十个线程，所以也只制造了10个ThreadLocal实例，在它们执行完10000次后，将ThreadLocal的设置为null，这也就使得每个线程的ThreadLocal为空了，之后马上进行一次GC回收，再次创建的时候，判定t1.get()==null，可见ThreadLocal又重新被制作了。</p><p>前面对ThreadLocal的使用的涉及到了ThreadLocalMap的entry</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>可以看作为一种较为弱的HashMap。当这个ThreadLocal的t1被设置为null时，它的所有key值都将不复存在，但这并不代表线程已经被销毁了，而是指它和线程的ID 解绑了，于是ThreadLocal的entry也将被销毁，成为null，而再次去线程池里使用线程时，ThreadLocal的key值再次和线程ID绑定，只不过他的value已空，需要重新去设置。</p><h4 id="ThreadLocal对性能的提升"><a href="#ThreadLocal对性能的提升" class="headerlink" title="ThreadLocal对性能的提升"></a>ThreadLocal对性能的提升</h4><p>最后我们最后做一个测试去查看ThreadLocal对性能的提升如何：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GEN_COUNT=<span class="number">10000000</span>;<span class="comment">//每个线程要执行生成随机数的次数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_COUNT=<span class="number">4</span>;<span class="comment">//线程数</span></span><br><span class="line">    <span class="keyword">static</span> ExecutorService es= Executors.newFixedThreadPool(<span class="number">10</span>);<span class="comment">//线程池</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Random rnd=<span class="keyword">new</span> Random(<span class="number">123</span>);<span class="comment">//返回一个随机数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;Random&gt; tRnd=<span class="keyword">new</span> ThreadLocal&lt;Random&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Random <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Random(<span class="number">123</span>);<span class="comment">//返回一个随机数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RndTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Long</span>&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//java5开始，提供了Callable接口，是Runable接口的增强版。</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> mode=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RndTask</span><span class="params">(<span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.mode = mode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Random <span class="title">getRandom</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(mode==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> rnd;<span class="comment">//</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (mode==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> tRnd.get();<span class="comment">//ThreadLocal</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Long <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> b=System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt;GEN_COUNT ; i++) &#123;</span><br><span class="line">                getRandom().nextInt();<span class="comment">//返回随机数，10000000次</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> e=System.currentTimeMillis();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"花费"</span>+(e-b)+<span class="string">"ms"</span>);</span><br><span class="line">            <span class="keyword">return</span> e-b;<span class="comment">// java5提供了Future接口来代表Callable接口里的call()方法的返回值，并为Future接口提供了一个FutureTask实现类，该实现类实现了Future接口，并实现了Runnable接口，所以这样可以作为Thread的target。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        Future&lt;Long&gt;[] f=<span class="keyword">new</span> Future[THREAD_COUNT];<span class="comment">//制作四个线程组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;THREAD_COUNT ; i++) &#123;</span><br><span class="line">            f[i]=es.submit(<span class="keyword">new</span> RndTask(<span class="number">0</span>));<span class="comment">//提交普通的线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> totaltime=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;THREAD_COUNT ; i++) &#123;</span><br><span class="line">            totaltime+=f[i].get();<span class="comment">//获取返回值</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"多线程访问同一个Random实例"</span>+totaltime+<span class="string">"ms"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Threadlocal</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;THREAD_COUNT ; i++) &#123;</span><br><span class="line">            f[i]=es.submit(<span class="keyword">new</span> RndTask(<span class="number">1</span>));<span class="comment">//提交ThreadLocal</span></span><br><span class="line">        &#125;</span><br><span class="line">        totaltime=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;THREAD_COUNT ; i++) &#123;</span><br><span class="line">            totaltime+=f[i].get();<span class="comment">//获取返回值</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"使用ThreadLocal包装Random实例"</span>+totaltime+<span class="string">"ms"</span>);</span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>花费<span class="number">1596</span>ms</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>花费<span class="number">1643</span>ms</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>花费<span class="number">1688</span>ms</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>花费<span class="number">1687</span>ms</span><br><span class="line">多线程访问同一个Random实例<span class="number">6614</span>ms</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span>花费<span class="number">110</span>ms</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span>花费<span class="number">121</span>ms</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>花费<span class="number">127</span>ms</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span>花费<span class="number">132</span>ms</span><br><span class="line">使用ThreadLocal包装Random实例<span class="number">490</span>ms</span><br></pre></td></tr></table></figure><p>这个测试，一个使用全局的Random实例，被多个线程访问，每个线程都执行了100000次return new Random(123)的操作，总共产生了40000000次Random对象。而使用ThreadLocal去包装Random，总共就创建了4次Random对象，之后只是在不断地访问它而已，可见得，效率有着显著的提高。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（十二）如何提高锁的性能</title>
      <link href="/2019/12/27/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B12/"/>
      <url>/2019/12/27/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B12/</url>
      
        <content type="html"><![CDATA[<h3 id="几种提高锁性能的方法"><a href="#几种提高锁性能的方法" class="headerlink" title="几种提高锁性能的方法"></a>几种提高锁性能的方法</h3><h4 id="减小锁持有的时间"><a href="#减小锁持有的时间" class="headerlink" title="减小锁持有的时间"></a>减小锁持有的时间</h4><p>synchronized虽然可以保持原子性，但是大量的使用synchronized会使系统的整体性能下降，于是，我们可以只在需要上锁的时候上锁，对某些不改变系统数据的方法不上锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        code1();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        code2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//可以改为</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        code1();</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">        code2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//其实这个例子不能很好的说明，因为jvm对锁有优化，使得不需要上锁的区域会自动发生逃逸现象。</span></span><br></pre></td></tr></table></figure><p>比如code1和code2是不影响原子性的普通操作，而它们所占用的时间又很多，于是便可以将synchronized从一个整体函数拆分到一个个体中，更甚至可以使用lock和unlock继续细分，使得仅仅需要同步的方法上锁。</p><h4 id="减小锁的粒度：锁细化"><a href="#减小锁的粒度：锁细化" class="headerlink" title="减小锁的粒度：锁细化"></a>减小锁的粒度：锁细化</h4><p>除了可以通过减小锁持有的时间去提高性能外，还可以通过减小锁的粒度去提高性能，就比如HashMap，在使用put()的时候，它是线程不安全的，如果直接使用synchronized去上锁，那么可能会对整体性能造成很大的影响，因为HashMap经常需要被使用。所以，便可以通过减小锁的粒度的形式去改变它，就比如ConcurrentHashMap，它本身有16个空的容器可以容纳元素，它在使用put方法的时候，进行计算，如果各个线程所得出来的key值不相同，那就不进行加锁，也就是说，最多可以共同容纳16个线程不加锁去put元素，极大的提高了效率。以下提供ConcurrentHashMap源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK7</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        Segment&lt;K,V&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">        <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">             (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">            s = ensureSegment(j);</span><br><span class="line">        <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//JDK8</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                tab = initTable();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                             <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                    <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                V oldVal = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            binCount = <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                                K ek;</span><br><span class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                    ((ek = e.key) == key ||</span><br><span class="line">                                     (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                    oldVal = e.val;</span><br><span class="line">                                    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, <span class="keyword">null</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            binCount = <span class="number">2</span>;</span><br><span class="line">                            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                oldVal = p.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意，并不是所有的锁细化都可以提高性能，因为一旦进行锁细化操作后，如果一个全局的变量需要获得锁，那就必须等待所有被细化的锁释放之后才能进行。比如ConcurrentHashMap的size()；就必须获得整体的锁，所以在执行类似操作的时候，要注意当时的场景是否需要经常使用全局变量，比如一个需要实时统计数据的股票交易所，就不要使用锁细化。</p><h4 id="增大锁的粒度：锁粗化"><a href="#增大锁的粒度：锁粗化" class="headerlink" title="增大锁的粒度：锁粗化"></a>增大锁的粒度：锁粗化</h4><p>有的时候为了提高性能甚至还可以反其道而行之，提高锁的粒度。因为存在一个特殊的场景，需要经常获得锁，但是不需要获得锁的部分所执行的时间又极短，所以与其不停的去申请锁并释放锁，不如直接申请一个大锁，锁住全部内容，以为每次加锁和解锁都是需要时间的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;&#125;</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">2</span>);<span class="comment">//中间所执行时间极短</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不如就</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//减少锁的申请，减小开销</span></span><br></pre></td></tr></table></figure><h4 id="用读写锁去代替独占锁"><a href="#用读写锁去代替独占锁" class="headerlink" title="用读写锁去代替独占锁"></a>用读写锁去代替独占锁</h4><p>在生活中很多应用场合中，读取数据的次数总是要大于写入次数的，就比如购物平台，所以很多时候都可以用读写锁ReadWriteLock去代替独占锁，或者用重入锁去代替独占锁，很多特殊的锁在特定环境下总能够获得更大的性能，要看场合使用。</p><h4 id="锁分离"><a href="#锁分离" class="headerlink" title="锁分离"></a>锁分离</h4><p>从读写锁的角度出发，我们可以从中获得启发，那就是将锁分离，读写锁可以拆分为读锁和写锁，用作于很多不同的场景，而我们也可以试着将锁分离，或者增加更多的锁，从而用更多的方法去得到灵活性。就比如之前的LinkedBlockingQueue。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Wait queue for waiting takes */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Lock held by put, offer, etc */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Wait queue for waiting puts */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure><p>使用了两个锁，，分别去控制put方法和take方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">        Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">        <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">        putLock.lockInterruptibly();<span class="comment">//不能有两个线程同时进行put</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count.get() == capacity) &#123;<span class="comment">//如果达到了上限，便等待</span></span><br><span class="line">                notFull.await();<span class="comment">//等待</span></span><br><span class="line">            &#125;</span><br><span class="line">            enqueue(node);<span class="comment">//跳出了等待，便入队</span></span><br><span class="line">            c = count.getAndIncrement();<span class="comment">//入队成功，总数加一</span></span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)<span class="comment">//如果仍未满，就通知其他线程的put继续入队</span></span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            putLock.unlock();<span class="comment">//解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            signalNotEmpty();<span class="comment">//插入成功，通知take操作</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        E x;</span><br><span class="line">        <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">        takeLock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            x = dequeue();</span><br><span class="line">            c = count.getAndDecrement();</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">                notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            takeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == capacity)</span><br><span class="line">            signalNotFull();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//以此类推......</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（十一）并发容器</title>
      <link href="/2019/12/26/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B11/"/>
      <url>/2019/12/26/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B11/</url>
      
        <content type="html"><![CDATA[<h3 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h3><h4 id="一些常用的工具"><a href="#一些常用的工具" class="headerlink" title="一些常用的工具"></a>一些常用的工具</h4><ul><li>ConcurrentHashMap：线程安全的hashmap。</li><li>CopyOnWriteArrayList：线程安全的ArrayList，比较适合读多写少的场合，完胜vector。</li><li>ConcurrentLinkedQueue：线程安全的队列，它们两之间的差别在于数据结构不一样，一个是类似于数组，更适合直接查找，一个则是像链表一样，更适合添加和修改。</li><li>BlockingQueue：一个阻塞队列，也是一个接口，通常用于数据共享的通道。</li><li>ConcurrentSkipListMap：线程安全的跳表。</li></ul><table><thead><tr><th align="left">–</th><th align="left">ADD()操作</th><th align="left">DELETE()操作</th><th align="left">INSERT操作</th><th align="left">INDEX取值操作</th><th align="left">ITERATOR取值操作</th></tr></thead><tbody><tr><td align="left">ArrayList/Vector/Stack</td><td align="left">好</td><td align="left">差</td><td align="left">差</td><td align="left">极优</td><td align="left">极优</td></tr><tr><td align="left">LinkedList</td><td align="left">好</td><td align="left">好</td><td align="left">好</td><td align="left">差</td><td align="left">极优</td></tr></tbody></table><h4 id="初步实现线程安全"><a href="#初步实现线程安全" class="headerlink" title="初步实现线程安全"></a>初步实现线程安全</h4><p>想要保持HashMap的线程安全的话，出了手动使用synchronized包围之外，还能够调用一个类去实现它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Map map= Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line"><span class="comment">//将HashMap对象传入synchronized的map，正如字面意思所示</span></span><br><span class="line"><span class="comment">//看看里面的实现</span></span><br><span class="line">        SynchronizedMap(Map&lt;K,V&gt; m) &#123;</span><br><span class="line">            <span class="keyword">this</span>.m = Objects.requireNonNull(m);</span><br><span class="line">            mutex = <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//list同理</span></span><br><span class="line">List list=Collections.synchronizedList(<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">SynchronizedList(List&lt;E&gt; list) &#123;</span><br><span class="line">            <span class="keyword">super</span>(list);</span><br><span class="line">            <span class="keyword">this</span>.list = list;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p> Objects.requireNonNull是判断有没有传入参数，mutex表示的是一个锁，表明要拥有这个锁的时候才能对map进行读取或写入，这样的话效率很低。</p><p>一个更好用的办法，就是用ConcurrentHashMap。</p><h4 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h4><p>ConcurrentLinkedQueue是在高并发环境下最好的队列了，队列经常被用于实际生活，比如消息队列，用餐的推送顺序，购票网站等，之前讲过的Java并发编程（六）的ArrayList线程不安全，我们用线程安全的代替试试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ConcurrentLinkedQueue list=<span class="keyword">new</span> ConcurrentLinkedQueue();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> test());</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> test());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            list.offer(i);</span><br><span class="line">            <span class="comment">//add也行，一样的</span></span><br><span class="line">            <span class="comment">//    public boolean add(E e) &#123;</span></span><br><span class="line">            <span class="comment">//        return offer(e);</span></span><br><span class="line">            <span class="comment">//    &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">200000</span></span><br></pre></td></tr></table></figure><p>我们看看ConcurrentLinkedQueue是如何实现的吧！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentLinkedQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = tail = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">    &#125;<span class="comment">//无参数的构造方法，将类的头结点和子节点都设置为新的节点</span></span><br><span class="line"><span class="comment">//Node 是一个类，里面有两个参数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> E item;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;E&gt; next;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//E表示是泛型的容器，用传入的类型定义目标值，和用一个新的Node去定义next值，类似于链表一般，一个接着一个。</span></span><br><span class="line"><span class="comment">//而Node又有几个方法</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">casItem</span><span class="params">(E cmp, E val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, itemOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">lazySetNext</span><span class="params">(Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">            UNSAFE.putOrderedObject(<span class="keyword">this</span>, nextOffset, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//casItem的意思是设置当前的值，使用cas操作(compareAndSwapObject)去保证其原子性</span></span><br></pre></td></tr></table></figure><p>队列里有head和tail两个值，分别代表的头结点和尾节点，头结点值永远不会为null，而我们正是使用头结点去遍历这个队列，每当有一个新的值入队的时候，都会从尾部入队，直接进入尾节点，从而只需移动尾节点便可以入队，极大的方便与插入和删除操作。而tail的更新情况并不一定是随时更新，而是可能会产生延迟，比如要进入了两个数值，尾节点才会移动到末尾。而我们入队的方法有两个，一个是add，一个是offer，但是实际上使用的都是offer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add也行，一样的</span></span><br><span class="line"><span class="comment">//    public boolean add(E e) &#123;</span></span><br><span class="line"><span class="comment">//        return offer(e);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="comment">//检查是否为空</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="comment">//然后便建立一个新的节点</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;<span class="comment">//p为头结点</span></span><br><span class="line">        Node&lt;E&gt; q = p.next;</span><br><span class="line">        <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;<span class="comment">//等于空表示是最后的节点</span></span><br><span class="line">            <span class="comment">//第一次加入元素时，p.next为空，于是便使用一个新的节点</span></span><br><span class="line">            <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, newNode)) &#123;</span><br><span class="line">                <span class="comment">//新节点与p的next交换(p为头节点)</span></span><br><span class="line">                <span class="keyword">if</span> (p != t) <span class="comment">//头结点不等于尾节点</span></span><br><span class="line">                    casTail(t, newNode);<span class="comment">//允许失败</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//返回true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">        <span class="comment">//取最后一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在if (q == null)这个判断中，如何q为空，可能队列为空，也可能加入新的节点，正常执行增加节点操作。但在队列为空时，p==t（即head=tail），因此不会执行castail()操作。</p><p>但在执行了第一个元素入队后，再执行第二个元素入队时，p的next不为空，于是就开始查找最后一个节点，执行 p = (p != t &amp;&amp; t != (t = tail)) ? t : q;     使得p取下一个节点或最后的节点，于是p就成了链表的第一个元素。这个时候再进行循环，p的null（即第一个元素的next）为空，而此时的p不等于尾节点，于是变更新尾节点，使得尾节点移动至链表最后。</p><p>而出现特殊情况 else if (p == q) 出现的时候，便使用新的tail作为链表的末尾。</p><p>特殊情况是怎么诞生的呢？比如两个线程去读取队列的一个值，一个读取完了之后，另一个执行了修改，那么第一个线程再次去读取的时候，就会发生两次数据不一致的问题。就会出现一个(t != (t = tail))的情况，这时候，如果尾节点没有被修改，则返回head，重新查找尾节点。</p><p>看看出队的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       restartFromHead:</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">               E item = p.item;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (p != h) </span><br><span class="line">                       updateHead(h, ((q = p.next) != <span class="keyword">null</span>) ? q : p);</span><br><span class="line">                   <span class="keyword">return</span> item;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> ((q = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   updateHead(h, p);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">                   <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   p = q;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>但在执行了第一个元素入队后，再执行第一个元素出队时，此刻的tail并没有更新，所以会直接执行最后一个操作，使得p=q；就是说把头结点的值变为第一个节点的值，然后再循环，执行到 item != null &amp;&amp; p.casItem(item, null) 此时的item元素不会为空，因为它现在是第一个节点，然后再将其cas交换，交换后，item值已经为空了，于是就不会等于h，然后执行   updateHead(h, ((q = p.next) != null) ? q : p); </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">updateHead</span><span class="params">(Node&lt;E&gt; h, Node&lt;E&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h != p &amp;&amp; casHead(h, p))</span><br><span class="line">        h.lazySetNext(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再把head和tail变为同一个元素。</p><h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>CopyOnWriteArrayList常被用作于商品类目的展示，黑名单等各种读多写少的场景。但是它只能保证数据的最终一致性，不能保证数据的实时一致性，也就是说，被修改的值不一定能够被马上读到。我们来看看它的源码把。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取的时候，返回一个get(getArray(), index)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    <span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (E) a[index];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这相当于每次都返回一个array[index]的内部数组，因为这个数组不会被修改，只能够被另一个array数组给替换，从而保证了原子性，所以就没有类似于synchronized和lock的加锁操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add方法</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//set</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">        array = a;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>一开始便设置了一个重入锁，进行了加锁操作，然后没增加一个新元素，都会创建一个新的数组，然后使用setArray去改变这个数组的值，由于整体都加了锁，所以不会影响到原子性，其次array变量是一个volatile类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br></pre></td></tr></table></figure><p>所以被修改后，其他线程会被察觉到并将其修改，保证可见性和有序性。</p><h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><p>之前在写线程池的时候，介绍过四个任务队列，它们都有一个共同的特点就是都具有阻塞功能，因为它们都来自于一个接口BlockingQueue</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">remainingCapacity</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c, <span class="keyword">int</span> maxElements)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而我们就以ArrayBlockingQueue为例。虽然说ArrayBlockingQueue和concurrentlinkedqueue也有offer方法和poll方法，但是ArrayBlockingQueue由于继承的是BlockQueue，所以还有两个独有的方法，那就是put和take。</p><p>这有什么区别呢？可以猜的到这两个方法具有阻塞功能，就以offer方法和put方法来对比。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == items.length)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//直接返回</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                enqueue(e);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">                notFull.await();<span class="comment">//阻塞</span></span><br><span class="line">            enqueue(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        E x = (E) items[takeIndex];</span><br><span class="line">        items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">            takeIndex = <span class="number">0</span>;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">            itrs.elementDequeued();</span><br><span class="line">        notFull.signal();<span class="comment">//唤醒notfull</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br></pre></td></tr></table></figure><p>它们之间最为明显的差别就是，offer在队列已经满的时候，直接返回一个false，而put方法则是使用了condition.await去阻塞这个线程继续运行，等待另一个dequeue方法，移除一个元素出队后，再去唤醒put方法，使其继续将未能加入线程的元素继续加入进去。</p><p>同理，take方法也是如此</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();<span class="comment">//直接返回</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">                notEmpty.await();<span class="comment">//阻塞</span></span><br><span class="line">            <span class="keyword">return</span> dequeue();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">        items[putIndex] = x;</span><br><span class="line">        <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">            putIndex = <span class="number">0</span>;</span><br><span class="line">        count++;</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用take想要获得队列首部信息的时候，如果没有值，便发生阻塞，直到有元素入队，使用notEmpty方法唤醒为止。</p><h4 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h4><p>跳表(SkipList)，是除了哈希表(HashTable)以外，一个非常特别的表。哈希图是用哈希表去实现的，那么跳表也有对应的map结构，那就是跳图(ConcurrentSkipListMap)，这个ConcurrentSkipListMap非常的神奇，这是一个用空间去换时间的算法，它的数据结构如下：图片资源来自于：<a href="http://www.liuhaihua.cn/archives/40657.html" target="_blank" rel="noopener">http://www.liuhaihua.cn/archives/40657.html</a></p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/skipmap1.jpg" alt="skipmap1"></p><p>顶层有着很少的数据和很大的区间，然后往下走，数据越密，区间越小。每个节点都有key值和value值，它的运行机制如下：当你要寻找一个key值的时候，从顶层开始找，如果需要找的key值小于当前节点，便继续前进一个节点，如果需要找的key值大于当前节点，便直接进入当前节点的下一层继续寻找，如果需要找的key值等于当前节点，便返回当前节点的value值。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/skipmap.jpg" alt="skipmap2"></p><p>如图所示，如果你要找的值为70，从顶层开始找，大于20往下，大于40再往下，小于40则往前，最后找到了目标值70。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentSkipListMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,String&gt; s=<span class="keyword">new</span> ConcurrentSkipListMap&lt;Integer,String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">30</span> ; i++) &#123;</span><br><span class="line">            s.put(i,<span class="string">"i am "</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer,String&gt; e:s.entrySet()</span><br><span class="line">             ) &#123;</span><br><span class="line">            System.out.println(e.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以发现它的输出是有序的，而HashMap的输出是无序的。</span></span><br></pre></td></tr></table></figure><p>我们看看它的源码构成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> Object value;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br></pre></td></tr></table></figure><p>每一个节点除了自己的key和value，还有下一个节点的next，类似于链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">casValue</span><span class="params">(Object cmp, Object val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, valueOffset, cmp, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(Node&lt;K,V&gt; cmp, Node&lt;K,V&gt; val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>都使用CAS操作去保证原子性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt; node;</span><br><span class="line">    <span class="keyword">final</span> Index&lt;K,V&gt; down;</span><br><span class="line">    <span class="keyword">volatile</span> Index&lt;K,V&gt; right;</span><br></pre></td></tr></table></figure><p>特别是这个index，定义了本身节点，右节点和下节点，这三个节点，这将其数据结构的实现联系到了一起，看看构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentSkipListMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.comparator = <span class="keyword">null</span>;</span><br><span class="line">        initialize();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        keySet = <span class="keyword">null</span>;</span><br><span class="line">        entrySet = <span class="keyword">null</span>;</span><br><span class="line">        values = <span class="keyword">null</span>;</span><br><span class="line">        descendingMap = <span class="keyword">null</span>;</span><br><span class="line">        head = <span class="keyword">new</span> HeadIndex&lt;K,V&gt;(<span class="keyword">new</span> Node&lt;K,V&gt;(<span class="keyword">null</span>, BASE_HEADER, <span class="keyword">null</span>),</span><br><span class="line">                                  <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadIndex</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Index</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> level;</span><br><span class="line">        HeadIndex(Node&lt;K,V&gt; node, Index&lt;K,V&gt; down, Index&lt;K,V&gt; right, <span class="keyword">int</span> level) &#123;</span><br><span class="line">            <span class="keyword">super</span>(node, down, right);</span><br><span class="line">            <span class="keyword">this</span>.level = level;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个HeadIndex的三个参数分别是需要寻找的目标节点的移动，和当前节点的本身的值和右值和下值，最后一个参数表示了层数。这个构造函数是整个SkipMap的核心所在。</p>]]></content>
      
      
      
        <tags>
            
            <tag> HashMap </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（十）线程池</title>
      <link href="/2019/12/24/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%8D%81%EF%BC%89/"/>
      <url>/2019/12/24/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%8D%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="线程池的基本使用"><a href="#线程池的基本使用" class="headerlink" title="线程池的基本使用"></a>线程池的基本使用</h4><h5 id="创建一个线程池"><a href="#创建一个线程池" class="headerlink" title="创建一个线程池"></a>创建一个线程池</h5><p>线程的每一次创建，最后的结果免不了都是销毁，那么在大型的系统的，就有着不断地创建和销毁，线程的创建和销毁开销是很大的，甚至在一些小的任务当中，创建和销毁的开销甚至超过了任务本身，那么，有方法可以去减少这种开销吗？设计者当然也想到了，于是乎有了线程池这个事物，使用线程池去创建线程，线程执行完任务后再回到线程池，等待下次任务的执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test t1=<span class="keyword">new</span> test();</span><br><span class="line">        ExecutorService es= Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            es.submit(t1);</span><br><span class="line">        &#125;</span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis()+<span class="string">"线程ID："</span>+Thread.currentThread().getId());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1577176965545</span>线程ID：<span class="number">12</span></span><br><span class="line"><span class="number">1577176965545</span>线程ID：<span class="number">15</span></span><br><span class="line"><span class="number">1577176965545</span>线程ID：<span class="number">13</span></span><br><span class="line"><span class="number">1577176965545</span>线程ID：<span class="number">12</span></span><br><span class="line"><span class="number">1577176965545</span>线程ID：<span class="number">14</span></span><br><span class="line"><span class="number">1577176965546</span>线程ID：<span class="number">15</span></span><br><span class="line"><span class="number">1577176965546</span>线程ID：<span class="number">12</span></span><br><span class="line"><span class="number">1577176965546</span>线程ID：<span class="number">13</span></span><br><span class="line"><span class="number">1577176965545</span>线程ID：<span class="number">16</span></span><br><span class="line"><span class="number">1577176965546</span>线程ID：<span class="number">14</span></span><br></pre></td></tr></table></figure><p>可以看到，线程池只创建了5个线程，却要执行10个任务，使用线程池的方法可以使得线程被重复利用。从而减少线程的创建和销毁所占用的内存。</p><h5 id="线程池的种类"><a href="#线程池的种类" class="headerlink" title="线程池的种类"></a>线程池的种类</h5><p>线程池不仅仅只有一种创建方法，它还有其他的种类</p><ul><li>newFixedThreadPool(int nThreads)创建一个拥有固定数量的线程池</li><li>newSingleThreadExecutor()创建一个只有一个线程的线程池</li><li>newCachedThreadPool()创建一个拥有自动改变大小的线程池</li><li>newSingleThreadScheduledExecutor()创建一个有固定时间执行的单个线程池</li><li>newScheduledThreadPool(int corePoolSize)创建一个有固定时间执行的且指定数量的线程池</li></ul><h5 id="固定时间执行任务-：newScheduledThreadPool-int-corePoolSize"><a href="#固定时间执行任务-：newScheduledThreadPool-int-corePoolSize" class="headerlink" title="固定时间执行任务 ：newScheduledThreadPool(int corePoolSize)"></a>固定时间执行任务 ：newScheduledThreadPool(int corePoolSize)</h5><p>这个函数可以指定固定时间完成线程的执行，看看它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//返回的是一个ScheduledExecutorService 对象</span></span><br><span class="line"><span class="comment">//ScheduledExecutorService :</span></span><br><span class="line">    <span class="keyword">public</span> &lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(Callable&lt;V&gt; callable,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">long</span> delay, TimeUnit unit)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">                                                  <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                                  <span class="keyword">long</span> period,</span><br><span class="line">                                                  TimeUnit unit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">                                                     <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                                     <span class="keyword">long</span> delay,</span><br><span class="line">                                                     TimeUnit unit);</span><br></pre></td></tr></table></figure><p>它有三个方法，最主要的两个是scheduleAtFixedRate和scheduleWithFixedDelay，它们的区别在于传入的是period还是delay，实际运用的时候，AtFixedRate是等待initial+n*period的时间允许，而WithFixedDelay是在线程执行完后等待delay时间运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test t=<span class="keyword">new</span> test();</span><br><span class="line">        ScheduledExecutorService es = Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line">        es.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(System.currentTimeMillis()/<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">0</span>,<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1577178569</span></span><br><span class="line"><span class="number">1577178571</span></span><br><span class="line"><span class="number">1577178573</span></span><br><span class="line"><span class="number">1577178575</span></span><br><span class="line"><span class="number">1577178577</span></span><br><span class="line">......</span><br><span class="line"><span class="comment">//每次丢失间隔两秒执行一次</span></span><br><span class="line"><span class="comment">//而我们把AtFixedRate换为WithFixedDelay呢？</span></span><br><span class="line"><span class="number">1577178975</span></span><br><span class="line"><span class="number">1577178978</span></span><br><span class="line"><span class="number">1577178981</span></span><br><span class="line"><span class="number">1577178984</span></span><br><span class="line"><span class="comment">//执行时间间隔变成了3秒</span></span><br></pre></td></tr></table></figure><p>但如果我们的周期时间要大于等待时间呢？比如说8秒，那我们的AtFixedRate就会执行完后继续执行而不是再继续等待，反之，WithFixedDelay是还要再等待2秒才会继续执行。</p><h4 id="线程池的内部实现"><a href="#线程池的内部实现" class="headerlink" title="线程池的内部实现"></a>线程池的内部实现</h4><h5 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h5><p>倒回来去看看前三个线程池构造方法，可以点进去看他们的实现，发现他们的实现都是来源于一个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>它们的不同也仅仅是传入的参数不同而已，并且都返回了一个叫做ThreadPoolExecutor的函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>corePoolSize</li><li>maximumPoolSize</li><li>keepAliveTime超过指定线程数量的线程在被销毁前的存活时间</li><li>TimeUnit unit</li><li>BlockingQueue<Runnable> workQueue任务队列</li><li>Executors.defaultThreadFactory()</li><li>handler：拒绝策略</li></ul><p>这里有几个比较不好理解的词语：BlockingQueue和handler</p><h5 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h5><p>BlockingQueue是一个任务队列，它可以指定任务队列的样式，通常有那么几种：</p><ul><li>直接提交的队列：SynchronousQueue。它没有容量，它的每一个插入操作都要等待一个删除操作，这个队列锁提交的任务不会被真实的保存，而是将新任务交给线程执行，如果没有新的进程，便创建一个新的进程，它通常要设置很大的线程容量，否则很容易执行拒绝策略。</li><li>有界的任务队列：ArrayBlockingQueue。这个队列的特点就是，在等待队列已经满之时，又有新的任务加入，且指定线程数目还未超过最大线程数，就创建新的进程执行任务。</li><li>无界的任务队列：LinkedBlockQueue。这个队列在有新的任务加入队列时，但线程已经达到指定的容量，新的任务会进入队列一直等待，而不是创建新的进程。</li><li>优先任务队列：PriorityBlockQueue。顾名思义，带有优先级的队列，一般的队列都是依照着先进先出的规则执行，而这个队列的任务带有优先级标志，按照优先级去执行。</li></ul><p>前面提到过newCacheThreadPool，这个函数的指定线程为0，最大线程数为无穷大。一般情况下，这个线程池没有线程，但是当有新的任务分配到的时候，会加入SynchronousQueue，提交任务。执行完成后，空闲线程若无其他任务，就会在60秒内被回收。</p><h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h4><h5 id="jdk内置的拒绝策略"><a href="#jdk内置的拒绝策略" class="headerlink" title="jdk内置的拒绝策略"></a>jdk内置的拒绝策略</h5><ul><li>AbortPolicy策略：直接抛出异常</li><li>CallerRunsPolicy策略：直接在调用者线程中，运行被抛弃的任务</li><li>DiscardOledestPOlicy策略：丢弃最老的一个请求</li><li>DIscardPolicy策略：默默丢弃无法处理的任务</li></ul><h5 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        test t=<span class="keyword">new</span> test();</span><br><span class="line">        ExecutorService es= <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>,<span class="number">5</span>,<span class="number">0L</span>,</span><br><span class="line">                TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">10</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> RejectedExecutionHandler()&#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">                        System.out.println(r.toString()+<span class="string">"is discard"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;Integer.MAX_VALUE ; i++) &#123;</span><br><span class="line">            es.submit(t);</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis()+<span class="string">" :Theard ID:"</span>+Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1577183355191</span> :Theard ID:<span class="number">12</span></span><br><span class="line"><span class="number">1577183355201</span> :Theard ID:<span class="number">13</span></span><br><span class="line"><span class="number">1577183355291</span> :Theard ID:<span class="number">12</span></span><br><span class="line"><span class="number">1577183355301</span> :Theard ID:<span class="number">13</span></span><br><span class="line"><span class="number">1577183355334</span> :Theard ID:<span class="number">14</span></span><br><span class="line"><span class="number">1577183355344</span> :Theard ID:<span class="number">15</span></span><br><span class="line"><span class="number">1577183355354</span> :Theard ID:<span class="number">16</span></span><br><span class="line">java.util.concurrent.FutureTask@<span class="number">135f</span>baa4is discard</span><br><span class="line">java.util.concurrent.FutureTask@<span class="number">45</span>ee12a7is discard</span><br><span class="line">java.util.concurrent.FutureTask@<span class="number">330</span>bedb4is discard</span><br><span class="line"><span class="number">1577183355391</span> :Theard ID:<span class="number">12</span></span><br><span class="line"><span class="number">1577183355401</span> :Theard ID:<span class="number">13</span></span><br><span class="line">java.util.concurrent.FutureTask@<span class="number">2503</span>dbd3is discard</span><br><span class="line">java.util.concurrent.FutureTask@<span class="number">4</span>b67cf4dis discard</span><br><span class="line"><span class="number">1577183355434</span> :Theard ID:<span class="number">14</span></span><br><span class="line"><span class="number">1577183355444</span> :Theard ID:<span class="number">15</span></span><br><span class="line"><span class="number">1577183355454</span> :Theard ID:<span class="number">16</span></span><br><span class="line">java.util.concurrent.FutureTask@<span class="number">7</span>ea987acis discard</span><br><span class="line">java.util.concurrent.FutureTask@<span class="number">12</span>a3a380is discard</span><br><span class="line">java.util.concurrent.FutureTask@<span class="number">29453f</span>44is discard</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>如上所示，在创建了两个线程之后，发现所需线程不够，便达到了最大线程数，此刻在进行访问的时候，任务太多，处理不过来，便选择了抛弃任务，从而出现了拒绝策略，不去执行这个任务。</p><h5 id="自定义线程创建"><a href="#自定义线程创建" class="headerlink" title="自定义线程创建"></a>自定义线程创建</h5><p>线程池的目的是实现线程复用，但线程池并没有使用new语句去创建多个线程，它仅仅是进行了submit而已，那么这些线程是怎么来的呢？它们来自于ThreadFactory。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;<span class="comment">//定制名字</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        test t=<span class="keyword">new</span> test();</span><br><span class="line">        ExecutorService es=<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>,</span><br><span class="line">                <span class="number">5</span>,</span><br><span class="line">                <span class="number">0L</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                        i++;<span class="comment">//</span></span><br><span class="line">                       Thread t=<span class="keyword">new</span> Thread(r,<span class="string">""</span>+i);<span class="comment">//定制名字</span></span><br><span class="line">                        Thread t=<span class="keyword">new</span> Thread(r);</span><br><span class="line">                        t.setDaemon(<span class="keyword">true</span>);<span class="comment">//设置为守护线程</span></span><br><span class="line">                        System.out.println(<span class="string">"create"</span>+t);</span><br><span class="line">                        <span class="keyword">return</span> t;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">5</span> ; i++) &#123;</span><br><span class="line">            es.submit(t);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="comment">//es.shutdown();</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createThread[Thread-<span class="number">0</span>,<span class="number">5</span>,main]</span><br><span class="line">createThread[Thread-<span class="number">1</span>,<span class="number">5</span>,main]</span><br><span class="line">createThread[Thread-<span class="number">2</span>,<span class="number">5</span>,main]</span><br><span class="line">createThread[Thread-<span class="number">3</span>,<span class="number">5</span>,main]</span><br><span class="line">createThread[Thread-<span class="number">4</span>,<span class="number">5</span>,main]</span><br></pre></td></tr></table></figure><p>如上，在创建了线程池之后，重写线程池的ThreadFactory方法，修改了线程工厂的构造方法，这使得我们在submit这个t对象后，使用构造方法构造了许多线程，可以看到这个线程所输出的信息。由于将所有的线程都设置为了守护线程，这使得我们的主线程退出后，会自动销毁所有线程，而不需要再加一个es.shutdown();去手动的结束线程。</p><h4 id="扩展线程池"><a href="#扩展线程池" class="headerlink" title="扩展线程池"></a>扩展线程池</h4><p>我们在使用线程的时候，对于线程的创建和销毁状态是不可见的，只能在执行run方法的时候，才能够从中察觉，但能不能在创建或者销毁的时候去监控它呢?当然是可以的啦！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">mytask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">mytask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"正在执行"</span>+<span class="string">" 线程ID："</span>+Thread.currentThread().getId()+<span class="string">",task name="</span>+name);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService es=<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>,<span class="number">5</span>,<span class="number">0L</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;())&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"准备执行"</span>+((mytask) r).name);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"执行完成"</span>+((mytask) r).name);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"线程池退出"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            mytask t=<span class="keyword">new</span> mytask(<span class="string">"task_geym_"</span>+i);</span><br><span class="line">            es.execute(t);</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">准备执行task_geym_0</span><br><span class="line">正在执行 线程ID：<span class="number">12</span>,task name=task_geym_0</span><br><span class="line">准备执行task_geym_1</span><br><span class="line">正在执行 线程ID：<span class="number">13</span>,task name=task_geym_1</span><br><span class="line">准备执行task_geym_2</span><br><span class="line">正在执行 线程ID：<span class="number">14</span>,task name=task_geym_2</span><br><span class="line">准备执行task_geym_3</span><br><span class="line">正在执行 线程ID：<span class="number">15</span>,task name=task_geym_3</span><br><span class="line">准备执行task_geym_4</span><br><span class="line">正在执行 线程ID：<span class="number">16</span>,task name=task_geym_4</span><br><span class="line">执行完成task_geym_0</span><br><span class="line">执行完成task_geym_1</span><br><span class="line">执行完成task_geym_2</span><br><span class="line">执行完成task_geym_3</span><br><span class="line">执行完成task_geym_4</span><br><span class="line">线程池退出</span><br></pre></td></tr></table></figure><p>只要选择自行重写beforeExecute和afterExecute方法便可以实现啦。</p><h4 id="线程池中的堆栈"><a href="#线程池中的堆栈" class="headerlink" title="线程池中的堆栈"></a>线程池中的堆栈</h4><p>在上面的时候，我们发现线程池使用execute去执行程序而不是submit，这是有很多原因的，其中一点就是，execute可以打印出异常堆栈，这代表的，如果线程的创建出了一个无法被编译器识别的错误的，可以将其错误的地方打印出来，这使得我们的程序更为优秀。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor es=<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>,Integer.MAX_VALUE,<span class="number">0L</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">5</span> ; i++) &#123;</span><br><span class="line">            es.execute(<span class="keyword">new</span> test(<span class="number">100</span>,i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> re=a/b;</span><br><span class="line">        System.out.println(re);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Exception in thread <span class="string">"pool-1-thread-1"</span> java.lang.ArithmeticException: / by zero</span><br><span class="line">at test.run(test.java:<span class="number">24</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1149</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"><span class="number">100.0</span></span><br><span class="line"><span class="number">25.0</span></span><br><span class="line"><span class="number">33.0</span></span><br><span class="line"><span class="number">50.0</span></span><br></pre></td></tr></table></figure><p>比如这个，发生了除数为0，而导致线程的出错，但是如果你的方法是submit，则打印不出来异常堆栈。顺着提示的错误点，点进去，你就可以快速找到是哪里错了，但是这样仍然不能够找到提交的地点，那应该怎么做呢？</p><p>首先写一个新的类并继承ThreadPoolExecutor，并重写提交和执行这两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 打印出异常堆栈的类 <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> 打印出异常堆栈的类(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.execute(wrap(command,clientTrace(),Thread.currentThread().getName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.submit(wrap(task,clientTrace(),Thread.currentThread().getName()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Exception <span class="title">clientTrace</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Exception(<span class="string">"客户端堆栈追踪"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Runnable <span class="title">wrap</span><span class="params">(<span class="keyword">final</span> Runnable task,<span class="keyword">final</span> Exception clientStack,String clientThreadName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    clientStack.printStackTrace();</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而submit函数返回的是一个Runnable型的类，那么我们便可以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写一个Runnable型函数去返回它，调用的时候还是使用task.run();继续调用，但区别在于传入了一个叫做Exception型的参数：clientStack.printStackTrace();使其找到提交的地点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor es=<span class="keyword">new</span> 打印出异常堆栈的类(<span class="number">0</span>,Integer.MAX_VALUE,<span class="number">0L</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">5</span> ; i++) &#123;</span><br><span class="line">            es.submit(<span class="keyword">new</span> test(<span class="number">100</span>,i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> re=a/b;</span><br><span class="line">        System.out.println(re);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">java.lang.Exception: client stack trace</span><br><span class="line">at 打印出异常堆栈的类.clientTrace(打印出异常堆栈的类.java:<span class="number">21</span>)</span><br><span class="line">at 打印出异常堆栈的类.submit(打印出异常堆栈的类.java:<span class="number">18</span>)</span><br><span class="line">at test.main(test.java:<span class="number">17</span>)</span><br><span class="line"><span class="number">100.0</span></span><br><span class="line"><span class="number">25.0</span></span><br><span class="line"><span class="number">33.0</span></span><br><span class="line"><span class="number">50.0</span></span><br></pre></td></tr></table></figure><p>瞬间定位提交地点。</p><h4 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h4><p>一般来说，线程都有各自的任务，但各个任务的难度都不相同，有的繁琐而艰巨，有的只是喝茶聊天，所以设计者为了平衡这样的状况，设计出了一个叫做Fork/Join的框架，它能够实现线程之间的互助，比如说t1线程早就执行完了自己的任务，他就会去帮助t2线程执行任务。而很多线程在执行任务的时候，都是由队列的顶部去抓取数据，而在Fork/Join框架线程互助的时候，t1会从t2的底部去抓取数据，从而避免了数据的竞争。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Threshold =<span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">test</span><span class="params">(<span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ForkJoinPool fjp=<span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        test t=<span class="keyword">new</span> test(<span class="number">0</span>,<span class="number">200000L</span>);</span><br><span class="line">        ForkJoinTask&lt;Long&gt; result=fjp.submit(t);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> res=result.get();</span><br><span class="line">            System.out.println(<span class="string">"sum="</span>+res);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> canCompute=(end-start)&lt;Threshold;</span><br><span class="line">        <span class="keyword">if</span> (canCompute)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = start; i &lt;end ; i++) &#123;</span><br><span class="line">                sum+=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//分成100个小任务</span></span><br><span class="line">            <span class="keyword">long</span> step=(start+end)/<span class="number">100</span>;</span><br><span class="line">            ArrayList&lt;test&gt; subtests=<span class="keyword">new</span> ArrayList&lt;test&gt;();</span><br><span class="line">            <span class="keyword">long</span> pos=start;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">100</span> ; i++) &#123;</span><br><span class="line">                <span class="keyword">long</span> lastone=pos+step;</span><br><span class="line">                <span class="keyword">if</span>(lastone&gt;end)&#123;</span><br><span class="line">                    lastone=end;</span><br><span class="line">                &#125;</span><br><span class="line">                test subtest=<span class="keyword">new</span> test(pos,lastone);</span><br><span class="line">                pos+=step+<span class="number">1</span>;</span><br><span class="line">                subtests.add(subtest);</span><br><span class="line">                subtest.fork();</span><br><span class="line">            &#125;<span class="comment">//分而治之</span></span><br><span class="line">            <span class="keyword">for</span> (test t:</span><br><span class="line">                 subtests) &#123;</span><br><span class="line">                sum+=t.join();</span><br><span class="line">            &#125;<span class="comment">//最后累加</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">sum=<span class="number">19989995149</span></span><br></pre></td></tr></table></figure><p>这是一道计算1到200000求和的计算题，利用了算法当中的分治法，但这个分治法是使用多线程是完成的。首先设置了阈值为10000，若大于这个阈值，则进行将其往下分解100个小任务，每个任务将每一段都构造新的test()进行加入队列，其次在使用fork方法执行每个test类的compute方法，分解的值都加入subtests队列。最后每个subtest使用join方法导出值，并且加入sum。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（九）同步控制</title>
      <link href="/2019/12/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B9%9D%EF%BC%89/"/>
      <url>/2019/12/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B9%9D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="多线程的团队协作"><a href="#多线程的团队协作" class="headerlink" title="多线程的团队协作"></a>多线程的团队协作</h3><h4 id="重入锁（ReentrantLock）"><a href="#重入锁（ReentrantLock）" class="headerlink" title="重入锁（ReentrantLock）"></a>重入锁（ReentrantLock）</h4><h5 id="什么是重入锁"><a href="#什么是重入锁" class="headerlink" title="什么是重入锁"></a>什么是重入锁</h5><p>重入锁和synchronized非常的相似，我们知道synchronized的锁区域是用大括号所包围起来的，而ReentrantLock则是可以自己决定加锁的位置和解锁的位置的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">L.lock();</span><br><span class="line">L.unloock();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock L=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> test());</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> test());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;<span class="number">10000</span> ; j++) &#123;</span><br><span class="line">            L.lock();</span><br><span class="line">            L.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                L.unlock();</span><br><span class="line">                L.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">20000</span></span><br></pre></td></tr></table></figure><p>与synchronized比较大的区别还在于，ReentrantLock是可以重入的，如上述代码所示，使用了两个L.lock()，但是仍然能够运行，这表示着这是同一个线程在获得锁，每次获得锁就会在计数器上+1，在解锁的时候在计数器上-1，这样最后的计数器为零的时候完全释放锁。这种方法可以看做为，只要是同一个线程获取的锁，就可以被一直重入。</p><p>而lock（）的实现为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个叫做CAS操作，意思为比较和交换，这种操作方式能够获得原子性，以致于起到synchronized的作用。</p><h5 id="ReentrantLock的中断"><a href="#ReentrantLock的中断" class="headerlink" title="ReentrantLock的中断"></a>ReentrantLock的中断</h5><p>重入锁还有另一个非常人性化的一点，那就是会自然的中断，比如在遇到产生的死锁问题的时候ReentrantLock就会自然中断，防止死锁的发生，这是synchronized所不具有的。</p><p>还记得之前讲过的interrupt吗，它仅仅是起到一个标记作用而已，为什么不用flag去代替它呢？效果不是一样吗？其实，interrupt标记还能够作用于其他的类用于线程的控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock1=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock2=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">int</span> lock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> lock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> test(<span class="number">1</span>));</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> test(<span class="number">2</span>));</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        t2.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(lock==<span class="number">1</span>)&#123;</span><br><span class="line">                lock1.lockInterruptibly();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                lock2.lockInterruptibly();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                lock2.lockInterruptibly();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                lock1.lockInterruptibly();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lock1.isHeldByCurrentThread())</span><br><span class="line">            &#123;lock1.unlock();&#125;</span><br><span class="line">            <span class="keyword">if</span> (lock2.isHeldByCurrentThread())</span><br><span class="line">            &#123;lock2.unlock();&#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getId()+<span class="string">"退出"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">java.lang.InterruptedException</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchronizer.java:<span class="number">898</span>)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchronizer.java:<span class="number">1222</span>)</span><br><span class="line">at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:<span class="number">335</span>)</span><br><span class="line">at test.run(test.java:<span class="number">38</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"><span class="number">12</span> 退出</span><br><span class="line"><span class="number">13</span> 退出</span><br></pre></td></tr></table></figure><p>一开始，设置了两个线程，线程t1先获得锁，t2阻塞，当在等待两秒后，设置了可以中断的标记，于是t2便不再尝试去获得锁，直接断开，从而开始输出错误信息。</p><h5 id="限时等待锁"><a href="#限时等待锁" class="headerlink" title="限时等待锁"></a>限时等待锁</h5><p>使用中断标记去打断锁的话，虽然可以解决死锁，但也可能会出现数据不一致的问题，于是乎可以使用等待时间这一方式去等待锁，如果时间到了还没有获得锁，便直接放弃它。使用的api叫做trylock()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>它有的构造方法有两个参数，一个是数值，一个是计时单位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> test());</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> test());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lock.tryLock(<span class="number">5</span>, TimeUnit.SECONDS))&#123;</span><br><span class="line">                Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"get lock faild"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(lock.isHeldByCurrentThread())&#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">get lock faild</span><br></pre></td></tr></table></figure><p>一开始t1便运行run方法获得了锁，并等待6秒，然后t2进入了if判断语句中，开始等待5秒，等待时间过后，仍然没有获得锁，便返回一个false值，打印出get lock faild，最后lock再解锁。当然，你也会想，万一传入的参数是0怎么办呢，其实，你传入的参数是0的话，就和没有传参数的构造函数一样的，可以猜想的到，没有参数，那就不会等待，一旦感觉到阻塞，就立即退出。</p><h5 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h5><p>线程在相互竞争资源的顺序可以被自由决定吗？默认是不能的，其实设计者也能想的到，要由自己去控制资源的顺序，已达到安全的、稳定的目的，但是这样做会使的线程运行变得更慢，因为要给快速运行的线程加一个队列的话，开销是很大的，所以大多数的时候，是随意的、非公平的，但这并不代表不可以由自己自由的去决定。</p><p>我们先看一个ReentrantLock的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个单构造函数传入的是布尔值，这个布尔值是选择这个重入锁是公平的还是非公平的，默认是非公平的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock=<span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> test(),<span class="string">"joker"</span>);</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> test(),<span class="string">"alex"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" 获得锁"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">joker 获得锁</span><br><span class="line">alex 获得锁</span><br><span class="line">joker 获得锁</span><br><span class="line">alex 获得锁</span><br><span class="line">joker 获得锁</span><br><span class="line">alex 获得锁</span><br></pre></td></tr></table></figure><p>这就是重入锁设置公平和非公平的办法啦，看一来是不是有点眼熟呢，没错，我们之前的双线程累加到20000的例子，也可以用这个来实现。看看底层的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这里在判断条件中，公平锁多了一个hasQueuedPredecessors()方法，既加入了同步队列中当前节点是否有前驱节点的判断，如果返回true，则表明有线程比当前线程更早的请求锁，因此需要等待前驱线程获取并释放锁之后才能继续获得锁。</p><p>总结：ReentrantLock的几个重要方法：</p><ul><li>lock();</li><li>lockinterruptibly();</li><li>trylock();</li><li>unlock();</li><li>new ReentrantLock(true);</li></ul><h5 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h5><p>这里稍微讲一下底层的实现，我们可以从重入锁的类接口看到它是接入了一个Lock的接口，并重写它的方法，但值得注意的是，它们实际上使用的，是来自一个叫做AQS的同步器(AbstractQueuedSynchronizer)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br></pre></td></tr></table></figure><p>获得锁的调用的是tryAcquire方法，而这个方法来自于AQS队列同步器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>可以看到这里使用getState();去判断获取当前状态，如果为0，说明没有线程获得了该锁，代表可以进行CAS操作去获取锁</p><h5 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h5><p>总结了几点Synchronized和ReentrantLock的区别：</p><ol><li><p>Synchronized是JVM层次的锁实现，ReentrantLock是JDK层次的锁实现；</p></li><li><p>Synchronized的锁状态是无法在代码中直接判断的，但是ReentrantLock可以通过ReentrantLock#isLocked判断；</p></li><li><p>Synchronized是非公平锁，ReentrantLock是可以是公平也可以是非公平的；</p></li><li><p>Synchronized是不可以被中断的，而ReentrantLock#lockInterruptibly方法是可以被中断的；</p></li><li><p>在发生异常时Synchronized会自动释放锁（由javac编译时自动实现），而ReentrantLock需要开发者在finally块中显示释放锁；</p></li><li><p>ReentrantLock获取锁的形式有多种：如立即返回是否成功的tryLock(),以及等待指定时长的获取，更加灵活；</p></li><li><p>Synchronized在特定的情况下对于已经在等待的线程是后来的线程先获得锁，而ReentrantLock对于已经在等待的线程一定是先来的线程先获得锁；</p></li></ol><h4 id="Condition条件"><a href="#Condition条件" class="headerlink" title="Condition条件"></a>Condition条件</h4><p>与synchronized对应的是lock和unlock，那么与Tread类的wait和notify方法，ReentrantLock也有相应的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Condition condition=lock.newCondition();<span class="comment">//设置condition</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> test());</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="comment">//继续加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        condition.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">"开始等待"</span>);</span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(<span class="string">"继续运行"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">开始等待</span><br><span class="line">继续运行</span><br></pre></td></tr></table></figure><p>使用condition.await()和condition.signal()方法，分别让线程阻塞和唤醒。</p><h4 id="线程的交通信号灯：Semaphore"><a href="#线程的交通信号灯：Semaphore" class="headerlink" title="线程的交通信号灯：Semaphore"></a>线程的交通信号灯：Semaphore</h4><p>线程的公平锁和非公平锁是线程之间排队运行用的，但除此之外，我们还有别的控制线程的方法，就比如说，某个函数只是偶尔被调用，但需要调用的时候，却会变得非常频繁，这时候我们就要控制好线程的队列了，不能一口气涌入成千上万条线程，最终导致负载过大，停止运行。</p><p>于是便需要一个信号灯，也叫作信号量 ：Semaphore</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Semaphore semaphore=<span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newFixedThreadPool(<span class="number">20</span>);<span class="comment">//线程池，后面会提</span></span><br><span class="line">        <span class="keyword">final</span> test demo=<span class="keyword">new</span> test();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">20</span> ; i++) &#123;</span><br><span class="line">            exec.submit(demo);<span class="comment">//运行run方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            semaphore.acquire();<span class="comment">//此处进入线程为5的时候，阻塞后面的线程，直到使用release为止</span></span><br><span class="line">            <span class="comment">//模拟耗时</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getId()+<span class="string">"to doing"</span>);</span><br><span class="line">            semaphore.release();<span class="comment">//通知acquire继续放行</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要使用acquire和release方法，控制着线程的运行数量。</p><ul><li>semaphore.acquire();//此处进入线程为5的时候，阻塞后面的线程，直到使用release为止</li><li>semaphore.release();;//通知acquire继续放行</li></ul><h4 id="倒计时器：CountDownLatch"><a href="#倒计时器：CountDownLatch" class="headerlink" title="倒计时器：CountDownLatch"></a>倒计时器：CountDownLatch</h4><p>如果说Semaphore如同交通信号灯一般，获取一定数量，每执行一次release释放一个线程，再允许进入一个线程，这样的流水线，那么CountDownLatch就是每次等到达一定数量，一口气放行。</p><p>CountDownLatch就像一个火箭的发射台，要等到全部准备就绪的时候，才能够发射，缺一个都不行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatch end=<span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> test demo=<span class="keyword">new</span> test();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            executorService.submit(demo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//等待所有就绪</span></span><br><span class="line">        end.await();<span class="comment">//主线程等待end的count值达到0之后继续执行下一步</span></span><br><span class="line">        <span class="comment">//开始</span></span><br><span class="line">        System.out.println(<span class="string">"开始"</span>);</span><br><span class="line">        executorService.shutdown();<span class="comment">//执行结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>)*<span class="number">100</span>);</span><br><span class="line">            System.out.println(<span class="string">"检查完成"</span>);</span><br><span class="line">            end.countDown();<span class="comment">//执行这个方法表示线程已经准备就绪了，count计数器-1</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">检查完成</span><br><span class="line">检查完成</span><br><span class="line">检查完成</span><br><span class="line">检查完成</span><br><span class="line">检查完成</span><br><span class="line">检查完成</span><br><span class="line">检查完成</span><br><span class="line">检查完成</span><br><span class="line">检查完成</span><br><span class="line">检查完成</span><br><span class="line">开始</span><br></pre></td></tr></table></figure><p>里面涉及了几个方法，</p><ul><li>end.countDown();计数器</li><li>end.await();等待完成计数量</li><li>new CountDownLatch(10);传入一个参数表示数值</li></ul><h4 id="循环栅栏：CyclicBarrier"><a href="#循环栅栏：CyclicBarrier" class="headerlink" title="循环栅栏：CyclicBarrier"></a>循环栅栏：CyclicBarrier</h4><p>CyclicBarrier和CountDownLatch非常相似，最大的区别就是CyclicBarrier可以重复被利用，而CountDownLatch不行。</p><p>CyclicBarrier正如它的名字一样，循环栅栏，栅栏是一个阻挡别人进入的障碍物，CyclicBarrier和CountDownLatch一样有一个计数器，不过CountDownLatch的计数器被定义了之后就只能被一直减少，最后减少到0时，完全结束，而CyclicBarrier的计数器则是从0开始增加，直到指定数值时开始放行，然后计数器归零，并等待下一波线程的访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> CyclicBarrier end=<span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> test demo=<span class="keyword">new</span> test();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService= Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">20</span> ; i++) &#123;</span><br><span class="line">            executorService.submit(demo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>)*<span class="number">100</span>);</span><br><span class="line">            end.await();</span><br><span class="line">            System.out.println(Thread.currentThread().getId()+<span class="string">"集合完成"</span>);</span><br><span class="line">            end.await();</span><br><span class="line">            System.out.println(Thread.currentThread().getId()+<span class="string">"执行完成"</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法更为简单，且可以被复用，运行之后可以看到一开始是集结了5个线程之后，才会继续运行下去，这表示了CyclicBarrier的阻塞作用它后面的线程，CyclicBarrier主要的方法就是await()；方法，值得注意的是，CyclicBarrier有了更多的异常处理：BrokenBarrierException e 这个异常处理表示如果发生了意外使得线程破损，无法继续运行，那就让那个线程中断，防止阻塞后面的线程，而之所以CountDownLatch不这样做，是因为，它的特性就是必须全部都集合了之后才能运行，所以没有这个异常处理。</p><h4 id="线程的阻塞工具：LockSupport"><a href="#线程的阻塞工具：LockSupport" class="headerlink" title="线程的阻塞工具：LockSupport"></a>线程的阻塞工具：LockSupport</h4><p>之前说过线程的挂起(suspend)和继续执行(resume)，这个在之后有了一个比较灵活的类去代替，它就是LockSupport</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line">public class test implements Runnable &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread t&#x3D;new Thread(new test());</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">        LockSupport.unpark(t);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getId()+&quot;执行run方法中,已经被阻塞&quot;);</span><br><span class="line">        LockSupport.park();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unpark传入参数表示要解锁的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">        UNSAFE.unpark(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unpark方法也会和resume方法一样先于park（suspend）方法执行，但是与其不同的是，unpark就算先执行了，也不会产生死循环，因为unpark会产生一个特别的许可，这个许可，不可叠加且只有一个，只会被park所获取，所以就算unpark先于park发生，只要产生了这个许可，park就能够获取这个许可并且停止阻塞继续运行</p><h4 id="ReadWriteLock读写锁"><a href="#ReadWriteLock读写锁" class="headerlink" title="ReadWriteLock读写锁"></a>ReadWriteLock读写锁</h4><p>我们在对一个对象进行操作的时候，无论是读取还是写入，为了保持原子性，都用以synchronized包围，但是，在很多实际应用中，读取操作都是要远大于写入操作的，但是却全都用synchronized去上锁，这无疑降低了某些方面的效率，于是乎，设计者根据这种情况，设计了一个叫做读写锁的类，将读取操作与写入操作分离，使两个线程在读取同一个对象的时候，不阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock reentrantReadWriteLock=<span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock read=reentrantReadWriteLock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> test demo=<span class="keyword">new</span> test();</span><br><span class="line">        Runnable readrunnable=<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    demo.handleRead(read);</span><br><span class="line">                    <span class="comment">//demo.handleRead(lock);</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">18</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(readrunnable).start();<span class="comment">//开启线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">handleRead</span><span class="params">(Lock lock)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);<span class="comment">//线程休眠</span></span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当这个方法开启的时候，在休眠一秒后加了锁，按道理来说，18个线程至少要等18秒才能运行完成，但是对于锁类型是读写锁的线程而言，可以被多个线程重复进入，重入锁和读写锁的区别在于，重入锁是对于本线程的行为可以被重复进入而不加锁，读写锁则是对于多个不进行修改操作的线程，都可以进入而不加锁。</p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>int getReadLockCount()</td><td>获取读锁的数量，此时读锁的数量不一定等于获取锁的数量，因为锁可以重入，可能有线程重入了读锁</td></tr><tr><td>int getReadHoldCount()</td><td>获取当前线程重入读锁的次数</td></tr><tr><td>int getWriteHoldCount()</td><td>获取当前线程重入写锁的次数</td></tr><tr><td>int isWriteLocked()</td><td>判断锁的状态是否是写锁，返回true，表示锁的状态是写锁</td></tr></tbody></table><h5 id="读写状态的设计"><a href="#读写状态的设计" class="headerlink" title="读写状态的设计"></a>读写状态的设计</h5><p>读写锁和重入锁在设计上都继承了AQS队列同步器，相关描述来自掘金作者天堂同志。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br></pre></td></tr></table></figure><ul><li>在AQS中，通过int类型的全局变量state来表示同步状态，即用state来表示锁。ReentrantReadWriteLock也是通过AQS来实现锁的，但是ReentrantReadWriteLock有两把锁：读锁和写锁，它们保护的都是同一个资源，那么如何用一个共享变量来区分锁是写锁还是读锁呢？答案就是按位拆分。</li><li>由于state是int类型的变量，在内存中占用4个字节，也就是32位。将其拆分为两部分：高16位和低16位，其中高16位用来表示读锁状态，低16位用来表示写锁状态。当设置读锁成功时，就将高16位加1，释放读锁时，将高16位减1；当设置写锁成功时，就将低16位加1，释放写锁时，将第16位减1。如下图所示：</li></ul><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/aqs4.jpg" alt="aqs4"></p><ul><li>那么如何根据state的值来判断当前锁的状态时写锁还是读锁呢？</li><li>假设锁当前的状态值为S，将S和16进制数0x0000FFFF进行与运算，即S&amp;0x0000FFFF，运算时会将高16位全置为0，将运算结果记为c，那么c表示的就是写锁的数量。如果c等于0就表示还没有线程获取锁；如果c不等于0，就表示有线程获取到了锁，c等于几就代表写锁重入了几次。</li><li>将S无符号右移16位（S&gt;&gt;&gt;16），得到的结果就是读锁的数量。当S&gt;&gt;&gt;16得到的结果不等于0，且c也不等于0时，就表示当前线程既持有了写锁，也持有了读锁。</li><li>当成功获取到读锁时，如何对读锁进行加1呢？S +（1&lt;&lt;16）得到的结果，就是将对锁加1。释放读锁是，就进行S - (1&lt;&lt;16)运算。</li><li>当成功获取到写锁时，令S+1即表示写锁状态+1；释放写锁时，就进行S-1运算。</li><li>由于读锁和写锁的状态值都只占用16位，所以读锁的最大数量为 <img src="https://juejin.im/equation?tex=2%5E%7B16%7D" alt="2^{16}">)-1，写锁可被重入的最大次数为<img src="https://juejin.im/equation?tex=2%5E%7B16%7D" alt="2^{16}">-1。</li></ul><h5 id="写锁的获取与释放"><a href="#写锁的获取与释放" class="headerlink" title="写锁的获取与释放"></a>写锁的获取与释放</h5><p>写锁是一个排它锁，只能被一个线程所获取，这个锁的主要方法，也来自于AQS同步器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// exclusiveCount()方法的作用是将同步变量与0xFFFF做&amp;运算，计算结果就是写锁的数量。</span></span><br><span class="line">    <span class="comment">// 因此w的值的含义就是写锁的数量</span></span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="comment">// 如果c不为0就表示锁被占用了，但是占用的是写锁还是读书呢？这个时候就需要根据w的值来判断了。</span></span><br><span class="line">    <span class="comment">// 如果c等于0就表示此时锁还没有被任何线程占用，那就让线程直接去尝试获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1. 如果w为0，说明写锁的数量为0，而此时又因为c不等于0，说明锁被占用，但是不是写锁，那么此时锁的状态一定是读锁，</span></span><br><span class="line"><span class="comment">         * 既然是读锁状态，那么写锁此时来获取锁时，就肯定失败，因此当w等于0时，tryAcquire()方法返回false。</span></span><br><span class="line"><span class="comment">         * 2. 如果w不为0，说明此时锁的状态时写锁，接着进行current != getExclusiveOwnerThread()判断，判断持有锁的线程是否是当前线程</span></span><br><span class="line"><span class="comment">         * 如果不是当前线程，那么tryAcquire()返回false；如果是当前线程，那么就进行后面的逻辑。为什么是当前线程持有锁，就还能执行后面的逻辑呢？</span></span><br><span class="line"><span class="comment">         * 因为读写锁是支持重入的。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 下面一行代码是判断，写锁的重入次数或不会超过最大限制，这个最大限制是：2的16次方减1</span></span><br><span class="line">        <span class="comment">// 为什么是2的16次方减1呢？因为state的低16位存放的是写锁，因此写锁数量的最大值是2的16次方减1</span></span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// Reentrant acquire</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. writerShouldBlock()方法的作用是判断当前线程是否应该阻塞，对于公平的写锁和非公平写锁的具体实现不一样。</span></span><br><span class="line"><span class="comment">     * 对于非公平写锁而言，直接返回false，因为非公平锁获取锁之前不需要去判断是否排队</span></span><br><span class="line"><span class="comment">     * 对于公平锁写锁而言，它会判断同步队列中是否有人在排队，有人排队，就返回true，表示当前线程需要阻塞。无人排队就返回false。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. 当writerShouldBlock()返回true时，表示当前线程还不能直接获取锁，因此tryAcquire()方法直接返回false。</span></span><br><span class="line"><span class="comment">     * 当writerShouldBlock()返回false时，表示当前线程可以尝试去获取锁，因此会执行if判断中后面的逻辑，即通过CAS方法尝试去修改同步变量的值，</span></span><br><span class="line"><span class="comment">     * 如果修改同步变量成功，则表示当前线程获取到了锁，最终tryAcquire()方法会返回true。如果修改失败，那么tryAcquire()会返回false，表示获取锁失败。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写锁的释放与排他锁的释放逻辑也几乎一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否是当前线程持有锁</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">// 将state的值减去releases</span></span><br><span class="line">    <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">    <span class="comment">// 调用exclusiveCount()方法，计算写锁的数量。如果写锁的数量为0，表示写锁被完全释放，此时将AQS的exclusiveOwnerThread属性置为null</span></span><br><span class="line">    <span class="comment">// 并返回free标识，表示写锁是否被完全释放</span></span><br><span class="line">    <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="读锁的获取与释放"><a href="#读锁的获取与释放" class="headerlink" title="读锁的获取与释放"></a>读锁的获取与释放</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This code is in part redundant with that in</span></span><br><span class="line"><span class="comment">     * tryAcquireShared but is simpler overall by not</span></span><br><span class="line"><span class="comment">     * complicating tryAcquireShared with interactions between</span></span><br><span class="line"><span class="comment">     * retries and lazily reading hold counts.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// for死循环，直到满足相应的条件才会return退出，否则一直循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 锁的状态为写锁时，持有锁的线程不等于当期那线程，就说明当前线程获取锁失败，返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// else we hold the exclusive lock; blocking here</span></span><br><span class="line">            <span class="comment">// would cause deadlock.</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">            <span class="comment">// Make sure we're not acquiring read lock reentrantly</span></span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            readHolds.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// 尝试设置同步变量的值，只要设置成功了，就表示当前线程获取到了锁，然后就设置锁的获取次数等相关信息</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                rh.count++;</span><br><span class="line">                cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">        <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">        <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">            firstReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">        <span class="keyword">int</span> count = rh.count;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            readHolds.remove();</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        --rh.count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 将修改同步变量的值（读锁状态减去1&lt;&lt;16）</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">            <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">            <span class="comment">// both read and write locks are now free.</span></span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><h5 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h5><p>读写锁会发生锁降级的事件，这里的锁降级指的是线程获取到了写锁，在没有释放写锁的情况下，又获取读锁。为什么不支持锁升级呢？举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="comment">// 创建读锁</span></span><br><span class="line">    Lock readLock = lock.readLock();</span><br><span class="line">    <span class="comment">// 创建写锁</span></span><br><span class="line">    Lock writeLock = lock.writeLock();</span><br><span class="line">    readLock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// ...处理业务逻辑</span></span><br><span class="line">        writeLock.lock();   <span class="comment">// 代码①</span></span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例代码中，假如T1线程先获取到了读锁，然后执行后面的代码，在执行到代码①的上一行时，T2线程也去获取读锁，由于读锁是共享锁，且此时写锁还没有被获取，所以此时T2线程可以获取到读锁，当T1执行到代码①时，尝试去获取写锁，由于有T2线程占用了读锁，所以T1线程是无法获取到写锁的，只能等待，当T2也执行到代码①时，由于T1占有了读锁，导致T2无法获取到写锁，这样两个线程就一直等待，即获取不到写锁，也释放不掉读锁。因此锁是不支持锁升级的。</p><p>读写锁支持锁的降级，锁的降级是为了保证可见性。让T1线程对数据的修改对其他线程可见。读锁不支持条件等待队列。当调用ReadLock类的newCondition()方法时，会直接抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为读锁是共享锁，最大获取次数为<img src="https://juejin.im/equation?tex=2%5E%7B16%7D" alt="2^{16}">-1，同一时刻可以被多个线程持有，对于读锁而言，其他线程没有必要等待获取读锁，Condition的等待唤醒毫无意义。</p><p>那么锁降级中，先获取到读锁有没有必要呢？答案是肯定的。如果当前线程不获取读锁而是直接释放写锁，假设此刻存在另一个线程获取了写锁并修改了数据，那么当前线程就无法感知到另一个线程的更新。如果当前线程获取到了读锁，遵循锁降级的步骤，则另一个线程就会被阻塞，直到当前的线程使用数据并释放读锁之后，另一个线程才能获取写锁进行数据更新。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（八）synchronized原理</title>
      <link href="/2019/12/22/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%85%AB%EF%BC%89/"/>
      <url>/2019/12/22/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%85%AB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="synchronized原理"><a href="#synchronized原理" class="headerlink" title="synchronized原理"></a>synchronized原理</h1><h2 id="synchronized的概念"><a href="#synchronized的概念" class="headerlink" title="synchronized的概念"></a>synchronized的概念</h2><h3 id="synchronized的简介"><a href="#synchronized的简介" class="headerlink" title="synchronized的简介"></a>synchronized的简介</h3><p>synchronized是一个在Java中比较常见的锁。可以选择在代码中加入synchronized代码块，也可以在方法头加入synchronized的声明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncBlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"hello block"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在反编译为字节码后，可以看到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  public void syncBlock();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;2, locals&#x3D;3, args_size&#x3D;1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: dup</span><br><span class="line">         2: astore_1</span><br><span class="line">         3: monitorenter   &#x2F;&#x2F; monitorenter指令进入同步块</span><br><span class="line">         4: getstatic     #2                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">         7: ldc           #3                  &#x2F;&#x2F; String hello block</span><br><span class="line">         9: invokevirtual #4                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">        12: aload_1</span><br><span class="line">        13: monitorexit  &#x2F;&#x2F; monitorexit指令退出同步块</span><br><span class="line">        14: goto          22</span><br><span class="line">        17: astore_2</span><br><span class="line">        18: aload_1</span><br><span class="line">        19: monitorexit  &#x2F;&#x2F; monitorexit指令退出同步块</span><br><span class="line">        20: aload_2</span><br><span class="line">        21: athrow</span><br><span class="line">        22: return</span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             4    14    17   any</span><br><span class="line">            17    20    17   any</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  public synchronized void syncMethod();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED      &#x2F;&#x2F;添加了ACC_SYNCHRONIZED标记</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;2, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: getstatic     #2                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">         3: ldc           #5                  &#x2F;&#x2F; String hello method</span><br><span class="line">         5: invokevirtual #4                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">         8: return</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Javac在编译的时候，在第3行生成了monitorenter指令，表示这同步块的进入，在13行使用monitorexit表示同步块的退出。之所以会有两个monitorexit是因为：在保证抛出异常的情况下，也能够释放锁，就相当于Java里面的try-final语句块。</p><p>而对于synchronized的方法而言，javac为它生成了一个<strong>ACC_SYNCHRONIZED</strong>关键字，在JVM进行方法调用的时候，会发现这个关键字，并先尝试去获得锁。</p><h3 id="锁的几种形式"><a href="#锁的几种形式" class="headerlink" title="锁的几种形式"></a>锁的几种形式</h3><p>在JDK5以及之前，synchronized是重量级锁，每次运行需要同步的代码块的时候，总是锁住所有需要进入的线程，来保持原子性。所以synchronized在这之前都不如其他的同步函数，但在JKD6开始，java引入了新的机制：<strong>锁升级</strong>。当然，JVM种的锁也是能降级的，只不过条件很苛刻。</p><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><p>首先就要提到对象头。因为在Java中，任何的对象都可以被加锁，所以必然需要一个映射关系，存储该对象以及其对应的锁信息，这样才能知道当前哪个线程持有锁，哪些线程需要等待。有一种很直观的方法是，使用一个全局的Map，来存储这个映射关系，但这又会涉及到一些问题，比如这个Map怎么保持线程安全，不同的synchronized之间又会出现互相的影响，性能比较差，如果需要同步的对象比较多的话，该Map所占用的内存也会增多。</p><p>所以，不如将这些映射关系存储在目标的对象头好了。因为对象头本身也有一些关于hashcode、GC相关的数据，不妨就将这些锁的信息一并封装起来。</p><p>在JVM中，对象在内存中除了本身的数据外还会有个对象头，对于普通对象而言，其对象头中有两类信息：mark word和类型指针。另外对于数组而言还会有一份记录数组长度的数据。</p><p>类型指针是指向该对象所属类对象的指针，mark word 用于存储对象的hashcode、GC分代年龄、锁状态等信息。在32位系统上mark word长度为32字节，64位系统上长度为64字节。为了能在有限的空间里存储下更多的数据，其存储格式是不固定的，在32位系统上各状态的格式如下：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/synchronized/synchronize1.jpg" alt="s"></p><p>这就是整个mark word所存储的信息了。可以看到，锁的信息也存在于对象的mark word当中。<strong>当对象状态为偏向锁（biasable）时，mark word存储的是偏向的线程ID；当状态为轻量级锁（lightweight locked）时，mark word存储的是指向线程栈中Lock Record的指针；当状态为重量级锁（inflated）时，为指向堆中的monitor对象的指针。</strong></p><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>重量锁就是传统意义上的锁，在JDK5以及之前，使用的都是这样的锁。重量级锁的状态下，对象的mark word为指向一个堆中monitor对象的指针。</p><p>一个monitor对象包括这么几个关键字段：ContentionList，EntryList ，WaitSet，owner。</p><p>其中ContentionList ，EntryList ，WaitSet都是由ObjectWaiter的链表结构，owner指向持有锁的线程。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/synchronized/synchronize2.jpg" alt="s2"></p><p>每当有一个线程尝试去获得锁的时候，如果该锁已经被占用，重量锁就会讲该线程封装成一个ObjectWaiter对象插入到ContentionList队列的尾部，然后暂停当前线程。然后在锁的持有者释放锁之前，会将ContentionList中的所有元素移动到EntryList中去，并唤醒在EntryList的队首线程。</p><p>如果一个线程在同步块中调用了Object.wait()方法，会将该线程对应的ObjectWaiter从EntryList移除并加入到WaitSet中等待，然后释放锁。当wait的线程被Object.notify()之后，会将对应的ObjectWaiter从WaitSet移动到EntryList中。继续等待持有锁的线程释放锁。</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>JVM的设计者认为，在很多情况下，在运行java程序时，很多同步块的代码可能都不存在所谓的竞争关系，同的线程交替的执行同步块中的代码。这种情况下，用重量级锁是没必要的。因此JVM引入了轻量级锁的概念。</p><p>在线程执行同步块之前，JVM会先在当前的线程的栈帧中创建一个Lock Record，其中包括一个用于存储对象头中的mark word 以及一个指向对象的指针。下图中右边的就是Lock Record：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/synchronized/synchronize3.jpg" alt="s3"></p><h5 id="加锁过程"><a href="#加锁过程" class="headerlink" title="加锁过程"></a>加锁过程</h5><p>1.在线程栈中创建一个Lock Record，将其Object reference字段指向锁对象。</p><p>2.<strong>如果成功使用CAS将对象头重的Mark Word替换为指向锁记录的指针，则获得锁，失败则当前线程尝试使用自旋(循环等待)来获取锁。</strong></p><p>3.如果是当前线程已经持有该锁了，代表这是一次锁重入。设置Lock Record第一部分(Displaced Mark Word)为null，起到了一个重入计数器的作用。然后结束。</p><p>4.走到这一步说明发生了竞争，需要膨胀为重量级锁。</p><h5 id="解锁过程"><a href="#解锁过程" class="headerlink" title="解锁过程"></a>解锁过程</h5><p>1.遍历线程栈,找到所有Object reference字段等于当前锁对象的Lock Record。</p><p>2.如果Lock Record的Displaced Mark Word为null，代表这是一次重入，将Object reference设置为null后继续。</p><p>3.如果Lock Record的Displaced Mark Word不为null，则利用CAS指令将对象头的 Mark Word 恢复成为Displaced Mark Word。如果成功则继续，负责膨胀为重量级锁。</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>Java是支持多线程的语言，因此在很多二方包、基础库中为了保证代码在多线程的情况下也能正常运行，也就是我们常说的线程安全，都会加入如synchronized这样的同步语义。但是在应用在实际运行时，很可能只有一个线程会调用相关同步方法。比如下面这个demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SyncDemo1 syncDemo1 = <span class="keyword">new</span> SyncDemo1();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            syncDemo1.addString(<span class="string">"test:"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        list.add(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个demo中为了保证对list操纵时线程安全，对addString方法加了synchronized的修饰，但实际使用时却只有一个线程调用到该方法，对于轻量级锁而言，每次调用addString时，加锁解锁都有一个CAS操作；对于重量级锁而言，加锁也会有一个或多个CAS操作（这里的’一个‘、’多个‘数量词只是针对该demo，并不适用于所有场景）。</p><p>在JDK1.6中为了<strong>提高一个对象在一段很长的时间内都只被一个线程用做锁对象场景下的性能</strong>，引入了偏向锁，在第一次获得锁时，会有一个CAS操作，之后该线程再获取锁，只会执行几个简单的命令，而不是开销相对较大的CAS命令。我们来看看偏向锁是如何做的。</p><h5 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h5><p>当JVM启用了偏向锁模式（1.6以上默认开启），当新创建一个对象的时候，如果该对象所属的class没有关闭偏向锁模式（什么时候会关闭一个class的偏向模式下文会说，默认所有class的偏向模式都是是开启的），那新创建对象的mark word将是可偏向状态，此时mark word中的thread_id（参见上文偏向状态下的mark word格式）为0，表示未偏向任何线程，也叫做匿名偏向(anonymously biased)。</p><h5 id="加锁过程-1"><a href="#加锁过程-1" class="headerlink" title="加锁过程"></a>加锁过程</h5><p>1.当该对象第一次被线程获得锁的时候，发现是匿名偏向状态，则会用CAS指令，将mark word中的thread id由0改成当前线程ID。如果成功，则代表获得了偏向锁，继续执行同步块中的代码。否则，将偏向锁撤销，升级为轻量级锁。</p><p>2.当被偏向的线程再次进入同步块时，发现锁对象偏向的就是当前线程，在通过一些额外的检查后（细节见后面的文章），会往当前线程的栈中添加一条Displaced Mark Word为空的Lock Record中，然后继续执行同步块的代码，因为操纵的是线程私有的栈，因此不需要用到CAS指令；由此可见偏向锁模式下，当被偏向的线程再次尝试获得锁时，仅仅进行几个简单的操作就可以了，在这种情况下，synchronized关键字带来的性能开销基本可以忽略。</p><p>3.当其他线程进入同步块时，发现已经有偏向的线程了，则会进入到撤销偏向锁的逻辑里，一般来说，会在safepoint中去查看偏向的线程是否还存活，如果存活且还在同步块中则将锁升级为轻量级锁，原偏向的线程继续拥有锁，当前线程则走入到锁升级的逻辑里；如果偏向的线程已经不存活或者不在同步块中，则将对象头的mark word改为无锁状态（unlocked），之后再升级为轻量级锁。</p><p>由此可见，偏向锁升级的时机为：当锁已经发生偏向后，只要有另一个线程尝试获得偏向锁，则该偏向锁就会升级成轻量级锁。当然这个说法不绝对，因为还有批量重偏向这一机制。</p><h5 id="解锁过程-1"><a href="#解锁过程-1" class="headerlink" title="解锁过程"></a>解锁过程</h5><p>当有其他线程尝试获得锁时，是根据遍历偏向线程的lock record来确定该线程是否还在执行同步块中的代码。因此偏向锁的解锁很简单，仅仅将栈中的最近一条lock record的obj字段设置为null。需要注意的是，偏向锁的解锁步骤中并不会修改对象头中的thread id。</p><p>下图展示了锁状态的转换流程：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/synchronized/synchronize4.jpg" alt="s4"></p><p>另外，偏向锁默认不是立即就启动的，在程序启动后，通常有几秒的延迟，可以通过命令 -XX:BiasedLockingStartupDelay=0在虚拟机中来关闭延迟。</p><h5 id="批量重偏向与撤销"><a href="#批量重偏向与撤销" class="headerlink" title="批量重偏向与撤销"></a>批量重偏向与撤销</h5><p>从上文偏向锁的加锁解锁过程中可以看出，当只有一个线程反复进入同步块时，偏向锁带来的性能开销基本可以忽略，但是当有其他线程尝试获得锁时，就需要等到safe point时将偏向锁撤销为无锁状态或升级为轻量级/重量级锁。偏向锁的撤销是有一定成本的，如果说运行时的场景本身存在多线程竞争的，那偏向锁的存在不仅不能提高性能，而且会导致性能下降。因此，JVM中增加了一种批量重偏向/撤销的机制。</p><p>1.一个线程创建了大量对象并执行了初始的同步操作，之后在另一个线程中将这些对象作为锁进行之后的操作。这种case下，会导致大量的偏向锁撤销操作。</p><p>2.存在明显多线程竞争的场景下使用偏向锁是不合适的，例如生产者/消费者队列。</p><p>批量重偏向（bulk rebias）机制是为了解决第一种场景。批量撤销（bulk revoke）则是为了解决第二种场景。</p><p>其做法是：以class为单位，为每个class维护一个偏向锁撤销计数器，每一次该class的对象发生偏向撤销操作时，该计数器+1，当这个值达到重偏向阈值（默认20）时，JVM就认为该class的偏向锁有问题，因此会进行批量重偏向。每个class对象会有一个对应的epoch字段，每个处于偏向锁状态对象的mark word中也有该字段，其初始值为创建该对象时，class中的epoch的值。每次发生批量重偏向时，就将该值+1，同时遍历JVM中所有线程的栈，找到该class所有正处于加锁状态的偏向锁，将其epoch字段改为新值。下次获得锁时，发现当前对象的epoch值和class的epoch不相等，那就算当前已经偏向了其他线程，也不会执行撤销操作，而是直接通过CAS操作将其mark word的Thread Id 改成当前线程Id。</p><p>当达到重偏向阈值后，假设该class计数器继续增长，当其达到批量撤销的阈值后（默认40），JVM就认为该class的使用场景存在多线程竞争，会标记该class为不可偏向，之后，对于该class的锁，直接走轻量级锁的逻辑。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> Synchronized </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（七）Java内存模型</title>
      <link href="/2019/12/22/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%83%EF%BC%89/"/>
      <url>/2019/12/22/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="JAVA内存模型"><a href="#JAVA内存模型" class="headerlink" title="JAVA内存模型"></a>JAVA内存模型</h2><h3 id="JMM内存模型"><a href="#JMM内存模型" class="headerlink" title="JMM内存模型"></a>JMM内存模型</h3><p>我们常说的JVM内存模式指的是JVM的内存分区；而Java内存模式是一种虚拟机规范。</p><p>Java虚拟机规范中定义了Java内存模型（Java Memory Model，JMM），用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果，JMM规范了Java虚拟机与计算机内存是如何协同工作的：规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。</p><p>原始的Java内存模型存在一些不足，因此Java内存模型在Java1.5时被重新修订。这个版本的Java内存模型在Java8中仍然在使用。</p><p>java内存模型（不仅仅是JVM内存分区）：调用栈和本地变量存放在线程栈上，对象存放在堆上。</p><p><img src="https://pic2.zhimg.com/80/v2-bd607bd9a5598a8330ad329033e04b91_hd.jpg" alt=""></p><p><img src="https://pic3.zhimg.com/80/v2-a1a75c9f7264cf78d0927663371ca9d2_hd.jpg" alt=""></p><ul><li>一个本地变量可能是原始类型，在这种情况下，它总是“呆在”线程栈上。</li><li>一个本地变量也可能是指向一个对象的一个引用。在这种情况下，引用（这个本地变量）存放在线程栈上，但是对象本身存放在堆上。</li><li>一个对象可能包含方法，这些方法可能包含本地变量。这些本地变量仍然存放在线程栈上，即使这些方法所属的对象存放在堆上。</li><li>一个对象的成员变量可能随着这个对象自身存放在堆上。不管这个成员变量是原始类型还是引用类型。</li><li>静态成员变量跟随着类定义一起也存放在堆上。</li><li>存放在堆上的对象可以被所有持有对这个对象引用的线程访问。当一个线程可以访问一个对象时，它也可以访问这个对象的成员变量。如果两个线程同时调用同一个对象上的同一个方法，它们将会都访问这个对象的成员变量，但是每一个线程都拥有这个成员变量的私有拷贝。</li></ul><h4 id="硬件内存架构"><a href="#硬件内存架构" class="headerlink" title="硬件内存架构"></a><strong>硬件内存架构</strong></h4><p>现代硬件内存模型与Java内存模型有一些不同，理解内存模型架构以及Java内存模型如何与它协同工作也是非常重要的。</p><p>现代计算机硬件架构的简单图示：</p><p><img src="https://pic1.zhimg.com/80/v2-67833188e191c5e7a11d34e613ca352c_hd.jpg" alt=""></p><ul><li><strong>多CPU</strong>：一个现代计算机通常由两个或者多个CPU。其中一些CPU还有多核。从这一点可以看出，在一个有两个或者多个CPU的现代计算机上同时运行多个线程是可能的。每个CPU在某一时刻运行一个线程是没有问题的。这意味着，如果你的Java程序是多线程的，在你的Java程序中每个CPU上一个线程可能同时（并发）执行。</li><li><strong>CPU寄存器</strong>：每个CPU都包含一系列的寄存器，它们是CPU内内存的基础。CPU在寄存器上执行操作的速度远大于在主存上执行的速度。这是因为CPU访问寄存器的速度远大于主存。</li><li><strong>高速缓存cache</strong>：由于计算机的存储设备与处理器的运算速度之间有着几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。CPU访问缓存层的速度快于访问主存的速度，但通常比访问内部寄存器的速度还要慢一点。每个CPU可能有一个CPU缓存层，一些CPU还有多层缓存。在某一时刻，一个或者多个缓存行（cache lines）可能被读到缓存，一个或者多个缓存行可能再被刷新回主存。</li><li><strong>内存</strong>：一个计算机还包含一个主存。所有的CPU都可以访问主存。主存通常比CPU中的缓存大得多。</li><li><strong>运作原理</strong>：通常情况下，当一个CPU需要读取主存时，它会将主存的部分读到CPU缓存中。它甚至可能将缓存中的部分内容读到它的内部寄存器中，然后在寄存器中执行操作。当CPU需要将结果写回到主存中去时，它会将内部寄存器的值刷新到缓存中，然后在某个时间点将值刷新回主存。</li></ul><p><strong>一些问题：（多线程环境下尤其）</strong></p><ul><li><strong>缓存一致性问题</strong>：在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（MainMemory）。基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也引入了新的问题：缓存一致性（CacheCoherence）。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致的情况，如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI（IllinoisProtocol）、MOSI、Synapse、Firefly及DragonProtocol，等等：</li></ul><p><img src="https://pic1.zhimg.com/80/v2-1a021d2833b7a537dcdfdf0025f52a6c_hd.jpg" alt=""></p><p><strong>指令重排序问题</strong>：为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。因此，如果存在一个计算任务依赖另一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有类似的指令重排序（Instruction Reorder）优化</p><h4 id="Java内存模型和硬件内存架构之间的桥接"><a href="#Java内存模型和硬件内存架构之间的桥接" class="headerlink" title="Java内存模型和硬件内存架构之间的桥接"></a><strong>Java内存模型和硬件内存架构之间的桥接</strong></h4><p>Java内存模型与硬件内存架构之间存在差异。硬件内存架构没有区分线程栈和堆。对于硬件，所有的线程栈和堆都分布在主内存中。部分线程栈和堆可能有时候会出现在CPU缓存中和CPU内部的寄存器中。如下图所示：</p><p><img src="https://pic3.zhimg.com/80/v2-1a7b7bb752799b6c067a0eaca0a1a9b2_hd.jpg" alt=""></p><p>从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：</p><ul><li><p>线程之间的共享变量存储在主内存（Main Memory）中</p></li><li><p>每个线程都有一个私有的本地内存（Local Memory），本地内存是JMM的一个抽象概念，并不真实存在，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。本地内存中存储了该线程以读/写共享变量的拷贝副本。</p></li><li><p>从更低的层次来说，主内存就是硬件的内存，而为了获取更好的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中。</p></li><li><p>Java内存模型中的线程的工作内存（working memory）是cpu的寄存器和高速缓存的抽象描述。而JVM的静态内存储模型（JVM内存模型）只是一种对内存的物理划分而已，它只局限在内存，而且只局限在JVM的内存。</p></li></ul><p><img src="https://pic3.zhimg.com/80/v2-af520d543f0f4f205f822ec3b151ad46_hd.jpg" alt=""></p><h4 id="JMM模型下的线程间通信"><a href="#JMM模型下的线程间通信" class="headerlink" title="JMM模型下的线程间通信"></a>JMM模型下的线程间通信</h4><p>线程间通信必须要经过主内存。</p><p>如下，如果线程A与线程B之间要通信的话，必须要经历下面2个步骤：</p><p>1）线程A把本地内存A中更新过的共享变量刷新到主内存中去。</p><p>2）线程B到主内存中去读取线程A之前已更新过的共享变量。</p><p><img src="https://pic2.zhimg.com/80/v2-8750cb14ecaa93509e3f1981563513e1_hd.jpg" alt=""></p><p>关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：</p><ul><li><strong>lock（锁定）</strong>：作用于主内存的变量，把一个变量标识为一条线程独占状态。</li><li><strong>unlock（解锁）</strong>：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li><strong>read（读取）</strong>：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li><li><strong>load（载入）</strong>：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li><strong>use（使用）</strong>：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li><li><strong>assign（赋值）</strong>：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li><strong>store（存储）</strong>：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</li><li><strong>write（写入）</strong>：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</li></ul><p>Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：</p><ul><li>如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。</li><li>不允许read和load、store和write操作之一单独出现</li><li>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。</li><li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。</li><li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</li><li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现</li><li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值</li><li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</li><li>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。</li></ul><h4 id="Java内存模型解决的问题"><a href="#Java内存模型解决的问题" class="headerlink" title="Java内存模型解决的问题"></a>Java内存模型解决的问题</h4><p>当对象和变量被存放在计算机中各种不同的内存区域中时，就可能会出现一些具体的问题。Java内存模型建立所围绕的问题：在多线程并发过程中，如何处理多线程读同步问题与可见性（多线程缓存与指令重排序）、多线程写同步问题与原子性（多线程竞争race condition）。</p><h5 id="1、多线程读同步与可见性"><a href="#1、多线程读同步与可见性" class="headerlink" title="1、多线程读同步与可见性"></a>1、多线程读同步与可见性</h5><p><strong>可见性（共享对象可见性）</strong>：线程对共享变量修改的可见性。当一个线程修改了共享变量的值，其他线程能够立刻得知这个修改</p><p><strong>线程缓存导致的可见性问题：</strong></p><p>如果两个或者更多的线程在没有正确的使用volatile声明或者同步的情况下共享一个对象，一个线程更新这个共享对象可能对其它线程来说是不可见的：共享对象被初始化在主存中。跑在CPU上的一个线程将这个共享对象读到CPU缓存中，然后修改了这个对象。只要CPU缓存没有被刷新会主存，对象修改后的版本对跑在其它CPU上的线程都是不可见的。这种方式可能导致每个线程拥有这个共享对象的私有拷贝，每个拷贝停留在不同的CPU缓存中。</p><p>下图示意了这种情形。跑在左边CPU的线程拷贝这个共享对象到它的CPU缓存中，然后将count变量的值修改为2。这个修改对跑在右边CPU上的其它线程是不可见的，因为修改后的count的值还没有被刷新回主存中去。</p><p><img src="https://pic2.zhimg.com/80/v2-7abd7500588012315f4f0e068e20e341_hd.jpg" alt=""></p><p>解决这个内存可见性问题你可以使用：</p><ul><li>Java中的volatile关键字：volatile关键字可以保证直接从主存中读取一个变量，如果这个变量被修改后，总是会被写回到主存中去。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此，普通变量与volatile变量的区别是：volatile的特殊规则保证了新值能立即同步到主内存，以及每个线程在每次使用volatile变量前都立即从主内存刷新。因此我们可以说volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。</li><li>Java中的synchronized关键字：同步快的可见性是由“如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值”、“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store和write操作）”这两条规则获得的。</li><li>Java中的final关键字：final关键字的可见性是指，被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那么在其他线程就能看见final字段的值（无须同步）</li></ul><p><strong>重排序导致的可见性问题：</strong></p><p>Java程序中天然的有序性可以总结为一句话：如果在本地线程内观察，所有操作都是有序的（“线程内表现为串行”(Within-Thread As-If-Serial Semantics)）；如果在一个线程中观察另一个线程，所有操作都是无序的（“指令重排序”现象和“线程工作内存与主内存同步延迟”现象）。</p><p>Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性：</p><ul><li>volatile关键字本身就包含了禁止指令重排序的语义</li><li>synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入</li></ul><p><strong>指令序列的重排序：</strong></p><p>1）编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</p><p>2）指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-LevelParallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p><p>3）内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p><p><img src="https://pic1.zhimg.com/80/v2-a92ef160e8ba8d33541fb57b8a32de9c_hd.jpg" alt=""></p><p>每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对写-读操作进行重排序：</p><p><img src="https://pic4.zhimg.com/80/v2-f8a75081bcad888a7e73b4785a672e5b_hd.jpg" alt=""></p><p><strong>数据依赖：</strong></p><p>编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。（这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑）</p><p><img src="https://pic4.zhimg.com/80/v2-36500a7455955c58d02138913d5c0cd7_hd.jpg" alt=""></p><p><strong>指令重排序对内存可见性的影响：</strong></p><p><img src="https://pic4.zhimg.com/80/v2-8ef063a1b514d9cfbdf059984f83ed2f_hd.jpg" alt=""></p><p>当1和2之间没有数据依赖关系时，1和2之间就可能被重排序（3和4类似）。这样的结果就是：读线程B执行4时，不一定能看到写线程A在执行1时对共享变量的修改。</p><p><strong>指令重排序改变多线程程序的执行结果例子：</strong></p><p><img src="https://pic3.zhimg.com/80/v2-111bfd93bcd92fd2ee495a12cb34f9aa_hd.jpg" alt=""></p><p>flag变量是个标记，用来标识变量a是否已被写入。这里假设有两个线程A和B，A首先执行writer()方法，随后B线程接着执行reader()方法。线程B在执行操作4时，能否看到线程A在操作1对共享变量a的写入呢？</p><p>答案是：不一定能看到。</p><p>由于操作1和操作2没有数据依赖关系，编译器和处理器可以对这两个操作重排序；同样，操作3和操作4没有数据依赖关系，编译器和处理器也可以对这两个操作重排序。</p><p><strong>as-if-serial语义：</strong></p><p>不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。（编译器、runtime和处理器都必须遵守as-if-serial语义）</p><p><strong>happens before：</strong></p><p>从JDK 5开始，Java使用新的JSR-133内存模型，JSR-133使用happens-before的概念来阐述操作之间的内存可见性：在JMM中，如果一个操作执行的结果需要对另一个操作可见（两个操作既可以是在一个线程之内，也可以是在不同线程之间），那么这两个操作之间必须要存在happens-before关系：</p><ul><li>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li><li>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li><li>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li><li>传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</li></ul><p>一个happens-before规则对应于一个或多个编译器和处理器重排序规则</p><p><strong>内存屏障禁止特定类型的处理器重排序：</strong></p><p>重排序可能会导致多线程程序出现内存可见性问题。对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障（Memory Barriers，Intel称之为Memory Fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序。通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p><p>为了保证内存可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。</p><p><img src="https://pic2.zhimg.com/80/v2-6db326ce298332a673151117edcb1fcd_hd.jpg" alt=""></p><p>StoreLoad Barriers是一个“全能型”的屏障，它同时具有其他3个屏障的效果。现代的多处理器大多支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（Buffer Fully Flush）。</p><h5 id="2、多线程写同步与原子性"><a href="#2、多线程写同步与原子性" class="headerlink" title="2、多线程写同步与原子性"></a>2、多线程写同步与原子性</h5><p><strong>多线程竞争（Race Conditions）问题</strong>：当读，写和检查共享变量时出现race conditions。</p><p>如果两个或者更多的线程共享一个对象，多个线程在这个共享对象上更新变量，就有可能发生race conditions。</p><p>想象一下，如果线程A读一个共享对象的变量count到它的CPU缓存中。再想象一下，线程B也做了同样的事情，但是往一个不同的CPU缓存中。现在线程A将count加1，线程B也做了同样的事情。现在count已经被增加了两次，每个CPU缓存中一次。如果这些增加操作被顺序的执行，变量count应该被增加两次，然后原值+2被写回到主存中去。然而，两次增加都是在没有适当的同步下并发执行的。无论是线程A还是线程B将count修改后的版本写回到主存中取，修改后的值仅会被原值大1，尽管增加了两次：</p><p><img src="https://pic2.zhimg.com/80/v2-02ae4be429d4b48a18442efe91131155_hd.jpg" alt=""></p><p>解决这个问题可以使用Java同步块。一个同步块可以保证在同一时刻仅有一个线程可以进入代码的临界区。同步块还可以保证代码块中所有被访问的变量将会从主存中读入，当线程退出同步代码块时，所有被更新的变量都会被刷新回主存中去，不管这个变量是否被声明为volatile。</p><p><strong>使用原子性保证多线程写同步问题：</strong></p><p><strong>原子性：</strong>指一个操作是按原子的方式执行的。要么该操作不被执行；要么以原子方式执行，即执行过程中不会被其它线程中断。</p><p><strong>实现原子性：</strong></p><ul><li>由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store、write，我们大致可以认为基本数据类型变量、引用类型变量、声明为volatile的任何类型变量的访问读写是具备原子性的（long和double的非原子性协定：对于64位的数据，如long和double，Java内存模型规范允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这四个操作的原子性，即如果有多个线程共享一个并未声明为volatile的long或double类型的变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读取到一个既非原值，也不是其他线程修改值的代表了“半个变量”的数值。但由于目前各种平台下的商用虚拟机几乎都选择把64位数据的读写操作作为原子操作来对待，因此在编写代码时一般也不需要将用到的long和double变量专门声明为volatile）。这些类型变量的读、写天然具有原子性，但类似于 “基本变量++” / “volatile++” 这种复合操作并没有原子性。</li><li>如果应用场景需要一个更大范围的原子性保证，需要使用同步块技术。Java内存模型提供了lock和unlock操作来满足这种需求。虚拟机提供了字节码指令monitorenter和monitorexist来隐式地使用这两个操作，这两个字节码指令反映到Java代码中就是同步快——synchronized关键字。</li></ul><h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><p>通常在进行并发编程的时候，我们总会遇到一些数据不一致的问题，接下，就这一问题开始讨论和解决。如一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span>  <span class="title">test1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"="</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> test1());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> test1());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一次</span></span><br><span class="line">=<span class="number">13118</span></span><br><span class="line">=<span class="number">13921</span></span><br><span class="line"><span class="comment">//第二次</span></span><br><span class="line">=<span class="number">10937</span></span><br><span class="line">=<span class="number">10937</span></span><br></pre></td></tr></table></figure><p>我们发现无论怎么运行都差不多是这两种情况，要么两个数字都不一样，要么两个数字一样但都不是20000，这是什么情况呢？我想，第一种是因为两个线程在不断的使用i的过程中，某一个线程先完成了计算，还有一个线程仍在继续着循环，导致两次数字不一样，且第一次数字都小于第二次，第二种情况是两个线程交替执行，导致最后虽然同时完成，但是仍然损失了很多数字。</p><p>那么好，我们试着将两个变量都设置为volatile关键字试试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">=<span class="number">13144</span></span><br><span class="line">=<span class="number">13144</span></span><br></pre></td></tr></table></figure><p>发现它们仅仅是变得一样而已，并没有出现其20000的数字。</p><p>最后在设置为synchronize试试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//此时volatile可加可不加</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i=<span class="number">0</span>;<span class="comment">//此时volatile可加可不加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span>  <span class="title">test1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> test instance=<span class="keyword">new</span> test();</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (instance) &#123;</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"="</span> + count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> test1());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> test1());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">=<span class="number">10000</span></span><br><span class="line">=<span class="number">20000</span></span><br></pre></td></tr></table></figure><p>看，设置成了synchronize之后就没有了数据的损失，完全就变成了一个接着一个运行的机制，这样就输出了正确的数值。但是，我想要两个都为20000，这样怎么改造呢?想到线程之间协同关系，当然是要用之前讲过的wait()方法和notify()方法啦，这里先不说，大家想一想把。</p><p>接下来，可能会有人觉得奇怪，为什么声明了volatile还是会出现损失呢？，volatile的原理是什么呢？这里先简单讲一下，为什么这个例子没有保证它的原子性。那是因为，Volatile并不能保证count++的原子性，count++在执行的时候，实际上是完成了：读取—修改—写入。这三个操作，在多个线程进行读取和修改的时候，可能会遇到这种状况：</p><ol><li>线程A读取到count=1；</li><li>线程B读取到count=1；</li><li>线程A复制一个副本修改i的值为2；</li><li>线程B复制一个副本修改i的值为2；</li><li>线程A写回i；</li><li>线程B发现i的值已经为2，放弃写入；</li></ol><p>其实当我们进行到步骤2的时候，Volatile就已经无法保证i的原子性了，可以看到，如果线程A和线程B几乎同时读取到i的值为1，而不是线程A先于线程B读取修改并写入count的话，那么就已经无法保证i的原子性了，因为Volatile关键字并没有对count进行加锁，虽然声明了Volatile，会让count只会被一个单位所修改，但是在读取这个操作中，其实是不加以限制的。</p><p>volatile具有可见性和有序性，并不具备原子性，volatile只能确保一个线程修改了数据之后，另一个线程能够看到这个改动，当两个线程同时修改一个数据时，仍然会产生冲突。</p><h4 id="Volatile不能保证原子性"><a href="#Volatile不能保证原子性" class="headerlink" title="Volatile不能保证原子性"></a>Volatile不能保证原子性</h4><p>我们的所有的代码，实际运行的空间其实是在Java虚拟机当中，而Java虚拟机中的Java堆，使用的就是计算的内存。CPU在读取一个值的时候，初次是需要从主内存中读取，读取到缓存中来，之后只要每次读取都会从缓存当中读取值，直到缓存时间过期或者是缓存地址被修改，才会重新去主存中读取值。</p><p>volatile声明了一个对象后，将那个对象转为汇编代码，可以发现那个对象的已经加了lock前缀去处理。它会在主存和CPU之间中使用缓存一致性协议，此刻的主存会在CPU的每一个缓存中使用嗅探器去嗅探自己的缓存是否过期了，当发现自己的缓存被修改了，就会使在缓存的对象无效化，让在缓存中的对象重新去主存读取新的值。</p><p>下面就以一张图去表述吧：</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/volatileyuanli.png" alt="volatile"></p><p>而在修改了被声明为volatile的对象后，该缓存就会通过嗅探器得知，然后去通知其他的缓存，lock#信号就会锁住其他的缓存，不让它被读取，然后将该CPU的缓存中所修改的值，写回主存中去，其他缓存需要从主存中获取到新值后才能解锁。</p><p>讲到这里，为什么还是不能保证原子性呢？我们再次拿出上面讲的例子来：</p><p>当 i=1 的时候A,B两个线程同时读入了 i 的值， 然后A线程执行了 temp = i + 1的操作， 要注意，此时的 i 的值还没有变化，然后B线程也执行了 temp = i + 1的操作，注意，此时A，B两个线程保存的 i 的值都是1，temp 的值都是2， 然后A线程执行了 i = temp （2）的操作，此时i的值会立即刷新到主存并通知其他线程保存的 i 值失效， 此时B线程需要重新读取 i 的值那么此时B线程保存的 i 就是2，同时B线程保存的 temp 还仍然是2， 然后B线程执行 i=temp （2），然后B线程就以为自己已经成功读取到了新的值，这样下来，就损失了一个1。</p><h4 id="锁缓存还是锁总线"><a href="#锁缓存还是锁总线" class="headerlink" title="锁缓存还是锁总线"></a>锁缓存还是锁总线</h4><p>前面讲到，volatile会锁住全部缓存，使得它们必须更新新的值。除此之外，volatile还可以选择锁住总线，让该cpu暂时独占整个内存，完成所需操作。但是一般都不会去使用锁总线的方式，因为锁总线的开销实在是太大了，但有时候却不得不去锁总线，一是当前操作的数据跨越了多个缓存行，只能使用总线锁，二是设备不支持(现在很少)。默认情况下，Lock前缀都是通过锁缓存来保证一致性的。</p><h4 id="volatile-可见性实现"><a href="#volatile-可见性实现" class="headerlink" title="volatile 可见性实现"></a>volatile 可见性实现</h4><p>volatile 变量的内存可见性是基于内存屏障（Memory Barrier）实现。</p><p>内存屏障，又称内存栅栏，是一个 CPU 指令。<br>在程序运行时，为了提高执行性能，编译器和处理器会对指令进行重排序，JMM 为了保证在不同的编译器和 CPU 上有相同的结果，通过插入特定类型的内存屏障来禁止特定类型的编译器重排序和处理器重排序，插入一条内存屏障会告诉编译器和 CPU：不管什么指令都不能和这条 Memory Barrier 指令重排序。</p><h4 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h4><p>缓存是分段（line）的，一个段对应一块存储空间，称之为缓存行，它是 CPU 缓存中可分配的最小存储单元，大小 32 字节、64 字节、128 字节不等，这与 CPU 架构有关，通常来说是 64 字节。</p><ul><li>为了使其行为看起来如同一组缓存那样。因而设计了 缓存一致性协议。</li><li>缓存一致性协议有多种，但是日常处理的大多数计算机设备都属于 “ 嗅探（snooping）” 协议。</li><li>所有内存的传输都发生在一条共享的总线上，而所有的处理器都能看到这条总线。</li><li>缓存本身是独立的，但是内存是共享资源，所有的内存访问都要经过仲裁（同一个指令周期中，只有一个 CPU 缓存可以读写内存）。</li><li>CPU 缓存不仅仅在做内存传输的时候才与总线打交道，而是不停在嗅探总线上发生的数据交换，跟踪其他缓存在做什么。</li><li>当一个缓存代表它所属的处理器去读写内存时，其它处理器都会得到通知，它们以此来使自己的缓存保持同步。</li><li>只要某个处理器写内存，其它处理器马上知道这块内存在它们的缓存段中已经失效。</li></ul><h4 id="禁止重排序"><a href="#禁止重排序" class="headerlink" title="禁止重排序"></a>禁止重排序</h4><p>为了性能优化，JMM 在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序。JMM 提供了内存屏障阻止这种重排序。</p><p>Java 编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。</p><p>JMM 会针对编译器制定 volatile 重排序规则表。</p><p><img src="https://upload-images.jianshu.io/upload_images/5714666-390c861ed043ef94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt=""></p><p>“ NO “ 表示禁止重排序。</p><ul><li>为了实现 volatile 内存语义时，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</li><li>对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎是不可能的，为此，JMM 采取了保守的策略。<ul><li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障。</li><li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障。</li></ul></li></ul><p>volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障。</p><table><thead><tr><th>内存屏障</th><th>说明</th></tr></thead><tbody><tr><td>StoreStore 屏障</td><td>禁止上面的普通写和下面的 volatile 写重排序。</td></tr><tr><td>StoreLoad 屏障</td><td>防止上面的 volatile 写与下面可能有的 volatile 读/写重排序。</td></tr><tr><td>LoadLoad 屏障</td><td>禁止下面所有的普通读操作和上面的 volatile 读重排序。</td></tr><tr><td>LoadStore 屏障</td><td>禁止下面所有的普通写操作和上面的 volatile 读重排序。</td></tr></tbody></table><p><img src="https://upload-images.jianshu.io/upload_images/5714666-42b7250449160dc2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/747/format/webp" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5714666-cce9ccf139acf1a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/801/format/webp" alt=""></p><h3 id="happens-before-关系"><a href="#happens-before-关系" class="headerlink" title="happens-before 关系"></a>happens-before 关系</h3><p>我们无法就所有场景来规定某个线程修改的变量何时对其他线程可见，但是我们可以指定某些规则，这规则就是happens-before，从JDK 5 开始，JMM就使用happens-before的概念来阐述多线程之间的内存可见性。</p><p><strong>在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。</strong></p><p>happens-before原则非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们解决在并发环境下两操作之间是否可能存在冲突的所有问题。下面我们就一个简单的例子稍微了解下happens-before ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设线程A执行writer方法，线程B执行reader方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;              <span class="comment">// 1 线程A修改共享变量</span></span><br><span class="line">        flag = <span class="keyword">true</span>;        <span class="comment">// 2 线程A写volatile变量</span></span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;         <span class="comment">// 3 线程B读同一个volatile变量</span></span><br><span class="line">        <span class="keyword">int</span> i = a;          <span class="comment">// 4 线程B读共享变量</span></span><br><span class="line">        ……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 happens-before 规则，上面过程会建立 3 类 happens-before 关系。</p><ul><li>根据程序次序规则：1 happens-before 2 且 3 happens-before 4。</li><li>根据 volatile 规则：2 happens-before 3。</li><li>根据 happens-before 的传递性规则：1 happens-before 4。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5714666-04e61c5e5c4e91c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/587/format/webp" alt=""></p><p>因为以上规则，当线程 A 将 volatile 变量 flag 更改为 true 后，线程 B 能够迅速感知。</p><p>happens-before原则定义如下：</p><p><strong>1. 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</strong><br><strong>2. 两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。</strong></p><p>下面是happens-before原则规则：</p><ol><li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</li><li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作；</li><li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；</li><li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</li><li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；</li><li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</li><li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</li><li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；</li></ol><p>我们来详细看看上面每条规则：</p><p><strong>程序次序规则</strong>：一段代码在单线程中执行的结果是有序的。注意是执行结果，因为虚拟机、处理器会对指令进行重排序（重排序后面会详细介绍）。虽然重排序了，但是并不会影响程序的执行结果，所以程序最终执行的结果与顺序执行的结果是一致的。故而这个规则只对单线程有效，在多线程环境下无法保证正确性。</p><p><strong>锁定规则</strong>：这个规则比较好理解，无论是在单线程环境还是多线程环境，一个锁处于被锁定状态，那么必须先执行unlock操作后面才能进行lock操作。</p><p><strong>volatile变量规则</strong>：这是一条比较重要的规则，它标志着volatile保证了线程可见性。通俗点讲就是如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作一定是happens-before读操作的。</p><p><strong>传递规则</strong>：提现了happens-before原则具有传递性，即A happens-before B , B happens-before C，那么A happens-before C</p><p><strong>线程启动规则</strong>：假定线程A在执行过程中，通过执行ThreadB.start()来启动线程B，那么线程A对共享变量的修改在接下来线程B开始执行后确保对线程B可见。</p><p><strong>线程终结规则</strong>：假定线程A在执行的过程中，通过制定ThreadB.join()等待线程B终止，那么线程B在终止之前对共享变量的修改在线程A等待返回后可见。</p><p>上面八条是原生Java满足Happens-before关系的规则，但是我们可以对他们进行推导出其他满足happens-before的规则：</p><ol><li>将一个元素放入一个线程安全的队列的操作Happens-Before从队列中取出这个元素的操作</li><li>将一个元素放入一个线程安全容器的操作Happens-Before从容器中取出这个元素的操作</li><li>在CountDownLatch上的倒数操作Happens-Before CountDownLatch#await()操作</li><li>释放Semaphore许可的操作Happens-Before获得许可操作</li><li>Future表示的任务的所有操作Happens-Before Future#get()操作</li><li>向Executor提交一个Runnable或Callable的操作Happens-Before任务开始执行操作</li></ol><p>这里再说一遍happens-before的概念：<strong>如果两个操作不存在上述（前面8条 + 后面6条）任一一个happens-before规则，那么这两个操作就没有顺序的保障，JVM可以对这两个操作进行重排序。如果操作A happens-before操作B，那么操作A在内存上所做的操作对操作B都是可见的。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> Volatile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（六）隐蔽的错误</title>
      <link href="/2019/12/22/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%85%AD%EF%BC%89/"/>
      <url>/2019/12/22/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="隐蔽的错误"><a href="#隐蔽的错误" class="headerlink" title="隐蔽的错误"></a>隐蔽的错误</h3><p>在编程当中遇到错误，可能会让你头疼，但能提示出是哪里出现了某某错误，也许只是一两分钟就能解决的问题，最可怕的是，程序出错了，却没有任何提示，得自己慢慢的去找，在几十万行代码的工程当中，可能分分钟就猝死了。所以，写任何代码时，都要想一想各种会出现的问题，最简单的不可见错误如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> v1=<span class="number">1073741827</span>;</span><br><span class="line"><span class="keyword">int</span> v2=<span class="number">1431655768</span>;</span><br><span class="line"><span class="keyword">int</span> a=v1+v2;</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure><p>程序不会提示出你的代码错误，甚至可以说，从逻辑上而言完全没有错误，但隐藏的错误就是，值溢出了，这会使最后的结果出现了错误。</p><p>并且，在并行开发中，这样的隐藏错误还会有更多更多。</p><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>ArrayList在java中是一个经常被使用的容器。它的就相当于一个可以存放任何类型的、自动扩容的数组。我们看看下面这段代码，看它为什么线程不安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;Integer&gt; a=<span class="keyword">new</span> ArrayList&lt;Integer&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> test());</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> test());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(a.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Exception in thread <span class="string">"Thread-1"</span> java.lang.ArrayIndexOutOfBoundsException: <span class="number">10</span></span><br><span class="line">at java.util.ArrayList.add(ArrayList.java:<span class="number">463</span>)</span><br><span class="line">at test.run(test.java:<span class="number">19</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"><span class="number">100009</span></span><br></pre></td></tr></table></figure><p>第一种情况，就是如上所述，数组越界的错误，我们看看为什么会数组越界，首先这个越界发生在add这个方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>此时，t1线程和t2线程同时对ArrayList进行扩容：<br>t1发现list为10，不够存放，需要扩容到11，调用ensureCapacityInterna进行判断</li><li>t2发现list为10，不够存放，需要扩容到11，也调用ensureCapacityInterna进行判断</li><li>t1发现扩容后大小为11，可以容纳，不再扩容，返回</li><li>t2也发现扩容后大小为11，可以容纳，直接返回（这里的t2的判断容量的过程恰好在t1刚扩容完后）</li><li>t1开始进行设置值操作， elementData[size++] = e 操作。此时size变为11</li><li>t2也开始进行设置值操作，它尝试设置elementData[11] = e，而elementData没有进行过扩容，它的下标最大为10。于是此时会报出一个数组越界的异常ArrayIndexOutOfBoundsException</li></ol><p>于是乎，错误就这么诞生了，所以ArrayList线程不安全，可以使用vector代替，而vector之所以线程安全，那是因为它在扩容过程中使用了synchronize进行加锁，ArrayList代表效率，vector代表安全，看各种情况去使用它们。</p><p>第二种情况，它运气极好，没有发生冲突，恰好为200000。</p><p>第三种情况，183274，这种情况是一种非常隐蔽的错误，它既没有显式的表达出错误，也没有计算正确，这是因为两个线程同时对i进行赋值，导致的错误，这种错误不是属于逻辑上的错误，所以不会直接的表达，而是直接的被略过。</p><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><h5 id="HashMap的原理"><a href="#HashMap的原理" class="headerlink" title="HashMap的原理"></a>HashMap的原理</h5><p>HashMap是一个非常之重要的容器，几乎每一个互联网公司的面试都会问及HashMap的实现和原理，hashmap首先是一个可扩容的数组，然后每个数组底下可以存放多个内容，被存放的内容就像链表一样，一个接着一个，在一个数组存放的链表大于8个的时候，链表就会转化为红黑树的数据结构,这里先简要概述HashMap的原理</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/hashmap.png" alt="hashmap"></p><p>hashmap的设计可以说非常的及精妙，它结合了数组和链表的特点，数组是寻址容易，修改和插入困难，而链表反之，hashmap不仅仅寻址容易，插入和删除也容易。所以，hashmap可以看成是一个带有链表的数组，它的使用方法和图一样，一个key值，一个value值。</p><p>我们先看看hashmap的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//看看DEFAULT_LOAD_FACTOR</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure><p>这里写出了，hashmap的构造和扩容的机制，在构造的时候设置了负载因子0.75，以用来在hashmap的元素在达到其四分之三的时候，便会自发的发生扩容，为什么必须是0.75的时候呢，在这里，设计者给出了一个解释 nodes in bins follows a Poisson distribution。什么是poisson分布呢，用通俗的语言来说，世界上的概率都是可以通过计算得来的，比如硬币的概率是二分之一，但是若要涉及的各种各样的因素，比如风力，重力，地球的自转，或许就会与实际相差那么一点点，于是可以把概率分成有大数据支持的概率（正态分布），没大数据支持的概率（二项式分布），现实生活中的概率（poisson分布）。使用poisson分布在hashmap中，是为了减少hash冲突（又称碰撞）。</p><p>什么是哈希冲突？哈希冲突是指哈希码被放入到hashmap的时候发生的重叠，也可以看作为：两个不同的输入值，根据同一散列函数计算出的散列值相同的现象叫做碰撞。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">t.put(<span class="number">17</span>,<span class="string">"you"</span>);</span><br><span class="line"><span class="comment">//将key和value加入map，下面看看put的内容</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//put加入的值，除了本身之外，还有一个hash的函数，这个就是hash码了，我们看看是怎么将key值转为hash码的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//可以看到如果key值不为空，就将key值赋给一个int型变量h，h再与h右移16位(二进制位移)进行异或操作，该方法主要是将Object转换成一个整型。</span></span><br><span class="line"><span class="comment">//通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的。以上方法得到的int的hash值，然后再通过h &amp; (table.length -1)来得到该对象在数据中保存的位置。</span></span><br><span class="line"><span class="comment">//&gt;&gt;&gt;    :     无符号右移，忽略符号位，空位都以0补齐</span></span><br></pre></td></tr></table></figure><p>再回来看看put函数返回的putval函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="comment">// 如果存储元素的table为空，则进行必要字段的初始化</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;    <span class="comment">// 获取长度（16）</span></span><br><span class="line">        <span class="comment">// 如果根据hash值获取的结点为空，则新建一个结点</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)      <span class="comment">// 此处 &amp; 代替了 % （除法散列法进行散列）</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 这里的p结点是根据hash值算出来对应在数组中的元素</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">// 如果新插入的结点和table中p结点的hash值，key值相同的话</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">// 如果是红黑树结点的话，进行红黑树插入</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">// 代表这个单链表只有一个头部结点，则直接新建一个结点即可</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">// 链表长度大于8时，将链表转红黑树</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 及时更新p</span></span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果存在这个映射就覆盖</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="comment">// 判断是否允许覆盖，并且value是否为空</span></span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);     <span class="comment">// 回调以允许LinkedHashMap后置操作</span></span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;     <span class="comment">// 更改操作次数</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)     <span class="comment">// 大于临界值</span></span><br><span class="line">            <span class="comment">// 将数组大小设置为原来的2倍，并将原先的数组中的元素放到新数组中</span></span><br><span class="line">            <span class="comment">// 因为有链表，红黑树之类，因此还要调整他们</span></span><br><span class="line">            resize();  </span><br><span class="line">        <span class="comment">// 回调以允许LinkedHashMap后置操作</span></span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>总结为是通过hash(key)%len的方式，将hashcode其存放在hashmap当中，于是put里的key值17就变成了hashcode：1</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/hashcode.png" alt="hashcode"></p><p>而且，hashmap虽然在构造的时候,可以传入任意参数但其实，无论传入什么参数，最后都会变成2的次幂。</p><p>长度16或者其他2的幂，Length-1的值是所有二进制位全为1，这种情况下，index的结果等同于hashcode后几位的值。只要输入的hashcode本身分布均匀，Hash算法的结果就是均匀的。所以，hashmap中的&amp;位必须为奇数（Length - 1）</p><p>因为2的次幂可以很好的去减少hash碰撞,并且呢，虽然我们说hashcode其实是对容量取余获得的，但是由于取余这个方法在计算中并不是那么有效率，所以实际上还是通过位运算的方式去取得余，不过我们可以概念性的看作为取余，方便运算，并且位运算还有一个好处就是，可以解决负数的问题。</p><p>为什么可以使用位运算(&amp;)来实现取模运算(%)呢？这实现的原理如下：</p><ul><li>X % 2^n = X &amp; (2^n – 1)</li><li>2^n表示2的n次方，也就是说，一个数对2^n取模 == 一个数和(2^n – 1)做按位与运算 。</li><li>假设n为3，则2^3 = 8，表示成2进制就是1000。2^3 -1 = 7 ，即0111。</li><li>此时X &amp; (2^3 – 1) 就相当于取X的2进制的最后三位数。</li><li>从2进制角度来看，X / 8相当于 X &gt;&gt; 3，即把X右移3位，此时得到了X / 8的商，而被移掉的部分(后三位)，则是X % 8，也就是余数。</li></ul><p>而通常解决hash碰撞有这几种方法：</p><ul><li>开放定址法：<ul><li>开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。</li></ul></li><li>链地址法<ul><li>将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。</li></ul></li><li>再哈希法<ul><li>当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。</li></ul></li><li>建立公共溢出区<ul><li>将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。</li></ul></li></ul><h5 id="为什么HashMap线程不安全"><a href="#为什么HashMap线程不安全" class="headerlink" title="为什么HashMap线程不安全"></a>为什么HashMap线程不安全</h5><p>我们先来看一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String,String&gt; map=<span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">addthread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">addthread</span><span class="params">(<span class="keyword">int</span> object)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start=object;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;<span class="number">100000</span> ; i+=<span class="number">2</span>) &#123;</span><br><span class="line">                map.put(Integer.toString(i),Integer.toBinaryString(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> addthread(<span class="number">0</span>));</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> addthread(<span class="number">1</span>));</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(map.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码和ArrayList非常类似，也会出现三种情况</p><p>第一种情况就是运行结果为100000，也就是运气极佳，完美运行，但这种情况很少</p><p>第二种情况就是有结果，但结果少于100000，这是因为访问时出现了数据的不一致</p><p>但更多的是第三种情况，出现了程序一直在运行，无限循环的情况，为什么会出现这种情况呢，想必大家第一时间能想的到是因为put方法，对，没错，不同ArrayList的数组越界错误，hashmap出现了死循环</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/hashmapdead.jpg" alt="死循环"></p><p>hashmap扩容的时候，会出现链表互为对方的next的情况，从而导致一个死循环</p><p>不过jdk1.8之后，已经不存在这个问题了（jdk1.7及以下仍然存在），即使这样，hashmap在多线程中也要谨慎使用，最好的方法是使用concurrenthashmap去代替hashmap</p><h4 id="错误的加锁"><a href="#错误的加锁" class="headerlink" title="错误的加锁"></a>错误的加锁</h4><p>这里要提到一个新的观点，被synchronize包围的对象，就一定能保持原子性吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> test instance=<span class="keyword">new</span> test();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1= <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2= <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;<span class="number">100000</span> ; j++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (i)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，这是一个比较简单的事例，一个计数器，最后算出结果，我们从表面上看，这个列子完全没有问题，所用的对象i也完全被包围，那么我们看一下结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">153039</span></span><br></pre></td></tr></table></figure><p>这并不等于200000。很可能是在读写的过程中发生了数据不一致的错误。这是为什么呢？我们来看看Integer的实现。</p><p>我们发现了Integer的增长过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，valueof实际上是一个工厂方法，它会返回一个指定数值的Integer实例，因此这里的i++本质上是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i=Integer.valueOf(i.intValue()+<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>因为在多个线程之间，i在不断地变动，所以我们锁住的Integer都是过去的Integer，想要修正这个问题，也很简单，只要把synchronize那一部分变成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (instance)&#123;</span><br><span class="line">                i++; &#125;</span><br></pre></td></tr></table></figure><p>这样锁住的部分就变成了该线程本身。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（五）线程的管理</title>
      <link href="/2019/12/21/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2019/12/21/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="线程的管理"><a href="#线程的管理" class="headerlink" title="线程的管理"></a>线程的管理</h3><p>当我们在一个系统中使用了非常之多的线程的时候，就非常不方便去管理，于是乎，设计者便设计了一个名为线程组的类，去好好的管理线程。线程组类的名字叫做ThreadGroup</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ThreadGroup tg=<span class="keyword">new</span> ThreadGroup(<span class="string">"printGroup"</span>);</span><br><span class="line"><span class="comment">//创建线程组</span></span><br><span class="line">Thread t1=<span class="keyword">new</span> Thread(tg,<span class="string">"T1"</span>);</span><br><span class="line">Thread t2=<span class="keyword">new</span> Thread(tg,<span class="string">"T2"</span>);</span><br><span class="line"><span class="comment">//线程加入线程组</span></span><br></pre></td></tr></table></figure><p>我们看看这个thread的构造函数和别的有什么不同吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(ThreadGroup group, Runnable target, String name)</span> </span>&#123;</span><br><span class="line">        init(group, target, name, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里第一个要传入的参数叫ThreadGroup类，第三个叫名字，表示这个线程属于什么什么线程组，什么什么名字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tg.activeCount()</span><br><span class="line"><span class="comment">//可以获得活动中的总线程数，但是活动中的线程数只是一个估计值，无法精确</span></span><br><span class="line">tg.list();</span><br><span class="line"><span class="comment">//而list方法则可以打印出所有的线程信息</span></span><br></pre></td></tr></table></figure><p>最后运行一段程序看看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ThreadGroup tg=<span class="keyword">new</span> ThreadGroup(<span class="string">"printGroup"</span>);</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(tg,<span class="keyword">new</span> test(),<span class="string">"T1"</span>);</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(tg,<span class="keyword">new</span> test(),<span class="string">"T2"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        System.out.println(tg.activeCount());</span><br><span class="line">        tg.list();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String group=Thread.currentThread().getThreadGroup().getName()+<span class="string">"-"</span>+Thread.currentThread().getName();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">"i am "</span>+group);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span></span><br><span class="line">i am printGroup-T1</span><br><span class="line">i am printGroup-T2</span><br><span class="line">java.lang.ThreadGroup[name=printGroup,maxpri=<span class="number">10</span>]</span><br><span class="line">    Thread[T1,<span class="number">5</span>,printGroup]</span><br><span class="line">    Thread[T2,<span class="number">5</span>,printGroup]</span><br></pre></td></tr></table></figure><h3 id="线程的后台"><a href="#线程的后台" class="headerlink" title="线程的后台"></a>线程的后台</h3><p>这里的后台不是指靠山的意思，就是单纯的后台，每个活动都会有后台，很多次要的事物，都是在幕后运行的。比如一家饭馆，等客人就是主场，服务员就是后台，等主场人走光了，后台也就不必继续服务了，这里说线程的后台，就是指的这个意思。有些主线程在不断的消耗资源进行运算，而后台线程则负责资源垃圾的回收，等主线程结束以后，后台线程便会自然结束。</p><p>设置后台线程的方法很简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread t1= <span class="keyword">new</span> Thread(<span class="keyword">new</span> test());</span><br><span class="line">        t1.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"><span class="comment">//注意不能够颠倒次序，必须先setdaemon，才能start</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> test1());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> test2());</span><br><span class="line">        t1.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;<span class="comment">//一直在运行</span></span><br><span class="line">                System.out.println(<span class="string">"i am alive"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">test2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);<span class="comment">//等待5秒结束</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i am alive</span><br><span class="line">i am alive</span><br><span class="line">i am alive</span><br><span class="line">i am alive</span><br><span class="line">i am alive</span><br></pre></td></tr></table></figure><p>如上述代码块所示，线程便会在运行后，开始寻找主线程，等待主线程，如果发现没有主线程，或主线程已经结束，只有后台线程才存活，便会结束线程。</p><h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>从上面可以看到，线程与线程之间存在着主次关系，那么主线程与主线程之间也有高低之分吗？答案是有的。为了更好的完成线程之间的调度问题，必然有方法也可以控制着线程的优先级，最常用的方式就是主动的去设置线程的优先级setPriority（）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span> </span>&#123;</span><br><span class="line">        ThreadGroup g;</span><br><span class="line">        checkAccess();</span><br><span class="line">        <span class="keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((g = getThreadGroup()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">                newPriority = g.getMaxPriority();</span><br><span class="line">            &#125;</span><br><span class="line">            setPriority0(priority = newPriority);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在这个方法中传入一个数字，代表着线程的优先级，优先级更高的线程便拥有着更高的资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">high</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (test<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span> (count&gt;<span class="number">10000</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"high is win"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;&#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">low</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (test<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="keyword">if</span> (count&gt;<span class="number">10000</span>)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"low is win"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;&#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1= <span class="keyword">new</span> Thread(<span class="keyword">new</span> high());</span><br><span class="line">        Thread t2= <span class="keyword">new</span> Thread(<span class="keyword">new</span> low());</span><br><span class="line">        t1.setPriority(<span class="number">10</span>);<span class="comment">//设置优先级</span></span><br><span class="line">        t2.setPriority(<span class="number">1</span>);<span class="comment">//设置优先级</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">high is win</span><br><span class="line">low is win</span><br></pre></td></tr></table></figure><p>但我们常说事无绝对，哪怕是再冰冷的机器也是如此，设置优先级并不代表一定会优先获得，只不过是获得的概率比较大而已，再多试试几次，也会有低优先级的线程先执行完的时候。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（四）线程的基本使用2</title>
      <link href="/2019/12/19/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2019/12/19/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="Thread类的基本使用（二）"><a href="#Thread类的基本使用（二）" class="headerlink" title="Thread类的基本使用（二）"></a>Thread类的基本使用（二）</h3><h4 id="线程的join（等待线程结束）和yield（谦让线程）"><a href="#线程的join（等待线程结束）和yield（谦让线程）" class="headerlink" title="线程的join（等待线程结束）和yield（谦让线程）"></a>线程的join（等待线程结束）和yield（谦让线程）</h4><p>线程的join方法的意思是，如果有对象在该线程中执行，但是又有别的线程要调用这个对象，join方法会让别的线程阻塞，直到该线程执行完毕为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        test r = <span class="keyword">new</span> test();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t.start();</span><br><span class="line">        t.join();<span class="comment">//如果没有，打印出来的就会为0</span></span><br><span class="line">        System.out.println(<span class="string">"i="</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>;  i&lt;<span class="number">10000</span> ; i++) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//i=10000</span></span><br></pre></td></tr></table></figure><p>这里可以看到的是，t线程一直在执行run方法，如果此时没有join方法的话，就直接执行了之后的print方法，这样打印出来的数值就是0因为join方法阻塞了主线程调用print方法去打印i。</p><p>再看看join的内部构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    join(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个内部表示可以向join传入一个参数，表示等待的时间，看看我们传入了100ms之后，会出现什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        test r = <span class="keyword">new</span> test();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t.start();</span><br><span class="line">        t.join(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">"i="</span>+i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>;  i&lt;<span class="number">1000000000</span> ; i++) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//i=155033164</span></span><br></pre></td></tr></table></figure><p>看，线程t在100ms后便不再阻塞主线程，任由其打印了。</p><p>那么再看看源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取重点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">              wait(<span class="number">0</span>);</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><p>这个while循环会一直判断，是否一直存活，若存活则一直继续，若不为存活，则直接跳出循环并使用wait(delay)方法，它会传入参数，在调用notifyAll()方法，唤醒全部线程。</p><p>线程谦让：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>线程谦让表示该线程愿意让出CPU资源，给其他线程去调用，但这并不表示该线程就不执行了，它仅仅是表明了，“我愿意让出这个资源，大家再度公平竞争”，这通常会在某些运算中运用到，比如有一个线程调用了大量的cpu资源去给线程a运算一个一千万循环的for语句，和一百循环的for语句，这样相比cpu会给极大的资源给线程a运算第一个for，但当其运算完成后，第二个for想必不用调用这么多cpu资源去运算，那么便可以使用线程谦让，使得它们再次平衡下来。</p><h4 id="线程的suspend（线程挂起）和resume（继续执行）"><a href="#线程的suspend（线程挂起）和resume（继续执行）" class="headerlink" title="线程的suspend（线程挂起）和resume（继续执行）"></a>线程的suspend（线程挂起）和resume（继续执行）</h4><p>线程的suspend方法和resume方法早已被废弃，不过这里还是简单讲一下：</p><p>线程挂起的意思就是将当前的线程阻塞，不让其继续使用，等待线程收到resume命令之后才会继续执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> t.start();</span><br><span class="line">        t.suspend();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        i=<span class="number">1</span>;</span><br><span class="line">        t.resume();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"ok!!!"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>但是这样方法在某些情况的使用是致命的，因为被挂起的线程是不会释放任何资源的，如果线程此时被上了锁，那将会有非常多的线程去等待一个线程释放资源，从而导致长时间的阻塞，而且，在另一个线程去调用resume的同时，你也不能确定resume方法一定会在suspend之后执行，因为在并行计算中，这一切不一定完全有序，这样会导致死锁的产生，所以这两个方法被废弃了。</p><p>那有什么可以代替的呢？</p><h4 id="线程的wait（等待）和notify（通知）"><a href="#线程的wait（等待）和notify（通知）" class="headerlink" title="线程的wait（等待）和notify（通知）"></a>线程的wait（等待）和notify（通知）</h4><p>这里可以引入到两个新的方法wait和notify，wait方法和suspend方法一样，会让线程阻塞，然后等待通知了才会继续。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        timeout++;</span><br><span class="line">    &#125;</span><br><span class="line">    wait(timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是注意，wait方法的使用是被锁包围的，首先wait在执行之前会被锁给锁住，不让其它线程获取本线程(线程a)的对象资源，而使用了wait后，他会自动且暂时的释放当前的锁，然后阻塞该线程，等待需要访问该对象的线程b获得对象锁，再使用notify方法后，执行完成线程b的synchronize代码块后，再唤醒线程a，继续执行线程a。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                System.out.println(<span class="string">"test1"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"test1 wait"</span>);</span><br><span class="line">                    object.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"test1 end"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">test2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                System.out.println(<span class="string">"test2"</span>);</span><br><span class="line">                object.notify();</span><br><span class="line">                System.out.println(<span class="string">"test2 end"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> test1();</span><br><span class="line">        Thread t2=<span class="keyword">new</span> test2();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test1</span><br><span class="line">test1 wait</span><br><span class="line">test2</span><br><span class="line">test2 end</span><br><span class="line">test1 end</span><br></pre></td></tr></table></figure><p>区别的核心在于:<br>1、suspend()在引起当前所在线程阻塞后，不会释放线程占用的锁（如果占用了的话）<br>2、wait() 引起当前所在线程阻塞后，会释放占用的锁，并且必须 wait对象的锁必须被当前线程持有<br>3、wait与notify 需要  synchronized 锁来包裹</p><p>4、suspend会产生死锁问题，而wait不会</p><h4 id="线程的stop（终止）和interrupted（中断）"><a href="#线程的stop（终止）和interrupted（中断）" class="headerlink" title="线程的stop（终止）和interrupted（中断）"></a>线程的stop（终止）和interrupted（中断）</h4><p>线程可以在执行过程中被强行结束吗？当然可以，但是，强行被结束是会出现很多问题的，最初使用的方法叫stop</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SecurityManager security = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkAccess();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread()) &#123; security.checkPermission(SecurityConstants.STOP_THREAD_PERMISSION);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (threadStatus != <span class="number">0</span>) &#123;</span><br><span class="line">            resume();</span><br><span class="line">        &#125;</span><br><span class="line">        stop0(<span class="keyword">new</span> ThreadDeath());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>想必大家也很容易的猜得到，stop方法被弃用的原因是会破坏对象原子性，即使在被synchronize包围时也是如此，因为stop方法是先去释放锁，再去停止整个线程的，这样在释放锁的过程中，可能会出现一释放锁，该锁立马被别的线程锁获取，并发生了修改对象操作后，便停止了线程，这种数据错误不容易在众多代码出找出来，可以说是非常致命，那么对应的又有什么方式去代替它呢，当然有，那就是interrupt()方法，线程中断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        Interruptible b = blocker;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">            b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这个interrupt要如何使用呢，直接像stop一样使用吗？ 并不对，这样其实并不会停止线程。interrupt仅仅是产生了一个中断标记，表示该线程即将要中断了，至于什么时候中断，则是由设计者决定的了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> test());</span><br><span class="line">        t.start();</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().isInterrupted())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thread.interrupt() //中断线程<br>Thread.isInterrupted()判断是否被中断<br>Thread.interrupted()判断是否被中断,并清除当前中断状态</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（三）线程的基本使用</title>
      <link href="/2019/12/18/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2019/12/18/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="Thread类的基本使用（一）"><a href="#Thread类的基本使用（一）" class="headerlink" title="Thread类的基本使用（一）"></a>Thread类的基本使用（一）</h3><h4 id="线程的启动"><a href="#线程的启动" class="headerlink" title="线程的启动"></a>线程的启动</h4><p>线程的启动很简单，要知道所谓线程，其实也是属于Java的一个类而已，你可以通过继承这个类去使用它，也能够直接去使用它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread t=<span class="keyword">new</span> Thread();</span><br><span class="line">        t.start();</span><br><span class="line"><span class="comment">//这样线程就已经启动啦</span></span><br></pre></td></tr></table></figure><p>不过这样的线程并没有任何实体，你可以尝试去启动这个线程，不过这个，这个线程并没有什么实体，已启动就结束了。因为这个线程并没有重写run方法，当然也可以在测试类继承thread类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br></pre></td></tr></table></figure><p>然后再重写run方法，发现……</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"xxx"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印出 xxx。这样就成功了？？这又是什么个逻辑呢</p><p>为什么呢，我们点开thread类的源码，看看start方法是怎么回事</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * This method is not invoked for the main method thread or "system"</span></span><br><span class="line"><span class="comment">        * group threads created/set up by the VM. Any new functionality added</span></span><br><span class="line"><span class="comment">        * to this method in the future may have to also be added to the VM.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * A zero status value corresponds to state "NEW".</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">        * so that it can be added to the group's list of threads</span></span><br><span class="line"><span class="comment">        * and the group's unstarted count can be decremented. */</span></span><br><span class="line">       group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           start0();</span><br><span class="line">           started = <span class="keyword">true</span>;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                   group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">               <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">                 it will be passed up the call stack */</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>好吧，这里有点长，我画一下重点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> start0();</span><br><span class="line"><span class="comment">//这个启动了一个新的线程</span></span><br></pre></td></tr></table></figure><p>再看一下start0是什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>我们发现，这个方法居然没有实体？？不，不对，你仔细看看，它是一个native函数，这是什么，继续深挖。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* openjdk\jdk\src\share\native\java\lang\Thread.c */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"jni.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"jvm.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"java_lang_Thread.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THD <span class="meta-string">"Ljava/lang/Thread;"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ <span class="meta-string">"Ljava/lang/Object;"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STE <span class="meta-string">"Ljava/lang/StackTraceElement;"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STR <span class="meta-string">"Ljava/lang/String;"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAY_LENGTH(a) (sizeof(a)/sizeof(a[0]))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">"start0"</span>,           <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_StartThread&#125;,</span><br><span class="line">    &#123;<span class="string">"stop0"</span>,            <span class="string">"("</span> OBJ <span class="string">")V"</span>, (<span class="keyword">void</span> *)&amp;JVM_StopThread&#125;,</span><br><span class="line">    &#123;<span class="string">"isAlive"</span>,          <span class="string">"()Z"</span>,        (<span class="keyword">void</span> *)&amp;JVM_IsThreadAlive&#125;,</span><br><span class="line">    &#123;<span class="string">"suspend0"</span>,         <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_SuspendThread&#125;,</span><br><span class="line">    &#123;<span class="string">"resume0"</span>,          <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_ResumeThread&#125;,</span><br><span class="line">    &#123;<span class="string">"setPriority0"</span>,     <span class="string">"(I)V"</span>,       (<span class="keyword">void</span> *)&amp;JVM_SetThreadPriority&#125;,</span><br><span class="line">    &#123;<span class="string">"yield"</span>,            <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_Yield&#125;,</span><br><span class="line">    &#123;<span class="string">"sleep"</span>,            <span class="string">"(J)V"</span>,       (<span class="keyword">void</span> *)&amp;JVM_Sleep&#125;,</span><br><span class="line">    &#123;<span class="string">"currentThread"</span>,    <span class="string">"()"</span> THD,     (<span class="keyword">void</span> *)&amp;JVM_CurrentThread&#125;,</span><br><span class="line">    &#123;<span class="string">"countStackFrames"</span>, <span class="string">"()I"</span>,        (<span class="keyword">void</span> *)&amp;JVM_CountStackFrames&#125;,</span><br><span class="line">    &#123;<span class="string">"interrupt0"</span>,       <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_Interrupt&#125;,</span><br><span class="line">    &#123;<span class="string">"isInterrupted"</span>,    <span class="string">"(Z)Z"</span>,       (<span class="keyword">void</span> *)&amp;JVM_IsInterrupted&#125;,</span><br><span class="line">    &#123;<span class="string">"holdsLock"</span>,        <span class="string">"("</span> OBJ <span class="string">")Z"</span>, (<span class="keyword">void</span> *)&amp;JVM_HoldsLock&#125;,</span><br><span class="line">    &#123;<span class="string">"getThreads"</span>,        <span class="string">"()["</span> THD,   (<span class="keyword">void</span> *)&amp;JVM_GetAllThreads&#125;,</span><br><span class="line">    &#123;<span class="string">"dumpThreads"</span>,      <span class="string">"(["</span> THD <span class="string">")[["</span> STE, (<span class="keyword">void</span> *)&amp;JVM_DumpThreads&#125;,</span><br><span class="line">    &#123;<span class="string">"setNativeName"</span>,    <span class="string">"("</span> STR <span class="string">")V"</span>, (<span class="keyword">void</span> *)&amp;JVM_SetNativeThreadName&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> THD</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> OBJ</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> STE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> STR</span></span><br><span class="line"></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_java_lang_Thread_registerNatives(JNIEnv *env, jclass cls)</span><br><span class="line">&#123;</span><br><span class="line">    (*env)-&gt;RegisterNatives(env, cls, methods, ARRAY_LENGTH(methods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这居然是一个c++函数，我们可以看到我们几乎在thread类中的所有操作都有所涉及。主要是这个 JVM_StartThread 方法，这又是什么呢，我们尝试着打开jvm.cpp文件，搜索一下JVM_StartThread ，发现它被一个叫做JVM_ENTRY给调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(<span class="keyword">void</span>, JVM_StartThread(JNIEnv* env, jobject jthread))</span><br><span class="line">  JVMWrapper(<span class="string">"JVM_StartThread"</span>);</span><br><span class="line">  JavaThread *native_thread = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">bool</span> throw_illegal_thread_state = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We must release the Threads_lock before we can post a jvmti event</span></span><br><span class="line">  <span class="comment">// in Thread::start.</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">MutexLocker <span class="title">mu</span><span class="params">(Threads_lock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      throw_illegal_thread_state = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      jlong <span class="built_in">size</span> =</span><br><span class="line">             java_lang_Thread::stackSize(JNIHandles::resolve_non_null(jthread));</span><br><span class="line">      <span class="keyword">size_t</span> sz = <span class="built_in">size</span> &gt; <span class="number">0</span> ? (<span class="keyword">size_t</span>) <span class="built_in">size</span> : <span class="number">0</span>;</span><br><span class="line">      native_thread = <span class="keyword">new</span> JavaThread(&amp;thread_entry, sz);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (native_thread-&gt;osthread() != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// Note: the current thread is not being used within "prepare".</span></span><br><span class="line">        native_thread-&gt;<span class="built_in">prepare</span>(jthread);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (throw_illegal_thread_state) &#123;</span><br><span class="line">    THROW(vmSymbols::java_lang_IllegalThreadStateException());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Thread::start(native_thread);</span><br><span class="line"></span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure><p>其中有一行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">native_thread = <span class="keyword">new</span> JavaThread(&amp;thread_entry, sz);</span><br></pre></td></tr></table></figure><p>有native_thread，那这个JavaThread将一个thread_entry这个指针放入了构造函数中，看一看这个thread_entry</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thread_entry</span><span class="params">(JavaThread* thread, TRAPS)</span> </span>&#123;</span><br><span class="line">    <span class="function">HandleMark <span class="title">hm</span><span class="params">(THREAD)</span></span>;</span><br><span class="line">    <span class="function">Handle <span class="title">obj</span><span class="params">(THREAD, thread-&gt;threadObj())</span></span>;</span><br><span class="line">    <span class="function">JavaValue <span class="title">result</span><span class="params">(T_VOID)</span></span>;</span><br><span class="line">    JavaCalls::call_virtual(&amp;result,obj,</span><br><span class="line">    KlassHandle(THREAD,SystemDictionary::Thread_klass()),</span><br><span class="line">    vmSymbolHandles::run_method_name(),    </span><br><span class="line">    vmSymbolHandles::void_method_signature(),THREAD);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这个vmSymbolHandles::run_method_name(),调用了run的方法，可是，光看方法名还是不能确定是不是run</p><p>所以我们在看看这个vmSymbolHandles,正好发现里面有这样一条语句，</p><figure class="highlight hpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>(run_method_name,<span class="string">"run"</span>)</span><br></pre></td></tr></table></figure><p>成功的调用了run方法，所以，难怪在thread类中始终找不到相应的方法调用，原来是藏在了jvm的实现，cpp里面。</p><p>原来这就是它们之间的联系，从start到start0，再到native，再到jvm，再到cpp，其中的一个宏对象调用了run方法，那么我们再看看，这个run方法又写了啥</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>)</span><br><span class="line">    &#123;        target.run();    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里有一个target，通过它来判断，而这个target又在哪里？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable target;</span><br></pre></td></tr></table></figure><p>哦，原来target在thread这个类中又是runnable所定义了，那runnable又是什么？？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class="line"><span class="comment">     * to create a thread, starting the thread causes the object's</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class="line"><span class="comment">     * thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class="line"><span class="comment">     * take any action whatsoever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Thread#run()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里，俄罗斯套娃也终于结束了，所谓的runnable是一个接口，接口又声明必须要重写run这个方法。</p><p>也就是说，要么我们再开头创建的时候</p><p>要直接继承thread去声明，</p><p>要么直接在测试类中去接口一个runnable，这样才能够启动线程。</p><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test r = <span class="keyword">new</span> test();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"xxxx"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（二）线程的基本认知</title>
      <link href="/2019/12/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2019/12/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="线程的各个术语"><a href="#线程的各个术语" class="headerlink" title="线程的各个术语"></a>线程的各个术语</h3><h4 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h4><p>进程可以比喻为一个app，淘宝，美团，微信都是一个进程，<strong>线程是属于进程的</strong>。就好似微信里面的群发就是多个线程在工作。也可以比喻为，进程是一户人家，家里有多个人（线程），每个人都有各自的职业，在大多数时候一起分工合作（提高效率），少数时候发生冲突，比如一起抢一个厕所（线程阻塞）。</p><h4 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h4><p>在线程这个类中，有一个枚举类，枚举了线程的各个状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line"></span><br><span class="line">        NEW,</span><br><span class="line"></span><br><span class="line">        RUNNABLE,</span><br><span class="line"></span><br><span class="line">        BLOCKED,</span><br><span class="line"></span><br><span class="line">        WAITING,</span><br><span class="line"></span><br><span class="line">        TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">        TERMINATED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>NEW表示尚未启动的线程的线程状态</p><p>RUNNABLE表示它是一个正在运行的线程</p><p>BLOCKED表示线程被阻塞，无法获得想要获得的资源，可能是资源正在被锁定，或等待被解锁</p><p>WAITING由于调用其中一个线程，线程处于等待状态</p><p>TIMED_WAITING具有指定等待时间的等待线程的线程状态</p><p>TERMINATED终止线程的线程状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        test r = <span class="keyword">new</span> test();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        System.out.println(t.getState());</span><br><span class="line">        t.start();</span><br><span class="line">        System.out.println(t.getState());</span><br><span class="line">        t.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(t.getState());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"xxxx"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NEW</span></span><br><span class="line"><span class="comment">//RUNNABLE</span></span><br><span class="line"><span class="comment">//xxxx</span></span><br><span class="line"><span class="comment">//TERMINATED</span></span><br></pre></td></tr></table></figure><p>使用thread.getstate()获得此线程此刻的状态</p><h4 id="线程的切换"><a href="#线程的切换" class="headerlink" title="线程的切换"></a>线程的切换</h4><p>CPU通过<strong>时间片</strong>分配算法来循环执行任务，当前任务执行<strong>一个时间片后会</strong>切换到下一个任务。</p><p>在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。</p><p>所以任务从保存到再加载的过程就是<strong>一次线程切换</strong></p><h4 id="并发的级别"><a href="#并发的级别" class="headerlink" title="并发的级别"></a>并发的级别</h4><p><strong>1 阻塞</strong></p><p>一个线程是阻塞的，那么在其他线程释放资源之前，当前线程无法继续执行。阻塞可以分很多情况，一种是临时阻塞，就是当时要访问的资源暂时被锁住的了无法访问，所以就停留在此地，另一种是碰到了死锁，就会一直被阻塞，直到设计者发现它。</p><p><strong>2 无饥饿（Starvation-Free）</strong></p><p>如果线程之间是有优先级的，那么线程调度的时候总是会倾向于满足高优先级的线程。也就是说，对于同一个资源的分配，是不公平的。锁也分公平锁和非公平锁，对于非公平锁来说，系统允许高优先级的线程插队。这样就有可能导致低优先级的线程产生饥饿。但是如果是公平锁，满足先来后到，那么饥饿就不会产生，不管新来的线程优先级多高，要想获得资源，就必须乖乖排队。这样所有的线程都有机会执行。</p><p><strong>3 无障碍（Obstruction-Free）</strong></p><p>无障碍是一种最弱的非阻塞调度。无障碍表示两个线程可以畅通无阻的行动，但也会出现一些矛盾，比如一起访问同一个资源，又一起修改一个资源，那样就会出现数据的不可见性，对于无障碍的线程来说，一旦检测到这种情况，它就会立即对自己所做的修改进行回滚，确保数据安全。</p><p><strong>4 无锁（Lock-Free）</strong></p><p>无锁的并行都是无障碍的。但是这样会出现很多很多问题，比如说也是同时访问和修改资源，如果发生了资源的争夺，可能会陷入长时间的阻塞或者是直接奔溃，这对于程序来说，无疑是致命的。</p><p><strong>5 无等待（Wait-Free）</strong></p><p>无锁只要求一个线程可以在有限步数内完成操作，而无等待则是在无锁的基础上更进一步进行扩展，它要求所有的线程都必须在有限步数内完成，这样就不会引起线程饥饿问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程（一）并发的概念</title>
      <link href="/2019/12/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/12/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="并发是什么？"><a href="#并发是什么？" class="headerlink" title="并发是什么？"></a>并发是什么？</h3><hr><h4 id="并发是什么？-1"><a href="#并发是什么？-1" class="headerlink" title="并发是什么？"></a>并发是什么？</h4><p>顾名思义，同时发生，一起行动。单纯从Java上讲，并发是个一个thread类，它通过集成这个类，获得对应的api，提高程序的运行效率。不过这里暂时不讲和代码有关的事物，我们先为什么会诞生并发开始讲。</p><p>这里会引入一个新的词叫<strong>摩尔定律</strong>，“每隔18个月到24个月，计算机的性能会翻一倍”。这条定律持续了半个世纪之久，在此期间，计算机的能力也正如定律所描述的一样，不断的倍增。但是在几十年前，这条定律有点不管用了。你可以很简单的看作为，我们不再能够制造出性能更好的芯片，单核的能力已经很难再往上升了，所以在21世纪初，人们开始把多个芯片集成起来，企图用数量的增长去代替质量的不足，thread类，也正因此走进了程序员的视野。复杂的并发远远比单核的串行困难的多，所以，程序员的噩梦来了。</p><h4 id="并发一定优于串行吗？"><a href="#并发一定优于串行吗？" class="headerlink" title="并发一定优于串行吗？"></a>并发一定优于串行吗？</h4><p>这里可以很直接的告诉大家，<strong>并发在大多数的情况下都优于串行。</strong></p><p>举一个例子：</p><p>小明被告知明天要上台演讲，而小明今晚开始到明天要做的事情为</p><p>吃饭（半小时）—&gt;洗澡（半小时）—&gt;构思并撰写演讲稿（1.5+1.5=3小时）—&gt;睡觉（8小时）</p><p>我们可以通过面向对象的编程写出代码，其预计的执行时间为12小时，而引入的并行这个方式，让小明可以边吃饭边思考，边洗澡边思考，让其撰写演讲稿的时间减少一小时</p><p>这样最后的执行时间就变成了11小时，但是呢，无论增加多少线程，都只能让小明的构思时间减少1.5小时，其吃饭洗澡睡觉的时间是无法被改变的，也就是说，极限时间为10.5小时。</p><p>从上面的例子可以得出，并行在绝大多数的情况下都优于串行。少数情况下和串行是没有区别的。这里先不谈特殊情况下出现的并行比串行更差劲的事例，因为这并没有太多意义。要记住，我们是<strong>面向对象编程</strong>。 </p><h4 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h4><h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><p>顾名思义，具有原子的特性，无法被分割。在程序中可以看作为，这个操作不可被中断，各个线程想要执行这个操作也得一个一个来。</p><h5 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h5><p>可见性的意思就是，我们所执行的操作，是可见的。就像我们写一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">1</span>;</span><br><span class="line">a=<span class="number">2</span>;</span><br><span class="line">b=a;</span><br></pre></td></tr></table></figure><p>程序就会把a赋值为1，b赋值为2。这看上去貌似很寻常，因为在串行的情况下运行时，可以永远保持可见性。</p><p>而在并行情况下运行时，却不一定可见，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1</span></span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">i = <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line">j = i;</span><br></pre></td></tr></table></figure><p>在线程1和线程2一起运行之时，你并不能确定，此时的j到底取值是多少，因为此时的i是在两个线程之间共享的，它可以是0，也可以是2，这样对我们并不可见。但我们也可以深挖其中的原理。</p><p><img src="https://gitee.com/antarctica/img_sotre/raw/img/img/kjx.jpg" alt="可见性"></p><p>先看图示，我们的在定义了值为0之后，就会被写入到主内存，而我们在多个线程取i的值的时候，首先会把i加入到本地的缓存当中，读取值就从缓存中读取，因为这样多个线程就不会总从主内存读取，从而提高读取的效率，但是我们在更改了i的值的时候因为有一个线程嗅探的机制，一旦改了i的值，比如a线程修改了i的值后，就会向所有的线程发出一个警告，告诉所有线程i的值已经被更改了，需要重新从主内存中读取。但是呢，发出这样一个信息也是需要时间的，线程b也会因为时间差的关系导致了不能及时获得最新的值。</p><h5 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h5><p>这里会讲到一个新的概念，叫<strong>指令重排</strong>，意思就是程序在实际运行的时候，代码段运行的顺序会和你写的顺序不一样。</p><p>像下面这段代码，可能会出现一个问题，那就是先执行a=3再去执行a=1，这样会造成了最终结果不太一样，不过没关系，这种情况在串行条件下不会发生。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">1</span>;</span><br><span class="line">b=<span class="number">2</span>;</span><br><span class="line">a=<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>但是，在并行条件下，指令重排是怎么发生的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程一</span></span><br><span class="line">i=<span class="number">1</span>;</span><br><span class="line">j=i;</span><br><span class="line">k=i;</span><br><span class="line"><span class="comment">//线程二</span></span><br><span class="line">j=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>像这样，两边线程看似互不干扰，各自有各自的工作，但是我们看到了j和k都在读取同一个变量i，而i在这种情况下会被读取两次，而此时如果发生了指令重排，结果就会变成为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程一</span></span><br><span class="line">i=<span class="number">1</span>;</span><br><span class="line">j=i;</span><br><span class="line">k=j;</span><br><span class="line"><span class="comment">//线程二</span></span><br><span class="line">j=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>而如果线程二发生在j=i之后的话，会出现这样一个状况，线程二修改了j的值，然后线程一再读取了j的值，这样导致最后的结果k=2。你可以看到，其实如果一直按照它本来的写法，这段代码是不可能出问题了，而一旦指令重排出现了这样的问题，谁又能在几十万行代码中找出来呢？</p><p>你说为什么会出现指令重排呢？不发生重排不就没有这样的问题了吗？其实设计者的初衷很简单，<strong>一切都是为了提高效率</strong>。</p><p>为什么这样能够提高效率？这里就要涉及到汇编语言的问题了。简而言之就是，读取和修改一个值需要分很多个步骤，如果将多个步骤一起进行的话会提高效率，从而导致的指令重排，汇编的机制这里暂且不讲。</p><p>那怎样才能解决呢，最简单的方法就是声明volatile关键字，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> i;</span><br></pre></td></tr></table></figure><p>这样谁都不能够对i进行指令重排了，后面会讲到其他的办法，比如synchronized等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
